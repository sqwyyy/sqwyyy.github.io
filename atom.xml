<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-05-18T14:27:51.510Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codeforces Round #641(Div.2)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-641-Div-2/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-641-Div-2/</id>
    <published>2020-05-18T14:22:57.000Z</published>
    <updated>2020-05-18T14:27:51.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Orac-and-LCM"><a href="#C-Orac-and-LCM" class="headerlink" title="C Orac and LCM"></a><a href="https://codeforces.com/contest/1350/problem/C" target="_blank" rel="noopener">C Orac and LCM</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>给了n个数，让求gcd{ lcm{a[i],a[j]} } (i&lt;j)<br>就是n个数，两两配对求出他们的lcm，对于所有lcm在求出gcd</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>根据唯一分解定理</p><script type="math/tex; mode=display">x=p_1^{a_1}*p_2^{a_2}*..*p_k^{a_k} \quad y=p_1^{b_1}*p_2^{b_2}*..*p_k^{b_k}</script><p>则gcd和lcm在算术基本定理下的含义:</p><script type="math/tex; mode=display">lcm(x,y)=p_1^{max(a_1,b_1)}*p_2^{max(a_2,b_2)}*...*p_k^{max(a_k,b_k)}</script><script type="math/tex; mode=display">gcd(x,y)=p_1^{min(a_1,b_1)}*p_2^{min(a_2,b_2)}*...*p_k^{min(a_k,b_k)}</script><p>对于n个数而言:</p><ol><li>如果n-1个数都有质因子x，那么所求答案的gcd一定含有x，不含质因子的那个数一定会与含有质因子的数求lcm，则求出来的数一定含有质因子x，则答案应该乘以这个质因子的<strong>最小</strong></li><li>如果n个数都有质因子x，那么所求答案的gcd一定含有x，则答案应该乘以这个质因子的<strong>第二小</strong></li><li>如果少于n-1个数含有质因子x，则一定存在没有质因子的两个数求lcm，则对答案没有贡献</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>vis代表第j个数为质因子i的幂次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">     ll x;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*j&lt;=x;j++)&#123;</span><br><span class="line">         ll cnt=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(x%j==<span class="number">0</span>)&#123;</span><br><span class="line">           x/=j;</span><br><span class="line">           cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">         vis[j].push_back(cnt);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(x!=<span class="number">1</span>) vis[x].push_back(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(vis[i].<span class="built_in">size</span>()&gt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">       sort(vis[i].<span class="built_in">begin</span>(),vis[i].<span class="built_in">end</span>());</span><br><span class="line">       <span class="keyword">if</span>(vis[i].<span class="built_in">size</span>()==n) ans*=_pow(i,vis[i][<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">else</span> ans*=_pow(i,vis[i][<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Orac-and-Medians"><a href="#D-Orac-and-Medians" class="headerlink" title="D. Orac and Medians"></a><a href="https://codeforces.com/contest/1350/problem/D" target="_blank" rel="noopener">D. Orac and Medians</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h2><p>给出一个长度为 n 的数列，以及一个数字 k ，每次操作可以将一段连续区间 [ l , r ] 内的数字全部替换成该区间的中位数(如果该区间长度为偶数则中位数为a[n/2])，问能否通过适当的操作使得整个数列的 n 个数字全部等于 k </p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h2><p>首先不难看出，如果区间内不存在数字 k 的话一定是 no ，然后我设:</p><ol><li>小于 k 的数为 -1</li><li>大于 k 的数为 1</li><li>等于 k 的数为 0</li></ol><p>对[1,n]区间进行讨论，sum为区间[1,n]的和，有以下三种情况:</p><ol><li>如果 sum == 0 的话，说明等于 k 的数已经位于中位数的位置了，显然为 yes</li><li>如果 sum &gt; 0 的话，说明大于 k 的数比较多，需要减少大于 k 的数量，因为此时经过筛选后，区间内一定存在等于 k 的数，即一定存在着非正数（ -1 和 0 ），<strong>与这些非正数相邻的正数可以组成长度为 2 的区间，此时正数都可以根据规则被同化为非正数</strong>，所以通过适当的操作可以使 sum 不断减小，直到 sum == 0 ，所以这种情况也显然为 yes</li><li>如果 sum &lt; 0 的话，根据上面的思想，我们的目标是令 sum 不断增大，直到 sum == 0 为止，如果负数想要被同化为非负数的话，需要在长度至少为 3 的区间内，满足：<strong>有一个负数以及两个非负数</strong>才行</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> pi =<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">      <span class="keyword">if</span>(a[i]==k) num++,a[i]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;k) a[i]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> a[i]=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!num)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;a[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">1</span>&amp;&amp;a[i<span class="number">-2</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Orac-and-Game-of-Life"><a href="#E-Orac-and-Game-of-Life" class="headerlink" title="E. Orac and Game of Life"></a><a href="https://codeforces.com/contest/1350/problem/E" target="_blank" rel="noopener">E. Orac and Game of Life</a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意:"></a>题意:</h2><p>给个n*m的网格，里面一些格子一开始是白色(0)，另一些是黑色(1)，接下来网格可进行迭代，对于每次迭代，格子里颜色的变化遵循以下规则：</p><ol><li><p>若该格子有相邻格子的颜色与之相同，则颜色翻转</p></li><li><p>若该格子没有相邻格子的颜色与之相同，则颜色不变</p></li></ol><p>有t次询问，每次询问都有i, j, p，表示问第i行第j列格子在第p次迭代后是什么颜色</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h2><p>网格中一共有两种点:</p><ol><li>它的周围没有任何相同的点，不会变换</li><li>它的周围有相同的点，会与周围的点一直变换</li></ol><p><strong>对于第二种点，它周围和它同色的点会每个状态交替变换，且永远不会变成第一种点</strong></p><p><strong>对于第一种点，它周围第一次迭代可能没有相同的点，第k次则可能出现与其相同的点，则会变成第二种点</strong></p><p><strong>对于每个点只要求出第一次发生变化的迭代时刻，则根据t-p计算奇偶性就能知道这个点的颜色</strong></p><p>则问题就变成了</p><p>在一个新的01棋盘，0和1分别代表第一种和第二种点，<strong>求出所有第一种点离最近的第二种点的距离</strong></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li><p>设dp(i,j)表示第(i, j)个格子在dp(i,j)次迭代后会开始变色</p></li><li><p>初始dist数组的值为inf</p></li><li><p>对一开始就能变色的格子进行深搜，设其dp(x,y)=0，并把该格子加入宽搜队列</p></li><li><p>进行宽搜，把宽搜队列中的元素取出来进行四联通的搜索，如果有dp(x,y)+ 1 &lt; dp(xx,yy)，那么dp(xx,yy)更新并将第(xx, yy)格子加入宽搜队列</p></li><li><p>对于dist(i,j)为inf的格子，说明不管怎么迭代永远都不会变色，p &lt; dp(x,y)时，说明直到该次迭代都没有变色，p &gt;= dp(x,y)时，若p - dp(x,y)是奇数就说明这次迭代与初始色相反，偶数就是与初始色相同</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="built_in">string</span> mpt[maxn];</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkboundary</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=n||j&lt;<span class="number">0</span>||j&gt;=m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> by[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;mpt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pr&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(checkboundary(i+bx[k],j+by[k]))&#123;</span><br><span class="line">                    <span class="keyword">int</span> l=i+bx[k],r=j+by[k];</span><br><span class="line">                    <span class="keyword">if</span>(mpt[l][r]==mpt[i][j])&#123;</span><br><span class="line">                      <span class="keyword">if</span>(!vis[l][r]) q.push(make_pair(l,r));</span><br><span class="line">                      dp[l][r]=<span class="number">0</span>;</span><br><span class="line">                      vis[l][r]=<span class="number">1</span>;</span><br><span class="line">                      num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>&amp;&amp;!vis[i][j])&#123;</span><br><span class="line">                q.push(make_pair(i,j));</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                vis[i][j]=<span class="number">1</span>;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;m;j++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;vis[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;q.size()&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        pr now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=now.first+bx[i];</span><br><span class="line">            <span class="keyword">int</span> y=now.second+by[i];</span><br><span class="line">            <span class="keyword">if</span>(checkboundary(x,y))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y]&amp;&amp;dp[x][y]&gt;dp[now.first][now.second]+<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">                    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">                    dp[x][y]=dp[now.first][now.second]+<span class="number">1</span>;</span><br><span class="line">                    q.push(make_pair(x,y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">      ll i,j,p;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j&gt;&gt;p;</span><br><span class="line">      <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&gt;p)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        ll num = p - dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;((mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]-<span class="string">'0'</span>)^<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-Orac-and-LCM&quot;&gt;&lt;a href=&quot;#C-Orac-and-LCM&quot; class=&quot;headerlink&quot; title=&quot;C Orac and LCM&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1350/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C Orac and LCM&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;给了n个数，让求gcd{ lcm{a[i],a[j]} } (i&amp;lt;j)&lt;br&gt;就是n个数，两两配对求出他们的lcm，对于所有lcm在求出gcd&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
      <category term="数论" scheme="https://sqwyyy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>codeforces round #643(Div.2)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/17/codeforces-round-643-Div-2/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/17/codeforces-round-643-Div-2/</id>
    <published>2020-05-17T07:36:17.000Z</published>
    <updated>2020-05-17T07:49:30.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Count-Triangles"><a href="#C-Count-Triangles" class="headerlink" title="C. Count Triangles"></a><a href="https://codeforces.com/contest/1355/problem/C" target="_blank" rel="noopener">C. Count Triangles</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>给你 A , B , C , D</p><p>问有多少种方法构造出三角形(X , Y , Z)使得 A ≤ X ≤ B ≤ Y ≤ C ≤ Z ≤ D</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol><li><p>构成三角形的条件是：x+y&gt;z</p></li><li><p>那么可以进行<strong>枚举x+y来优化,令m=x+y，算出当x+y和为m的时候，有几种可行的构造数量s2，然后去乘s1=max(m-1,d)-c+1就可以了</strong>，前提是s1和s2均非0</p></li><li><p>∵x+y=m, ∴y=m-x, 又∵B≤y=m-x≤C,∴m-C≤x≤m-B，又因为A≤x≤B，所以取交集，该组数目等于右界-左界+1</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll a,b,c,d;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=a+b;i&lt;=b+c;i++)&#123;</span><br><span class="line">        ll s1=<span class="built_in">min</span>(d,i<span class="number">-1</span>)-c+<span class="number">1</span>;</span><br><span class="line">        ll s2=<span class="built_in">min</span>(i-b,b)-<span class="built_in">max</span>(i-c,a)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1&lt;<span class="number">0</span>||s2&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sum+=s1*s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Game-With-Array"><a href="#D-Game-With-Array" class="headerlink" title="D. Game With Array"></a><a href="https://codeforces.com/contest/1355/problem/D" target="_blank" rel="noopener">D. Game With Array</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h2><p>问你能否构造一个长度为 N 且和为 S 的序列</p><p>使得对于该序列你无法找到一个子序列使得子序列的和等于 K 或 S - K (0 &lt;= K &lt;= S)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>猜结论</p><p>我们构造一个前 N - 1项为 1，第 N 项为 S - N + 1 的序列</p><p>对于前 N - 1项构成的序列的和我们设为 K，那么第 N 项构成的序列和就为 S - K</p><p>这样就很好的使用上了题目给的信息，所以盲猜该构造方法是可行的</p><p>那么对于该序列，[ 1 , N - 1 ] 和 [ S - (N - 1) , S ] 的值我们都是可以通过选取子序列得到</p><p>而 [ N , S - N ] 的值无法得到，所以只要判断 N 是否小于等于 S - N 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n , s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s ;</span><br><span class="line">    <span class="keyword">int</span> ans = s - n;</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - <span class="number">1</span> ; i ++) <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-Count-Triangles&quot;&gt;&lt;a href=&quot;#C-Count-Triangles&quot; class=&quot;headerlink&quot; title=&quot;C. Count Triangles&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1355/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C. Count Triangles&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;给你 A , B , C , D&lt;/p&gt;
&lt;p&gt;问有多少种方法构造出三角形(X , Y , Z)使得 A ≤ X ≤ B ≤ Y ≤ C ≤ Z ≤ D&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
      <category term="思维 三分" scheme="https://sqwyyy.github.io/tags/%E6%80%9D%E7%BB%B4-%E4%B8%89%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/Java%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2020-05-10T15:52:45.000Z</published>
    <updated>2020-05-10T15:55:13.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h1><pre><code>1. 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化（因为外部类的非静态方法是需要创建外部类对象才能调用的，而你的静态内部类是不需要外部类对象就可以得到的）。</code></pre><h1 id="成员内部类："><a href="#成员内部类：" class="headerlink" title="成员内部类："></a>成员内部类：</h1><pre><code>1. 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。</code></pre><h1 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h1><pre><code>1. 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。2. 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。</code></pre><h1 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h1><pre><code>1. 没有类名的内部类，不能使用class，extends和implements，没有构造方法。2. 多用于GUI中的事件处理。3. 不能定义静态资源4. 只能创建一个匿名内部类实例。5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效</code></pre><hr><a id="more"></a><h1 id="非静态内部类为什么不能有静态成员变量和静态方法："><a href="#非静态内部类为什么不能有静态成员变量和静态方法：" class="headerlink" title="非静态内部类为什么不能有静态成员变量和静态方法："></a>非静态内部类为什么不能有静态成员变量和静态方法：</h1><p>JVM的类加载规则 ：</p><ol><li>static类型的属性和方法，在类加载的时候就会存在于内存中。</li><li>要想使用某个类的static属性和方法，那么这个类必须要加载到JAVA虚拟机中。</li><li>非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。<br>现在考虑这个情况：在外部类并没有实例化，内部类还没有加载，这时候如果<br>调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内<br>部类的静态成员，这明显是矛盾的。所以非静态内部类不能有静态成员变量或<br>静态方法。</li></ol><hr><h1 id="为什么静态内部类不允许访问外部非静态成员："><a href="#为什么静态内部类不允许访问外部非静态成员：" class="headerlink" title="为什么静态内部类不允许访问外部非静态成员："></a>为什么静态内部类不允许访问外部非静态成员：</h1><p>成员变量也叫实例变量，随着对象的创建而存在<br>静态成员随着类的加载而加载， 生命周期比对象长<br>静态成员在的时候还没成员变量，那还怎么调用</p><hr><h1 id="为什么局部内部类和匿名内部类只能访问final的局部变量"><a href="#为什么局部内部类和匿名内部类只能访问final的局部变量" class="headerlink" title="为什么局部内部类和匿名内部类只能访问final的局部变量?"></a>为什么局部内部类和匿名内部类只能访问final的局部变量?</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> InTest().f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test t=<span class="keyword">new</span> Test();</span><br><span class="line">t.play();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要原因还是生命周期：当我的t.play（）出栈后，play中的局部变量<br>就会随之销毁，但是我的内部类对象可能仍然还存在的（当不在被使用才会被垃圾回收器回收）这时在内部类中访问了局部变量x，但此时的x已经被销毁，内部类访问了一个并不会存在的变量，这就形成了一个矛盾。根本原因就是：内部类的生命周期比局部变量的长</strong><br>其实如果我们编译Test.java文件发现会出现两个class文件，Test.class和Test$InTest.class文件，java会将Test中的局部变量x复制一份到TestInTest.class中当做是内部类的成员常量。这样我们访问的其实就是复制的那个成员常量。</p><p><strong>如何保证数据的一致性：当我们修改局部变量的时候如何保证被复制出来的变量也会同步一致：用final修饰。这样只要这个局部变量进栈初始化的时候就是一个常量。在生命周期内不能被改变，这里注意生命周期。这样就保证了内部类的成员变量和方法的局部变量的一致性。</strong></p><hr><h1 id="内部类为什么能访问外部类的成员变量"><a href="#内部类为什么能访问外部类的成员变量" class="headerlink" title="内部类为什么能访问外部类的成员变量"></a>内部类为什么能访问外部类的成员变量</h1><p>1 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用；<br>2 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值；<br>3 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。<br><a href="https://blog.csdn.net/zhangjg_blog/article/details/20000769" target="_blank" rel="noopener">来源</a><br><a href="https://www.nowcoder.com/questionTerminal/e886e58981c346098a043c3c2ad2d736" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;静态内部类：&quot;&gt;&lt;a href=&quot;#静态内部类：&quot; class=&quot;headerlink&quot; title=&quot;静态内部类：&quot;&gt;&lt;/a&gt;静态内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化（因为外部类的非静态方法是需要创建外部类对象才能调用的，而你的静态内部类是不需要外部类对象就可以得到的）。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;成员内部类：&quot;&gt;&lt;a href=&quot;#成员内部类：&quot; class=&quot;headerlink&quot; title=&quot;成员内部类：&quot;&gt;&lt;/a&gt;成员内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;局部内部类：&quot;&gt;&lt;a href=&quot;#局部内部类：&quot; class=&quot;headerlink&quot; title=&quot;局部内部类：&quot;&gt;&lt;/a&gt;局部内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。
2. 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;匿名内部类：&quot;&gt;&lt;a href=&quot;#匿名内部类：&quot; class=&quot;headerlink&quot; title=&quot;匿名内部类：&quot;&gt;&lt;/a&gt;匿名内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 没有类名的内部类，不能使用class，extends和implements，没有构造方法。
2. 多用于GUI中的事件处理。
3. 不能定义静态资源
4. 只能创建一个匿名内部类实例。
5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。
6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="内部类" scheme="https://sqwyyy.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Session和Cookie</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/Session%E5%92%8CCookie/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/Session%E5%92%8CCookie/</id>
    <published>2020-05-10T15:50:05.000Z</published>
    <updated>2020-05-10T15:55:13.857Z</updated>
    
    <content type="html"><![CDATA[<p><strong>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session,Cookie是实现Session的一种方式（并不是唯一的）</strong><br><a id="more"></a></p><hr><p>1，session 在服务器端，cookie 在客户端（浏览器）<br>2，session 默认被存在在服务器的一个文件里（不是内存）<br>3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）<br>4，session 可以放在 文件、数据库、或内存中都可以。<br>5，用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id</p><hr><p>==如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。==</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session,Cookie是实现Session的一种方式（并不是唯一的）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Session" scheme="https://sqwyyy.github.io/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList和LinkedList</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/ArrayList%E5%92%8CLinkedList/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/ArrayList%E5%92%8CLinkedList/</id>
    <published>2020-05-10T15:45:16.000Z</published>
    <updated>2020-05-10T15:49:31.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的区别"><a href="#简单的区别" class="headerlink" title="简单的区别"></a>简单的区别</h1><ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous） </li><li><p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p></li><li><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p><a id="more"></a></li></ol><h1 id="深度的区别"><a href="#深度的区别" class="headerlink" title="深度的区别"></a>深度的区别</h1><ol><li>对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。</li><li>在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。</li><li><p>LinkedList不支持高效的随机元素访问。</p></li><li><p>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间</p></li></ol><h1 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h1><p>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，并且ArrayList不是线程安全的。</p><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">      * The array buffer into which the elements of the ArrayList are stored. </span></span><br><span class="line"><span class="comment">      * The capacity of the ArrayList is the length of this array buffer. </span></span><br><span class="line"><span class="comment">      */</span>  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;  </span><br><span class="line">   </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">      * The size of the ArrayList (the number of elements it contains). </span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@serial</span> </span></span><br><span class="line"><span class="comment">      */</span>  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><br>被标记为transient的属性在对象被序列化的时候不会被保存。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法:"></a>构造方法:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList带容量大小的构造函数。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">super</span>();    </span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+    </span><br><span class="line">                                               initialCapacity);    </span><br><span class="line">        <span class="comment">// 新建一个数组    </span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ArrayList无参构造函数。默认容量是10。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个包含collection的ArrayList    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    </span><br><span class="line">        elementData = c.toArray();    </span><br><span class="line">        size = elementData.length;    </span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)    </span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="元素存储"><a href="#元素存储" class="headerlink" title="元素存储:"></a>元素存储:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </span><br><span class="line">   RangeCheck(index);  </span><br><span class="line"> </span><br><span class="line">   E oldValue = (E) elementData[index];  </span><br><span class="line">   elementData[index] = element;  </span><br><span class="line">   <span class="keyword">return</span> oldValue;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 将指定的元素添加到此列表的尾部。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">   ensureCapacity(size + <span class="number">1</span>);   </span><br><span class="line">   elementData[size++] = e;  </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 将指定的元素插入此列表中的指定位置。  </span></span><br><span class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);  </span><br><span class="line">   <span class="comment">// 如果数组长度不足，将进行扩容。  </span></span><br><span class="line">   ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></span><br><span class="line">   <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，  </span></span><br><span class="line">   <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。  </span></span><br><span class="line">   <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></span><br><span class="line">   System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);  </span><br><span class="line">   elementData[index] = element;  </span><br><span class="line">   size++;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">   Object[] a = c.toArray();  </span><br><span class="line">   <span class="keyword">int</span> numNew = a.length;  </span><br><span class="line">   ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></span><br><span class="line">   System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);  </span><br><span class="line">   size += numNew;  </span><br><span class="line">   <span class="keyword">return</span> numNew != <span class="number">0</span>;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(  </span><br><span class="line">           <span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);  </span><br><span class="line"> </span><br><span class="line">   Object[] a = c.toArray();  </span><br><span class="line">   <span class="keyword">int</span> numNew = a.length;  </span><br><span class="line">   ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> numMoved = size - index;  </span><br><span class="line">   <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </span><br><span class="line"> </span><br><span class="line">   System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </span><br><span class="line">   size += numNew;  </span><br><span class="line">   <span class="keyword">return</span> numNew != <span class="number">0</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="元素读取"><a href="#元素读取" class="headerlink" title="元素读取:"></a>元素读取:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容:"></a>扩容:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">            &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">                 &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                    minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                    oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">            <span class="keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elementData = <span class="keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除:"></a>元素删除:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除此列表中指定位置上的元素。  </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    modCount++;  </span><br><span class="line">    E oldValue = (E) elementData[index];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);  </span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> oldValue;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的区别&quot;&gt;&lt;a href=&quot;#简单的区别&quot; class=&quot;headerlink&quot; title=&quot;简单的区别&quot;&gt;&lt;/a&gt;简单的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous） &lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="集合类" scheme="https://sqwyyy.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode907</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/Leetcode907/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/Leetcode907/</id>
    <published>2020-05-10T15:40:10.000Z</published>
    <updated>2020-05-10T15:42:56.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。<br>由于答案可能很大，因此返回答案模 10^9 + 7<br><a id="more"></a><br>输入：[3,1,2,4]<br>输出：17<br>解释：<br>子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。<br>最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>找出这个数字左边有几个，右边有几个，赋值为m、n；</li><li>计算以这个数字为最小值的情况有集中：(m+1)*(n+1);</li><li>遍历数组A的每一个元素，以其为最小数的次数乘其本身，再求和就是最后结果啦。</li><li>正常情况下，找出数组中每一个元素左边和右边各有几个连续的、比它小的数字的复杂度为n的二次方，怎样可以优化算法复杂度呢。</li><li>==是否可以维护一个栈，只存比当前栈顶元素更大的元素，在一个元素入栈之前要将所有比它小的数都弹出栈，那么，在这个元素入栈的时候，可以知道左边（连续）比他大的数有几个，出栈的时候会知道右边的数有几个。这样，复杂度变为了O（N）.==</li></ol><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Stack&lt;Integer&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty()&amp;&amp;A[i]&lt;=A[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = stack.pop();</span><br><span class="line">                right[pos]=i-pos-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                left[i]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left[i]=i-stack.peek()-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = stack.pop();</span><br><span class="line">            right[pos]=len-pos-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            ans+=((left[i]+<span class="number">1</span>)*(right[i]+<span class="number">1</span>)%mod)*A[i]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/onfu-za-du-de-javajie-fa-by-mei-shou-gan/" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。&lt;br&gt;由于答案可能很大，因此返回答案模 10^9 + 7&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单调栈" scheme="https://sqwyyy.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>poj2796</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/08/poj2796/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/08/poj2796/</id>
    <published>2020-05-08T15:46:26.000Z</published>
    <updated>2020-05-09T13:05:02.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个序列，要求的是一个区间，这个区间的最小值乘以这个区间数字的和是最大值<br><a id="more"></a></p><p>==单调栈处理的问题就是对每一个节点进行扩展的问题，<br>这个题目要维护的是一个单调递减栈，即从栈顶元素到栈底元素，值是单调递减的，即栈顶元素的值始终是栈的最大值。然后每一个值有属于自己的区间，这个区间目的是为了记录之后的元素向前延伸的用处。<br>向后延伸就靠从1到n扫描元素，(维护单调递减栈)这样当扫描的元素大于栈顶元素时，直接入栈。<br>当扫描的元素等于栈顶元素时，不记录，只将区间延伸到后面。<br>当扫描的元素小于栈顶元素时，这时要计算栈内当前的值。因为扫描的元素时小于栈顶元素的，要求的是一个区间的最小值，所以栈内那些大于该元素的值你会发现没有用处了，只需要将它们的那些区间留下来就对了，这就是向前扩展。==</p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>3 1 6 4 5 2</p><p>一开始每一个数都有自己的区间：</p><p>3(1,1)  1(2,2)  6(3,3)  4(4,4)  5(5,5)  2(6,6)  -1(7,7)后面加一个最小值，为了最后计算栈内元素使用。</p><p>先是3入栈。栈内元素 3(1,1)</p><p>1<3，首先计算一下栈内元素的值，记录下来。然后要把栈内大于1的全部弹出来，但是把它们的区间留下，栈内就变成了1(1,2)。实际上此时就会知道(1,2)这段区间之内的最小值是1。6>1，直接入栈，栈内元素变为1(1,2)，6(3,3)。<br>4<6，将6弹出，弹出之前计算值。然后栈内就变为1(1,2)，4(3,4)。5>4，直接入栈。栈内元素是1(1,2),4(3,4),5(5,5)。会发现因为5没有办法向前扩展了所以会知道5只能够在(5,5)的区间内最小，所以说站内元素是在自己区间的左端点与栈顶元素的右端点，这段区间之内满足着最小值的关系。1是在(1,5)这段区间内最小，4是在(3,5)这段区间内最小。这些值都会在碰到扫描的元素小于该元素时计算，记录下来，就是这样单调栈完成了对每一个元素进行左右扩展的目的。<br>2&lt;5,2&lt;4。要把5(5,5) 4(3,4)分别弹出，它们走之前要计算各自区间的值。<br>最后是-1，目的就是要将栈内所有元素弹出，计算每一个元素左右扩展的值。</p><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[N], lef[N], s[N], top;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">ll ans = <span class="number">-1</span>, tmp;</span><br><span class="line"><span class="keyword">int</span> i, j, n;</span><br><span class="line"><span class="keyword">int</span> ll, rr;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line">a[++n] = <span class="number">-1</span>;</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">0</span> || a[i] &gt; a[s[top - <span class="number">1</span>]])</span><br><span class="line">&#123;</span><br><span class="line">s[top++] = i;</span><br><span class="line">lef[i] = i;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] == a[s[top - <span class="number">1</span>]])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (top &gt;= <span class="number">1</span> &amp;&amp; a[i] &lt; a[s[top - <span class="number">1</span>]])</span><br><span class="line">&#123;</span><br><span class="line">--top;</span><br><span class="line">tmp = <span class="number">1L</span>L*a[s[top]] * (sum[i - <span class="number">1</span>] - sum[lef[s[top]] - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp &gt; ans)</span><br><span class="line">&#123;</span><br><span class="line">ll = lef[s[top]];</span><br><span class="line">rr = i - <span class="number">1</span>;</span><br><span class="line">ans = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lef[i] = lef[s[top]];</span><br><span class="line">s[top++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给出一个序列，要求的是一个区间，这个区间的最小值乘以这个区间数字的和是最大值&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单调栈" scheme="https://sqwyyy.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
</feed>
