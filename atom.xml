<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-10-13T13:02:24.783Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-13T09:52:10.000Z</published>
    <updated>2020-10-13T13:02:24.783Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/hanxiaoran906/article/details/81488232" target="_blank" rel="noopener">总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hanxiaoran906/article/details/81488232&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql主从复制</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/12/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/12/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2020-10-12T13:16:29.000Z</published>
    <updated>2020-10-13T13:03:16.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点</strong>。MySQL 默认采用<strong>异步复制</strong>方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><a id="more"></a><h1 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h1><ul><li><strong>读写分离</strong></li><li><strong>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换</strong></li><li><strong>架构扩展</strong></li></ul><h1 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h1><ol><li>主服务器上面的任何修改都会通过自己的 I/O tread(I/O 线程)保存在二进制日志 <code>Binary log</code> 里面。</li><li>从服务器上面也启动一个 I/O thread，通过配置好的用户名和密码, 连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个<code>Realy log</code>（中继日志）里面。</li><li>从服务器上面同时开启一个 SQL thread 定时检查 <code>Realy log</code>(这个文件也是二进制的)，如果发现有更新立即把更新的内容在本机的数据库上面执行一遍。</li></ol><h1 id="主从复制的模式"><a href="#主从复制的模式" class="headerlink" title="主从复制的模式"></a>主从复制的模式</h1><h2 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h2><p><strong>MySQL默认的复制即是异步的</strong>，MySQL 主服务器上I/O thread 线程将二进制日志写入binlog文件之后就返回客户端结果，不会考虑二进制日志是否完整传输到从服务器以及是否完整存放到从服务器上的relay日志中，这种模式一旦主服务(器)宕机，数据就可能会发生丢失。</p><h2 id="全同步复制"><a href="#全同步复制" class="headerlink" title="全同步复制"></a>全同步复制</h2><p>指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p><h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</p><h1 id="主从库一致性"><a href="#主从库一致性" class="headerlink" title="主从库一致性"></a>主从库一致性</h1><ul><li>半同步复制</li><li>数据中间件（MyCat）</li></ul><p><a href="https://www.jianshu.com/p/faf0127f1cb2" target="_blank" rel="noopener">主从复制</a></p><p><a href="https://blog.csdn.net/xmh594603296/article/details/82461222" target="_blank" rel="noopener">保证主从库一致性的方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点&lt;/strong&gt;。MySQL 默认采用&lt;strong&gt;异步复制&lt;/strong&gt;方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 621 任务调度器</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/09/leetcode-621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/09/leetcode-621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</id>
    <published>2020-10-09T15:04:12.000Z</published>
    <updated>2020-10-12T14:55:24.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的最短时间。</p><p>示例 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br><span class="line">     在本示例中，两个相同类型任务之间必须间隔长度为 n &#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>采用贪心思想，由于相同的任务需要相隔n个时间段，则一轮执行可以为n+1个任务，将出现次数最多的任务排序在前面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.如题得到的时间至少为 retCount &#x3D;（count-1）* (n+1) + 1 &#x3D;&#x3D;&gt; A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A(X为其他任务或者待命)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.再排序下一个任务，如果下一个任务B个数和最大任务数一致， 则retCount++ &#x3D;&#x3D;&gt; A-&gt;B-&gt;X-&gt;A-&gt;B-&gt;X-&gt;A-&gt;B</span><br><span class="line">如果不相同则代表其余任务出现的次数完全可以放在X上</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3、如果空位都插满之后还有任务，那就随便在这些间隔里面插入就可以，因为间隔长度肯定会大于n，在这种情况下就是任务的总数是最小所需时间</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks.length &lt;= <span class="number">1</span> || n &lt; <span class="number">1</span>) <span class="keyword">return</span> tasks.length;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">            counts[tasks[i] - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤1</span></span><br><span class="line">        Arrays.sort(counts);</span><br><span class="line">        <span class="keyword">int</span> maxCount = counts[<span class="number">25</span>];</span><br><span class="line">        <span class="keyword">int</span> retCount = (maxCount - <span class="number">1</span>) * (n + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">24</span>;</span><br><span class="line">        <span class="comment">//步骤2</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; counts[i] == maxCount) &#123;</span><br><span class="line">            retCount++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤3</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(retCount, tasks.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。&lt;/p&gt;
&lt;p&gt;然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。&lt;/p&gt;
&lt;p&gt;你需要计算完成所有任务所需要的最短时间。&lt;/p&gt;
&lt;p&gt;示例 ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：tasks &amp;#x3D; [&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;], n &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     在本示例中，两个相同类型任务之间必须间隔长度为 n &amp;#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="乱搞" scheme="https://sqwyyy.github.io/tags/%E4%B9%B1%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 647 回文子串</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/08/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/08/leetcode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-10-08T14:41:08.000Z</published>
    <updated>2020-10-12T14:55:24.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设dp[i][j]</span><br><span class="line">状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。</span><br><span class="line">状态转移方程：当 s[i] &#x3D;&#x3D; s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]&#x3D;true，否则为false</span><br></pre></td></tr></table></figure><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">10</span>][n+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == s.charAt(j-<span class="number">1</span>) &amp;&amp; (i-j &lt; <span class="number">2</span> || dp[j+<span class="number">1</span>][i-<span class="number">1</span>] == <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[j][i] = <span class="number">1</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">比如对一个字符串 ababa，选择最中间的 a 作为中心点，往两边扩散，第一次扩散发现 left 指向的是 b，right 指向的也是 b，所以是回文串，继续扩散，同理 ababa 也是回文串。</span><br><span class="line"></span><br><span class="line">这个是确定了一个中心点后的寻找的路径，然后我们只要寻找到所有的中心点，问题就解决了。</span><br><span class="line"></span><br><span class="line">中心点一共有多少个呢？看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到 abab，想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 abab，就可以有中心点 ba 扩展一次得到，所以最终的中心点由 2 * len - 1 个，分别是 len 个单字符和 len - 1 个双字符。</span><br><span class="line"></span><br><span class="line">如果上面看不太懂的话，还可以看看下面几个问题：</span><br><span class="line"></span><br><span class="line">为什么有 2 * len - 1 个中心点？</span><br><span class="line">aba 有5个中心点，分别是 a、b、c、ab、ba</span><br><span class="line">abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba</span><br></pre></td></tr></table></figure><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution6472 &#123;</span><br><span class="line">    public int countSubstrings(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 中心扩展法</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        for (int center &#x3D; 0; center &lt; 2 * s.length() - 1; center++) &#123;</span><br><span class="line">            &#x2F;&#x2F; left和right指针和中心点的关系是？</span><br><span class="line">            &#x2F;&#x2F; 首先是left，有一个很明显的2倍关系的存在，其次是right，可能和left指向同一个（偶数时），也可能往后移动一个（奇数）</span><br><span class="line">            &#x2F;&#x2F; 大致的关系出来了，可以选择带两个特殊例子进去看看是否满足。</span><br><span class="line">            int left &#x3D; center &#x2F; 2;</span><br><span class="line">            int right &#x3D; left + center % 2;</span><br><span class="line"></span><br><span class="line">            while (left &gt;&#x3D; 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) &#x3D;&#x3D; s.charAt(right)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;
&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：三个回文子串: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>windows搭建rocketmq集群</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/08/windows%E6%90%AD%E5%BB%BArocketmq%E9%9B%86%E7%BE%A4/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/08/windows%E6%90%AD%E5%BB%BArocketmq%E9%9B%86%E7%BE%A4/</id>
    <published>2020-10-08T06:31:54.000Z</published>
    <updated>2020-10-13T13:03:53.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备环境"><a href="#预备环境" class="headerlink" title="预备环境"></a>预备环境</h1><a id="more"></a><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>Windows</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>JDK1.8、Maven、Git(JDK11以上不支持rocketmq)</p><h1 id="RocketMQ部署"><a href="#RocketMQ部署" class="headerlink" title="RocketMQ部署"></a>RocketMQ部署</h1><p>1.1地址：<a href="http://rocketmq.apache.org/release_notes/release-notes-4.3.0/" target="_blank" rel="noopener">http://rocketmq.apache.org/release_notes/release-notes-4.3.0/</a><br>1.2选择‘Binary’进行下载</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>系统环境变量配置<br>变量名：ROCKETMQ_HOME<br>变量值：MQ解压路径\MQ文件夹名<br>ROCKETMQ_HOME=D:\rocketmq</p><h2 id="boker配置"><a href="#boker配置" class="headerlink" title="boker配置"></a>boker配置</h2><h4 id="a-properties"><a href="#a-properties" class="headerlink" title="a.properties"></a>a.properties</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"> <span class="comment">#所属集群名字</span></span><br><span class="line">    <span class="string">brokerClusterName=rocketmq-cluster</span></span><br><span class="line">    <span class="comment">#broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Amaster叫broker-a,他的slave也叫broker-a</span></span><br><span class="line">    <span class="string">brokerName=broker-a</span></span><br><span class="line">    <span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">    <span class="string">brokerId=0</span></span><br><span class="line">    <span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">    <span class="string">namesrvAddr=127.0.0.1:9876;127.0.0.1:9875</span></span><br><span class="line">    <span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">    <span class="string">defaultTopicQueueNums=4</span></span><br><span class="line">    <span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">    <span class="string">autoCreateTopicEnable=true</span></span><br><span class="line">    <span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">    <span class="string">autoCreateSubscriptionGroup=true</span></span><br><span class="line">    <span class="comment">#Broker 对外服务的监听端口,</span></span><br><span class="line">    <span class="string">listenPort=10942</span></span><br><span class="line">    <span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">    <span class="string">deleteWhen=04</span></span><br><span class="line">    <span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">    <span class="string">fileReservedTime=120</span></span><br><span class="line">    <span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">    <span class="string">mapedFileSizeCommitLog=1073741824</span></span><br><span class="line">    <span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">    <span class="string">mapedFileSizeConsumeQueue=300000</span></span><br><span class="line">    <span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line">    <span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line">    <span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">    <span class="string">diskMaxUsedSpaceRatio=88</span></span><br><span class="line">    <span class="comment">#存储路径</span></span><br><span class="line">    <span class="string">storePathRootDir=D:\cloud\RocketMQ\store\broker-a</span></span><br><span class="line">    <span class="comment">#commitLog 存储路径</span></span><br><span class="line">    <span class="string">storePathCommitLog=D:\cloud\RocketMQ\store\broker-a\commitlog</span></span><br><span class="line">    <span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">    <span class="string">storePathConsumeQueue=D:\cloud\RocketMQ\store\broker-a\consumequeue</span></span><br><span class="line">    <span class="comment">#消息索引存储路径</span></span><br><span class="line">    <span class="string">storePathIndex=D:\cloud\RocketMQ\store\broker-a\index</span></span><br><span class="line">    <span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">    <span class="string">storeCheckpoint=D:\cloud\RocketMQ\store\checkpoint</span></span><br><span class="line">    <span class="comment">#abort 文件存储路径</span></span><br><span class="line">    <span class="string">abortFile=D:\cloud\RocketMQ\store\abort</span></span><br><span class="line">    <span class="comment">#限制的消息大小</span></span><br><span class="line">    <span class="string">maxMessageSize=65536</span></span><br><span class="line">    <span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line">    <span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line">    <span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line">    <span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line">    <span class="comment">#Broker 的角色</span></span><br><span class="line">    <span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line">    <span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line">    <span class="comment">#- SLAVE</span></span><br><span class="line">    <span class="string">brokerRole=ASYNC_MASTER</span></span><br><span class="line">    <span class="comment">#刷盘方式</span></span><br><span class="line">    <span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line">    <span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">    <span class="string">flushDiskType=ASYNC_FLUSH</span></span><br><span class="line">    <span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line">    <span class="comment">#发消息线程池数量</span></span><br><span class="line">    <span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line">    <span class="comment">#拉消息线程池数量</span></span><br><span class="line">    <span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><h4 id="a-s-properties"><a href="#a-s-properties" class="headerlink" title="a-s.properties"></a>a-s.properties</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">    <span class="string">brokerClusterName=rocketmq-cluster</span></span><br><span class="line">    <span class="comment">#broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Amaster叫broker-a,他的slave也叫broker-a</span></span><br><span class="line">    <span class="string">brokerName=broker-b</span></span><br><span class="line">    <span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">    <span class="string">brokerId=1</span></span><br><span class="line">    <span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">    <span class="string">namesrvAddr=127.0.0.1:9876;127.0.0.1:9875</span></span><br><span class="line">    <span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">    <span class="string">defaultTopicQueueNums=4</span></span><br><span class="line">    <span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">    <span class="string">autoCreateTopicEnable=true</span></span><br><span class="line">    <span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">    <span class="string">autoCreateSubscriptionGroup=true</span></span><br><span class="line">    <span class="comment">#Broker 对外服务的监听端口,</span></span><br><span class="line">    <span class="string">listenPort=10922</span></span><br><span class="line">    <span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">    <span class="string">deleteWhen=04</span></span><br><span class="line">    <span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">    <span class="string">fileReservedTime=120</span></span><br><span class="line">    <span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">    <span class="string">mapedFileSizeCommitLog=1073741824</span></span><br><span class="line">    <span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">    <span class="string">mapedFileSizeConsumeQueue=300000</span></span><br><span class="line">    <span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line">    <span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line">    <span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">    <span class="string">diskMaxUsedSpaceRatio=88</span></span><br><span class="line">    <span class="comment">#存储路径</span></span><br><span class="line">    <span class="string">storePathRootDir=D:\clouds\RocketMQ\store\broker-a-s</span></span><br><span class="line">    <span class="comment">#commitLog 存储路径</span></span><br><span class="line">    <span class="string">storePathCommitLog=D:\clouds\RocketMQ\store\broker-a-s\commitlog</span></span><br><span class="line">    <span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">    <span class="string">storePathConsumeQueue=D:\clouds\RocketMQ\store\broker-a-s\consumequeue</span></span><br><span class="line">    <span class="comment">#消息索引存储路径</span></span><br><span class="line">    <span class="string">storePathIndex=D:\clouds\RocketMQ\store\broker-a-s\index</span></span><br><span class="line">    <span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">    <span class="string">storeCheckpoint=D:\clouds\RocketMQ\store\checkpoint</span></span><br><span class="line">    <span class="comment">#abort 文件存储路径</span></span><br><span class="line">    <span class="string">abortFile=D:\clouds\RocketMQ\store\abort</span></span><br><span class="line">    <span class="comment">#限制的消息大小</span></span><br><span class="line">    <span class="string">maxMessageSize=65536</span></span><br><span class="line">    <span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line">    <span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line">    <span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line">    <span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line">    <span class="comment">#Broker 的角色</span></span><br><span class="line">    <span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line">    <span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line">    <span class="comment">#- SLAVE</span></span><br><span class="line">    <span class="string">brokerRole=SLAVE</span></span><br><span class="line">    <span class="comment">#刷盘方式</span></span><br><span class="line">    <span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line">    <span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">    <span class="string">flushDiskType=ASYNC_FLUSH</span></span><br><span class="line">    <span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line">    <span class="comment">#发消息线程池数量</span></span><br><span class="line">    <span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line">    <span class="comment">#拉消息线程池数量</span></span><br><span class="line">    <span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><h4 id="b-properties"><a href="#b-properties" class="headerlink" title="b.properties"></a>b.properties</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"> <span class="comment">#所属集群名字</span></span><br><span class="line">    <span class="string">brokerClusterName=rocketmq-cluster</span></span><br><span class="line">    <span class="comment">#broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Amaster叫broker-a,他的slave也叫broker-a</span></span><br><span class="line">    <span class="string">brokerName=broker-b</span></span><br><span class="line">    <span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">    <span class="string">brokerId=0</span></span><br><span class="line">    <span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">    <span class="string">namesrvAddr=127.0.0.1:9876;127.0.0.1:9875</span></span><br><span class="line">    <span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">    <span class="string">defaultTopicQueueNums=4</span></span><br><span class="line">    <span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">    <span class="string">autoCreateTopicEnable=true</span></span><br><span class="line">    <span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">    <span class="string">autoCreateSubscriptionGroup=true</span></span><br><span class="line">    <span class="comment">#Broker 对外服务的监听端口,</span></span><br><span class="line">    <span class="string">listenPort=10911</span></span><br><span class="line">    <span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">    <span class="string">deleteWhen=04</span></span><br><span class="line">    <span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">    <span class="string">fileReservedTime=120</span></span><br><span class="line">    <span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">    <span class="string">mapedFileSizeCommitLog=1073741824</span></span><br><span class="line">    <span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">    <span class="string">mapedFileSizeConsumeQueue=300000</span></span><br><span class="line">    <span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line">    <span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line">    <span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">    <span class="string">diskMaxUsedSpaceRatio=88</span></span><br><span class="line">    <span class="comment">#存储路径</span></span><br><span class="line">    <span class="string">storePathRootDir=D:\clouds\RocketMQ\store\broker-a</span></span><br><span class="line">    <span class="comment">#commitLog 存储路径</span></span><br><span class="line">    <span class="string">storePathCommitLog=D:\clouds\RocketMQ\store\broker-a\commitlog</span></span><br><span class="line">    <span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">    <span class="string">storePathConsumeQueue=D:\clouds\RocketMQ\store\broker-a\consumequeue</span></span><br><span class="line">    <span class="comment">#消息索引存储路径</span></span><br><span class="line">    <span class="string">storePathIndex=D:\cloud\sRocketMQ\store\broker-a\index</span></span><br><span class="line">    <span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">    <span class="string">storeCheckpoint=D:\clouds\RocketMQ\store\checkpoint</span></span><br><span class="line">    <span class="comment">#abort 文件存储路径</span></span><br><span class="line">    <span class="string">abortFile=D:\clouds\RocketMQ\store\abort</span></span><br><span class="line">    <span class="comment">#限制的消息大小</span></span><br><span class="line">    <span class="string">maxMessageSize=65536</span></span><br><span class="line">    <span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line">    <span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line">    <span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line">    <span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line">    <span class="comment">#Broker 的角色</span></span><br><span class="line">    <span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line">    <span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line">    <span class="comment">#- SLAVE</span></span><br><span class="line">    <span class="string">brokerRole=ASYNC_MASTER</span></span><br><span class="line">    <span class="comment">#刷盘方式</span></span><br><span class="line">    <span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line">    <span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">    <span class="string">flushDiskType=ASYNC_FLUSH</span></span><br><span class="line">    <span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line">    <span class="comment">#发消息线程池数量</span></span><br><span class="line">    <span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line">    <span class="comment">#拉消息线程池数量</span></span><br><span class="line">    <span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><h4 id="b-s-properties"><a href="#b-s-properties" class="headerlink" title="b-s.properties"></a>b-s.properties</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">    <span class="string">brokerClusterName=rocketmq-cluster</span></span><br><span class="line">    <span class="comment">#broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Amaster叫broker-a,他的slave也叫broker-a</span></span><br><span class="line">    <span class="string">brokerName=broker-a</span></span><br><span class="line">    <span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">    <span class="string">brokerId=1</span></span><br><span class="line">    <span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">    <span class="string">namesrvAddr=127.0.0.1:9876;127.0.0.1:9875</span></span><br><span class="line">    <span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">    <span class="string">defaultTopicQueueNums=4</span></span><br><span class="line">    <span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">    <span class="string">autoCreateTopicEnable=true</span></span><br><span class="line">    <span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">    <span class="string">autoCreateSubscriptionGroup=true</span></span><br><span class="line">    <span class="comment">#Broker 对外服务的监听端口,</span></span><br><span class="line">    <span class="string">listenPort=10931</span></span><br><span class="line">    <span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">    <span class="string">deleteWhen=04</span></span><br><span class="line">    <span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">    <span class="string">fileReservedTime=120</span></span><br><span class="line">    <span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">    <span class="string">mapedFileSizeCommitLog=1073741824</span></span><br><span class="line">    <span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">    <span class="string">mapedFileSizeConsumeQueue=300000</span></span><br><span class="line">    <span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line">    <span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line">    <span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">    <span class="string">diskMaxUsedSpaceRatio=88</span></span><br><span class="line">    <span class="comment">#存储路径</span></span><br><span class="line">    <span class="string">storePathRootDir=D:\cloud\RocketMQ\store\broker-a-s</span></span><br><span class="line">    <span class="comment">#commitLog 存储路径</span></span><br><span class="line">    <span class="string">storePathCommitLog=D:\cloud\RocketMQ\store\broker-a-s\commitlog</span></span><br><span class="line">    <span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">    <span class="string">storePathConsumeQueue=D:\cloud\RocketMQ\store\broker-a-s\consumequeue</span></span><br><span class="line">    <span class="comment">#消息索引存储路径</span></span><br><span class="line">    <span class="string">storePathIndex=D:\cloud\RocketMQ\store\broker-a-s\index</span></span><br><span class="line">    <span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">    <span class="string">storeCheckpoint=D:\cloud\RocketMQ\store\checkpoint</span></span><br><span class="line">    <span class="comment">#abort 文件存储路径</span></span><br><span class="line">    <span class="string">abortFile=D:\cloud\RocketMQ\store\abort</span></span><br><span class="line">    <span class="comment">#限制的消息大小</span></span><br><span class="line">    <span class="string">maxMessageSize=65536</span></span><br><span class="line">    <span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line">    <span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line">    <span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line">    <span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line">    <span class="comment">#Broker 的角色</span></span><br><span class="line">    <span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line">    <span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line">    <span class="comment">#- SLAVE</span></span><br><span class="line">    <span class="string">brokerRole=SLAVE</span></span><br><span class="line">    <span class="comment">#刷盘方式</span></span><br><span class="line">    <span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line">    <span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">    <span class="string">flushDiskType=ASYNC_FLUSH</span></span><br><span class="line">    <span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line">    <span class="comment">#发消息线程池数量</span></span><br><span class="line">    <span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line">    <span class="comment">#拉消息线程池数量</span></span><br><span class="line">    <span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><h2 id="namesrv配置"><a href="#namesrv配置" class="headerlink" title="namesrv配置"></a>namesrv配置</h2><p>在conf/2m-2s-async中新建namesrv-a.properties/namesrv-a.properties</p><h4 id="namesrv-a-properties"><a href="#namesrv-a-properties" class="headerlink" title="namesrv-a.properties"></a>namesrv-a.properties</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">listenPort=9876</span></span><br></pre></td></tr></table></figure><h4 id="namesrv-b-properties"><a href="#namesrv-b-properties" class="headerlink" title="namesrv-b.properties"></a>namesrv-b.properties</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">listenPort=9875</span></span><br></pre></td></tr></table></figure><h4 id="修改启动命令"><a href="#修改启动命令" class="headerlink" title="修改启动命令"></a>修改启动命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runserver.cmd</span><br><span class="line">     -server -Xms512m -Xmx512m -Xmn126m -XX:PermSize&#x3D;128m -XX:MaxPermSize&#x3D;320m</span><br><span class="line">runboker.cmd</span><br><span class="line">     -server -Xms512m -Xmx512m -Xmn256m</span><br></pre></td></tr></table></figure><h2 id="启动NAMESERVER"><a href="#启动NAMESERVER" class="headerlink" title="启动NAMESERVER"></a>启动NAMESERVER</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namesrv 启动程序都在bin目录</span><br><span class="line">      mqnamesrv.cmd -c D:\rocketmq\conf\2m-2s-async\nameserver-a.properties</span><br><span class="line">      mqnamesrv.cmd -c D:\rocketmq\conf\2m-2s-async\nameserver-b.properties</span><br></pre></td></tr></table></figure><h2 id="启动BROKER"><a href="#启动BROKER" class="headerlink" title="启动BROKER"></a>启动BROKER</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boker  启动后信息很容器判断是否成功</span><br><span class="line">      mqbroker.cmd -c D:\rocketmq\conf\2m-2s-async\broker-a.properties</span><br><span class="line">      mqbroker.cmd -c D:\rocketmq\conf\2m-2s-async\broker-b.properties</span><br><span class="line">      mqbroker.cmd -c D:\rocketmq\conf\2m-2s-async\broker-a-s.properties</span><br><span class="line">      mqbroker.cmd -c D:\rocketmq\conf\2m-2s-async\broker-b-s.properties</span><br></pre></td></tr></table></figure><h1 id="RocketMQ插件部署"><a href="#RocketMQ插件部署" class="headerlink" title="RocketMQ插件部署"></a>RocketMQ插件部署</h1><p>地址:<a href="https://github.com/apache/rocketmq-externals.git" target="_blank" rel="noopener">https://github.com/apache/rocketmq-externals.git</a></p><p>下载完成之后，进入‘rocketmq-externals\rocketmq-console\src\main\resources’文件夹，打开‘application.properties’进行配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server.contextPath=</span></span><br><span class="line"><span class="string">server.port=8088</span></span><br><span class="line"><span class="comment">#spring.application.index=true</span></span><br><span class="line"><span class="string">spring.application.name=rocketmq-console</span></span><br><span class="line"><span class="string">spring.http.encoding.charset=UTF-8</span></span><br><span class="line"><span class="string">spring.http.encoding.enabled=true</span></span><br><span class="line"><span class="string">spring.http.encoding.force=true</span></span><br><span class="line"><span class="string">logging.config=classpath:logback.xml</span></span><br><span class="line"><span class="comment">#if this value is empty,use env value rocketmq.config.namesrvAddr  NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876</span></span><br><span class="line"><span class="string">rocketmq.config.namesrvAddr=127.0.0.1:9876</span></span><br><span class="line"><span class="comment">#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default true</span></span><br><span class="line"><span class="string">rocketmq.config.isVIPChannel=</span></span><br><span class="line"><span class="comment">#rocketmq-console's data path:dashboard/monitor</span></span><br><span class="line"><span class="string">rocketmq.config.dataPath=/tmp/rocketmq-console/data</span></span><br><span class="line"><span class="comment">#set it false if you don't want use dashboard.default true</span></span><br><span class="line"><span class="string">rocketmq.config.enableDashBoardCollect=true</span></span><br></pre></td></tr></table></figure><h2 id="编译启动"><a href="#编译启动" class="headerlink" title="编译启动"></a>编译启动</h2><p>用CMD进入‘\rocketmq-externals\rocketmq-console’文件夹，执行‘mvn clean package -Dmaven.test.skip=true’，编译生成。</p><p>编译成功之后，Cmd进入‘target’文件夹，执行‘java -jar rocketmq-console-ng-1.0.0.jar’，启动‘rocketmq-console-ng-1.0.0.jar’。(注意看不一定是1.0.0)</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器中输入‘127.0.0.1:配置端口’，成功后即可查看。</p><p><a href="http://127.0.0.1:8088" target="_blank" rel="noopener">http://127.0.0.1:8088</a></p><p><a href="https://blog.csdn.net/yueloveme/article/details/93492263" target="_blank" rel="noopener">来源</a></p><p><a href="https://www.cnblogs.com/linjiqin/p/9553663.html" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备环境&quot;&gt;&lt;a href=&quot;#预备环境&quot; class=&quot;headerlink&quot; title=&quot;预备环境&quot;&gt;&lt;/a&gt;预备环境&lt;/h1&gt;
    
    </summary>
    
    
      <category term="rocketmq" scheme="https://sqwyyy.github.io/categories/rocketmq/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 300 最长上升子序列</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/05/leetcode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/05/leetcode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-10-05T14:46:27.000Z</published>
    <updated>2020-10-12T14:55:24.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义 dp[i]为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度</span><br><span class="line">则</span><br><span class="line">dp[i] &#x3D; Math.max(dp[j]+1,dp[i]);</span><br></pre></td></tr></table></figure><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            maxx = Math.max(dp[i],maxx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [10,9,2,5,3,7,101,18]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 279 完全平方数</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/05/leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/05/leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</id>
    <published>2020-10-05T14:31:44.000Z</published>
    <updated>2020-10-12T14:55:24.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i]代表数值为n所需要的完全平方数最少的个数</span><br><span class="line"></span><br><span class="line">dp[i] &#x3D; min(dp[i-j*j]+1,dp[i]);</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i]=<span class="number">0x3f</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=i;j++)&#123;</span><br><span class="line">                dp[i] = min(dp[i-j*j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 12 &amp;#x3D; 4 + 4 + 4.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 91 解码方法</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/05/leetcode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/05/leetcode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</id>
    <published>2020-10-05T14:22:38.000Z</published>
    <updated>2020-10-12T14:55:24.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p>题目数据保证答案肯定是一个 32 位的整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于最多二位数，所以每次就最多枚举两种情况</p><ul><li>当前位是否满足</li><li>当前位*10 + 前一位 是否满足</li></ul><p>这样进行计数即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">10</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">2</span> &amp;&amp; (s.charAt(i-<span class="number">2</span>) != <span class="string">'0'</span>) &amp;&amp; ((s.charAt(i-<span class="number">2</span>)-<span class="string">'0'</span>)*<span class="number">10</span> + (s.charAt(i-<span class="number">1</span>)-<span class="string">'0'</span>)) &gt;=<span class="number">1</span> &amp;&amp; ((s.charAt(i-<span class="number">2</span>)-<span class="string">'0'</span>)*<span class="number">10</span> + (s.charAt(i-<span class="number">1</span>)-<span class="string">'0'</span>)) &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;一条包含字母 A-Z 的消息通过以下方式进行了编码：&lt;/p&gt;
&lt;p&gt;‘A’ -&amp;gt; 1&lt;br&gt;‘B’ -&amp;gt; 2&lt;br&gt;…&lt;br&gt;‘Z’ -&amp;gt; 26&lt;br&gt;给定一个只包含数字的非空字符串，请计算解码方法的总数。&lt;/p&gt;
&lt;p&gt;题目数据保证答案肯定是一个 32 位的整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&amp;quot;12&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：它可以解码为 &amp;quot;AB&amp;quot;（1 2）或者 &amp;quot;L&amp;quot;（12）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 48 旋转图像</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/05/leetcode-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/05/leetcode-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2020-10-05T14:14:39.000Z</published>
    <updated>2020-10-12T14:55:24.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><a href="https://leetcode-cn.com/problems/rotate-image/solution/man-hua-xuan-zhuan-tu-xiang-by-ivan1/" target="_blank" rel="noopener">图解</a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = matrix[<span class="number">0</span>].length - <span class="number">1</span>; x &lt; y; x++, y--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = x, e = y; s &lt; y; s++, e--) &#123;</span><br><span class="line">                temp = matrix[x][s];</span><br><span class="line">                matrix[x][s] = matrix[e][x];</span><br><span class="line">                matrix[e][x] = matrix[y][e];</span><br><span class="line">                matrix[y][e] = matrix[s][y];</span><br><span class="line">                matrix[s][y] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;/p&gt;
&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定 matrix &amp;#x3D; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [4,5,6],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [7,8,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;原地旋转输入矩阵，使其变为:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [7,4,1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [8,5,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [9,6,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="乱搞" scheme="https://sqwyyy.github.io/tags/%E4%B9%B1%E6%90%9E/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 714 买卖股票的最佳时机含手续费</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/05/leetcode-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/05/leetcode-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</id>
    <published>2020-10-05T13:59:52.000Z</published>
    <updated>2020-10-12T14:55:24.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>和无限次交易一样，只需要扣除手续费即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp1=<span class="number">0</span>, dp2=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp1;</span><br><span class="line">            dp1 = Math.max(dp1,dp2 + prices[i] - fee);</span><br><span class="line">            dp2 = Math.max(dp2,dp1 - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp1,dp2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。&lt;/p&gt;
&lt;p&gt;你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。&lt;/p&gt;
&lt;p&gt;返回获得利润的最大值。&lt;/p&gt;
&lt;p&gt;注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: prices &amp;#x3D; [1, 3, 2, 8, 4, 9], fee &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 能够达到的最大利润:  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在此处买入 prices[0] &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在此处卖出 prices[3] &amp;#x3D; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在此处买入 prices[4] &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在此处卖出 prices[5] &amp;#x3D; 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &amp;#x3D; 8.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 309 最佳买卖股票时机含冷冻期</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/05/leetcode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/05/leetcode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</id>
    <published>2020-10-05T13:58:29.000Z</published>
    <updated>2020-10-12T14:55:24.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] 表示 [0, i] 区间内，在下标为 i 这一天状态为 j 时的最大收益。</span><br><span class="line">里 j 取三个值：</span><br><span class="line"></span><br><span class="line">0 表示不持股；</span><br><span class="line">1 表示持股；</span><br><span class="line">2 表示处在冷冻期。</span><br></pre></td></tr></table></figure><p>第二步：状态转移方程</p><ul><li>不持股可以由这两个状态转换而来：<br>昨天不持股，今天什么都不操作，仍然不持股；<br>昨天持股，今天卖了一股。</li><li>持股可以由这两个状态转换而来：<br>昨天持股，今天什么都不操作，仍然持股；<br>昨天处在冷冻期，今天买了一股；</li><li>处在冷冻期只可以由不持股转换而来，因为题目中说，刚刚把股票卖了，需要冷冻 1 天。</li></ul><p><img src="https://pic.leetcode-cn.com/6dba5214e21684d0383521aaf820b66191106473b9e8a07faaa394e5136b5f47-image.png" alt=""></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">10</span>][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i-<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n][<span class="number">0</span>],dp[n][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。&lt;/p&gt;
&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;p&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;br&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;br&gt;示例:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,0,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 188 买卖股票的最佳时机4</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/04/leetcode-188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA4/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/04/leetcode-188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA4/</id>
    <published>2020-10-04T15:05:54.000Z</published>
    <updated>2020-10-04T15:15:57.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,4,1], k &#x3D; 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>当k &gt;= 2*n 时就是可以进行无限次交易</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[n][k][2] 这里的n表示天数</span><br><span class="line"></span><br><span class="line">dp[i][j][0]：表示第i天交易了j次时卖出后的累计最大利润</span><br><span class="line">dp[i][j][1]：表示第i天交易了j次时买入后的累计最大利润</span><br><span class="line"></span><br><span class="line">转移方程则为</span><br><span class="line">dp[i][j][0] &#x3D; Math.max(dp[i-1][j][0],dp[i-1][j][1] + prices[i]);&#x2F;&#x2F;卖出</span><br><span class="line">dp[i][j][1] &#x3D; Math.max(dp[i-1][j][1],dp[i-1][j-1][0] - prices[i]);&#x2F;&#x2F;买入</span><br></pre></td></tr></table></figure><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= <span class="number">2</span>*n)&#123;</span><br><span class="line">            <span class="keyword">int</span> dp0=<span class="number">0</span>,dp1=-prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dp0;</span><br><span class="line">                dp0 = Math.max(dp0,dp1+prices[i]);</span><br><span class="line">                dp1 = Math.max(dp1,dp0-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.max(dp0,dp1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [][][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">10</span>][k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>],dp[i-<span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);<span class="comment">//卖出</span></span><br><span class="line">                dp[i][j][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);<span class="comment">//买入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            maxx = Math.max(maxx,dp[n-<span class="number">1</span>][i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><p>使用滚动数组优化空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">//当k非常大时转为无限次交易</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;=n/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> dp0=<span class="number">0</span>,dp1=-prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dp0;</span><br><span class="line">                dp0 = Math.max(dp0,dp1+prices[i]);</span><br><span class="line">                dp1 = Math.max(dp1,dp0-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.max(dp0,dp1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义二维数组，交易了多少次、当前的买卖状态  </span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&gt;<span class="number">0</span>;--j) &#123;</span><br><span class="line">                <span class="comment">//处理第k次买入</span></span><br><span class="line">                dp[j-<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[j-<span class="number">1</span>][<span class="number">1</span>], dp[j-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">                <span class="comment">//处理第k次卖出</span></span><br><span class="line">                dp[j][<span class="number">0</span>] = Math.max(dp[j][<span class="number">0</span>], dp[j-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。&lt;/p&gt;
&lt;p&gt;注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,4,1], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在第 1 天 (股票价格 &amp;#x3D; 2) 的时候买入，在第 2 天 (股票价格 &amp;#x3D; 4) 的时候卖出，这笔交易所能获得利润 &amp;#x3D; 4-2 &amp;#x3D; 2 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 123 买卖股票的最佳时机3</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/03/leetcode-123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA3/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/03/leetcode-123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA3/</id>
    <published>2020-10-03T06:23:25.000Z</published>
    <updated>2020-10-04T15:16:01.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,5,0,0,3,1,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dp[n][3][2] 这里的n表示天数</span><br><span class="line"></span><br><span class="line">dp[i][0][0]：表示第i天交易了0次时卖出后的累计最大利润</span><br><span class="line">dp[i][0][1]：表示第i天交易了0次时买入后的累计最大利润</span><br><span class="line">dp[i][1][0]：表示第i天交易了1次时卖出后的累计最大利润</span><br><span class="line">dp[i][1][1]：表示第i天交易了1次时买入后的累计最大利润</span><br><span class="line">dp[i][2][0]：表示第i天交易了2次时卖出后的累计最大利润</span><br><span class="line">dp[i][2][1]：表示第i天交易了2次时买入后的累计最大利润</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">则转移方程为</span><br><span class="line">第一次买入：从初始状态转换而来，或者第一次买入后保持不动</span><br><span class="line">dp[i][0][1] &#x3D; max(dp[i-1][0][1],dp[i-1][0][0]-prices[i])</span><br><span class="line"></span><br><span class="line">第一次卖出：从第一次买入转换而来，或者第一次卖出后保持不动</span><br><span class="line">dp[i][1][0] &#x3D; max(dp[i-1][1][0],dp[i-1][0][1]+prices[i])</span><br></pre></td></tr></table></figure><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// return Integer.MIN_VALUE;</span></span><br><span class="line">        <span class="keyword">int</span> inf = <span class="number">1000000000</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n][<span class="number">2</span>][<span class="number">3</span>];<span class="comment">//持股 已卖出</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=-inf;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>]=-inf;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=-inf;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>]=-inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">2</span>]=-inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(dp[n-<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>],dp[n-<span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.状态：0，未交易，1，买入一次，2卖出1次，3买入2次，4卖出2次</span><br><span class="line">     dp[i][j] 用户手上金钱</span><br><span class="line">2. DP公式</span><br><span class="line">     - dp[i][0] &#x3D; dp[i-1][0]</span><br><span class="line">     - dp[i][1] &#x3D; Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);</span><br><span class="line">     - dp[i][2] &#x3D; Math.max(dp[i-1][2],dp[i-1][1]+prices[i]);</span><br><span class="line">     - dp[i][3] &#x3D; Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);</span><br><span class="line">     - dp[i][4] &#x3D; Math.max(dp[i-1][4],dp[i-1][3]+prices[i]);</span><br></pre></td></tr></table></figure><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>) dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>) dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = j%<span class="number">2</span> == <span class="number">1</span> ? -prices[i] : prices[i];</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) maxx = Math.max(maxx,dp[n-<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。&lt;/p&gt;
&lt;p&gt;注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,3,5,0,0,3,1,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在第 4 天（股票价格 &amp;#x3D; 0）的时候买入，在第 6 天（股票价格 &amp;#x3D; 3）的时候卖出，这笔交易所能获得利润 &amp;#x3D; 3-0 &amp;#x3D; 3 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     随后，在第 7 天（股票价格 &amp;#x3D; 1）的时候买入，在第 8 天 （股票价格 &amp;#x3D; 4）的时候卖出，这笔交易所能获得利润 &amp;#x3D; 4-1 &amp;#x3D; 3 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 122 买卖股票的最佳时机2</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/03/leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/03/leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2/</id>
    <published>2020-10-03T06:08:25.000Z</published>
    <updated>2020-10-04T15:09:36.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>dp(i,0)代表前i天并且在第i天卖出股票获取的最大利润</p><p>dp(i,1)代表前i天并且在第i天买入股票获取的最大利润</p><p>则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">0</span>],dp[n-<span class="number">1</span>][<span class="number">1</span>]);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [7,1,5,3,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在第 2 天（股票价格 &amp;#x3D; 1）的时候买入，在第 3 天（股票价格 &amp;#x3D; 5）的时候卖出, 这笔交易所能获得利润 &amp;#x3D; 5-1 &amp;#x3D; 4 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     随后，在第 4 天（股票价格 &amp;#x3D; 3）的时候买入，在第 5 天（股票价格 &amp;#x3D; 6）的时候卖出, 这笔交易所能获得利润 &amp;#x3D; 6-3 &amp;#x3D; 3 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 121 买卖股票的最佳时机</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/03/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/03/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2020-10-03T06:03:42.000Z</published>
    <updated>2020-10-04T15:09:36.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>维护一个当前最小的价格，然后遍历整个数组，只要当前价格比最小价格高就取一个最大值即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minprice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minprice&gt;prices[i])&#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans=Math.max(ans,prices[i]-minprice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [7,1,5,3,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在第 2 天（股票价格 &amp;#x3D; 1）的时候买入，在第 5 天（股票价格 &amp;#x3D; 6）的时候卖出，最大利润 &amp;#x3D; 6-1 &amp;#x3D; 5 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     注意利润不能是 7-1 &amp;#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 337 打家劫舍3</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/03/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/03/leetcode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/</id>
    <published>2020-10-03T05:38:06.000Z</published>
    <updated>2020-10-04T15:09:36.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 <strong>除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”</strong>。 <strong>如果两个直接相连的房子在同一天晚上被打劫</strong>，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h1><p>对于每个节点而言，能偷取的值就为</p><p><strong>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。</strong></p><p>4个孙子偷的钱加上爷爷的钱如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)</span><br></pre></td></tr></table></figure><p>两个儿子偷的钱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> method2 = rob(root.left) + rob(root.right);</span><br></pre></td></tr></table></figure><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> money = root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        money += (rob(root.left.left) + rob(root.left.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        money += (rob(root.right.left) + rob(root.right.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(money, rob(root.left) + rob(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h1><p>之前思路1中每个都要重复递归多个节点，可以将其记忆化优化时间</p><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;TreeNode,Integer&gt; vis = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(root,vis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root,HashMap&lt;TreeNode,Integer&gt; vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis.containsKey(root)) <span class="keyword">return</span> vis.get(root);</span><br><span class="line">        <span class="keyword">int</span> money = root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            money += dfs(root.left.right,vis) + dfs(root.left.left,vis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            money += dfs(root.right.right,vis) + dfs(root.right.left,vis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftVal = dfs(root.left,vis);</span><br><span class="line">        <span class="keyword">int</span> rightVal = dfs(root.right,vis);</span><br><span class="line">        <span class="keyword">int</span> result = Math.max(money,leftVal + rightVal); </span><br><span class="line">        vis.put(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h1><p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p><p><strong>当前节点选择偷时，那么两个孩子节点就不能选择偷了</strong><br><strong>当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)</strong></p><p>我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 0 代表不偷，1 代表偷<br>任何一个节点能偷到的最大钱的状态可以定义为</p><p><strong>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</strong><br><strong>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</strong></p><p>则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root[<span class="number">0</span>] = Math.max(rob(root.left)[<span class="number">0</span>], rob(root.left)[<span class="number">1</span>]) + Math.max(rob(root.right)[<span class="number">0</span>], rob(root.right)[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">root[<span class="number">1</span>] = rob(root.left)[<span class="number">0</span>] + rob(root.right)[<span class="number">0</span>] + root.val;</span><br></pre></td></tr></table></figure><h1 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = robInternal(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] robInternal(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] left = robInternal(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = robInternal(root.right);</span><br><span class="line"></span><br><span class="line">    result[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">    result[<span class="number">1</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 &lt;strong&gt;除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”&lt;/strong&gt;。 &lt;strong&gt;如果两个直接相连的房子在同一天晚上被打劫&lt;/strong&gt;，房屋将自动报警。&lt;/p&gt;
&lt;p&gt;计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,3,null,3,null,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \   \ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     3   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 小偷一晚能够盗取的最高金额 &amp;#x3D; 3 + 3 + 1 &amp;#x3D; 7.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 213 打家劫舍2</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/02/leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/02/leetcode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/</id>
    <published>2020-10-02T15:16:35.000Z</published>
    <updated>2020-10-04T15:09:36.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。<strong>这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的</strong>。同时，<strong>相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于该房屋是环形，则</p><p>dp(i,0)代表偷第1个房屋不偷第n-1房屋</p><p>dp(i,0)代表不偷第1个房屋偷第n房屋</p><p>则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != n)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">2</span>][<span class="number">0</span>] + num, dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">2</span>][<span class="number">1</span>] + num, dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">2</span>][<span class="number">1</span>] + nums[i-<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = i == n+<span class="number">1</span> ? nums[<span class="number">0</span>] : nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i != n)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">2</span>][<span class="number">0</span>] + num, dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">2</span>][<span class="number">1</span>] + num, dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">2</span>][<span class="number">1</span>] + nums[i-<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n][<span class="number">0</span>],dp[n][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。&lt;strong&gt;这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的&lt;/strong&gt;。同时，&lt;strong&gt;相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,3,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 你不能先偷窃 1 号房屋（金额 &amp;#x3D; 2），然后偷窃 3 号房屋（金额 &amp;#x3D; 2）, 因为他们是相邻的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 198 打家劫舍</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/02/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/02/leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2020-10-02T13:47:07.000Z</published>
    <updated>2020-10-02T13:52:42.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line"></span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>dp(i)代表前i个房间偷盗得到的最大金额，由于不能偷取相邻的</p><p>则转移方程则为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i-<span class="number">2</span>] + a[i], dp[i-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">并且初始化dp数组</span><br><span class="line"></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//代表不偷取第1个房子</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">2</span>] = a[<span class="number">1</span>];<span class="comment">//代表偷取第1个房子</span></span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>],dp[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：偷窃 1 号房屋 (金额 &amp;#x3D; 1) ，然后偷窃 3 号房屋 (金额 &amp;#x3D; 3)。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     偷窃到的最高金额 &amp;#x3D; 1 + 3 &amp;#x3D; 4 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 221 最大正方形</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/02/leetcode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/02/leetcode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</id>
    <published>2020-10-02T13:37:09.000Z</published>
    <updated>2020-10-02T13:52:42.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>dp(i,j)是以矩阵中(i-1,j-1)为右小角的正方形的最大边长。</p><ul><li>若形成正方形（非单 <code>1</code>），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 <code>1</code></li><li>可以换个角度：当前格、上、左、左上都不能受 <code>0</code> 的限制，才能成为正方形</li></ul><p><img src="https://pic.leetcode-cn.com/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">if</span> (grid[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">    dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">10</span>][m+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                maxx = Math.max(maxx,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx * maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 0 1 0 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 0 1 1 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 1 1 1 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 0 0 1 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 593 有效的正方形</title>
    <link href="https://sqwyyy.github.io/archives/2020/10/02/leetcode-593-%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>https://sqwyyy.github.io/archives/2020/10/02/leetcode-593-%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</id>
    <published>2020-10-02T13:33:19.000Z</published>
    <updated>2020-10-02T13:52:42.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定二维空间中四点的坐标，返回四点是否可以构造一个正方形。</p><p>一个点的坐标（x，y）由一个有两个整数的整数数组表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: p1 &#x3D; [0,0], p2 &#x3D; [1,1], p3 &#x3D; [1,0], p4 &#x3D; [0,1]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将这些坐标按照x排序y次级排序之后，计算两点之间的距离构造成的6条边是否相同</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;x, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.first == y.first) <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">        <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;x ,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x.first - y.first)*(x.first - y.first) + (x.second-y.second)*(x.second-y.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = p1[<span class="number">0</span>], y1 = p1[<span class="number">1</span>], x2 = p2[<span class="number">0</span>], y2 = p2[<span class="number">1</span>],  x3 = p3[<span class="number">0</span>], y3 = p3[<span class="number">1</span>],  x4 = p4[<span class="number">0</span>], y4 = p4[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;p;</span><br><span class="line">        p.push_back(make_pair(x1,y1));</span><br><span class="line">        p.push_back(make_pair(x2,y2));</span><br><span class="line">        p.push_back(make_pair(x3,y3));</span><br><span class="line">        p.push_back(make_pair(x4,y4));</span><br><span class="line">        sort(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dist(p[<span class="number">0</span>], p[<span class="number">1</span>]) != <span class="number">0</span> &amp;&amp; dist(p[<span class="number">0</span>], p[<span class="number">1</span>]) == dist(p[<span class="number">1</span>], p[<span class="number">3</span>]) &amp;&amp; dist(p[<span class="number">1</span>], p[<span class="number">3</span>]) == dist(p[<span class="number">3</span>], p[<span class="number">2</span>]) &amp;&amp; dist(p[<span class="number">3</span>], p[<span class="number">2</span>]) == dist(p[<span class="number">2</span>], p[<span class="number">0</span>])   &amp;&amp; dist(p[<span class="number">0</span>],p[<span class="number">3</span>])==dist(p[<span class="number">1</span>],p[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定二维空间中四点的坐标，返回四点是否可以构造一个正方形。&lt;/p&gt;
&lt;p&gt;一个点的坐标（x，y）由一个有两个整数的整数数组表示。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: p1 &amp;#x3D; [0,0], p2 &amp;#x3D; [1,1], p3 &amp;#x3D; [1,0], p4 &amp;#x3D; [0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: True&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sqwyyy.github.io/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
