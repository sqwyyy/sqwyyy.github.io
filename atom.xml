<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-08-17T10:21:28.662Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>final</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/17/final/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/17/final/</id>
    <published>2020-08-17T09:58:39.000Z</published>
    <updated>2020-08-17T10:21:28.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h1><p>final关键字是用来修饰Java中的变量，方法，类的。修饰变量表示这个变量引用的地址不能变化，修饰方法表示这个方法不可覆盖，修饰类表示这个类无法继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;final关键字的作用&quot;&gt;&lt;a href=&quot;#final关键字的作用&quot; class=&quot;headerlink&quot; title=&quot;final关键字的作用&quot;&gt;&lt;/a&gt;final关键字的作用&lt;/h1&gt;&lt;p&gt;final关键字是用来修饰Java中的变量，方法，类的。修饰变量表示
      
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="final" scheme="https://sqwyyy.github.io/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBffuer、StringBuilder</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/17/String%E3%80%81StringBffuer%E3%80%81StringBuilder/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/17/String%E3%80%81StringBffuer%E3%80%81StringBuilder/</id>
    <published>2020-08-17T08:31:16.000Z</published>
    <updated>2020-08-17T13:00:21.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p> 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ <strong>可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的</strong>。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><a id="more"></a><p><strong>区分对象和对象引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);  </span><br><span class="line"></span><br><span class="line">s = <span class="string">"123456"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>首先创建一个String对象s，然后让s的值为“ABCabc”， 然后又让s的值为“123456”。 从打印结果可以看出，s的值确实改变了。那么怎么还说String对象是不可变的呢？ 其实这里存在一个误区： ==s只是一个String对象的引用，并不是对象本身。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。==</p><p>也就是说，s只是一个引用，它指向了一个具体的对象，当s=“123456”; 这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个新的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。</p><h1 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h1><p>​      StringBuffer 和 StringBuilder 都继承<strong>抽象类AbstractStringBuilder</strong>。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><hr><p>​     StringBuilder 类在 Java 5 中被提出，它和 <strong>StringBuffer</strong> 之间的最大不同在于 StringBuilder 的方法<strong>不是线程安全</strong>的（不能同步访问）。</p><hr><h2 id="StringBuiler为什么线程安全以及StringBuffer为什么线程不安全"><a href="#StringBuiler为什么线程安全以及StringBuffer为什么线程不安全" class="headerlink" title="StringBuiler为什么线程安全以及StringBuffer为什么线程不安全"></a>StringBuiler为什么线程安全以及StringBuffer为什么线程不安全</h2><p>以StringBuilder的append()方法为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>.    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">3</span>.        <span class="keyword">return</span> appendNull();</span><br><span class="line"><span class="number">4</span>.    <span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="number">5</span>.    ensureCapacityInternal(count + len);</span><br><span class="line"><span class="number">6</span>.    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line"><span class="number">7</span>.    count += len;</span><br><span class="line"><span class="number">8</span>.    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">9</span>.&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p><strong>count += len不是一个原子操作.</strong><br>假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12</p></li><li><p>ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容</p></li><li><p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面.</p></li></ol><p><strong>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count=5。</strong><br><strong>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</strong></p><hr><p><strong>StringBuffer则根据synchronized关键字实现线程安全</strong></p><p><a href="https://zhuanlan.zhihu.com/p/85867299" target="_blank" rel="noopener">来源1</a><br><a href="https://blog.csdn.net/u011702479/article/details/82262823" target="_blank" rel="noopener">来源2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;p&gt; 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ &lt;strong&gt;可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的&lt;/strong&gt;。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/categories/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Sting" scheme="https://sqwyyy.github.io/tags/Sting/"/>
    
  </entry>
  
  <entry>
    <title>腾讯2020校招笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/16/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/16/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-16T05:58:44.000Z</published>
    <updated>2020-08-17T06:04:57.422Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-03T13:43:27.000Z</published>
    <updated>2020-08-12T15:02:58.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h1><h2 id="内存的含义"><a href="#内存的含义" class="headerlink" title="内存的含义"></a>内存的含义</h2><p><strong>内存就是用于存放数据的硬件。程序执行前需要放到内存中才能被CPU处理。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存的基础知识&quot;&gt;&lt;a href=&quot;#内存的基础知识&quot; class=&quot;headerlink&quot; title=&quot;内存的基础知识&quot;&gt;&lt;/a&gt;内存的基础知识&lt;/h1&gt;&lt;h2 id=&quot;内存的含义&quot;&gt;&lt;a href=&quot;#内存的含义&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存管理" scheme="https://sqwyyy.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JWT实现</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/28/JWT%E5%AE%9E%E7%8E%B0/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/28/JWT%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-28T14:19:50.000Z</published>
    <updated>2020-08-03T10:38:50.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><ul><li><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</p></li><li><p>是一种<strong>认证授权机制</strong>。</p></li><li><p>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p></li><li><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p></li></ul><a id="more"></a><h2 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h2><p><img src="https://pic3.zhimg.com/v2-aa19a381cbae00402e82b710f2db6e06_b.jpg" alt=""></p><p><strong>JWT 认证流程：</strong></p><ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</li><li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li><p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</p></li><li><p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</p></li><li><p>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</p></li><li><p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</p></li></ul><h2 id="Token和JWT的区别"><a href="#Token和JWT的区别" class="headerlink" title="Token和JWT的区别"></a>Token和JWT的区别</h2><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>区别：</strong></p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul><h2 id="使用JWT时需要考虑的问题"><a href="#使用JWT时需要考虑的问题" class="headerlink" title="使用JWT时需要考虑的问题"></a>使用JWT时需要考虑的问题</h2><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/164696755" target="_blank" rel="noopener">JWT详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是JWT&quot;&gt;&lt;a href=&quot;#什么是JWT&quot; class=&quot;headerlink&quot; title=&quot;什么是JWT&quot;&gt;&lt;/a&gt;什么是JWT&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JSON Web Token（简称 JWT）是目前最流行的&lt;strong&gt;跨域认证&lt;/strong&gt;解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是一种&lt;strong&gt;认证授权机制&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JWT 是为了在网络应用环境间&lt;strong&gt;传递声明&lt;/strong&gt;而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JWT" scheme="https://sqwyyy.github.io/categories/JWT/"/>
    
    
      <category term="JWT" scheme="https://sqwyyy.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>NAT协议</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/25/NAT%E5%8D%8F%E8%AE%AE/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/25/NAT%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-07-25T14:47:52.000Z</published>
    <updated>2020-07-27T14:51:28.898Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决ip地址稀缺问题，采用NAT技术使内网（私网）转换为公网</p><a id="more"></a><p>具体的转换规则:</p><p>对于TCP/UDP使用：</p><p>Host’s 私有IPv4 + Port &lt;——-&gt; NAT 公网IPv4 + Port</p><p>对于ICMP使用</p><p>Host’s 私有IPv4 + session ID &lt;——-&gt; NAT 公网IPv4 + session ID</p><p>session ID在NAT设备上是独一无二的</p><p><a href="https://www.jianshu.com/p/4cd76e25b894" target="_blank" rel="noopener">NAT技术</a></p><p><a href="https://www.zhihu.com/question/31332694/answer/118410360" target="_blank" rel="noopener">NAT转换对应规则</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了解决ip地址稀缺问题，采用NAT技术使内网（私网）转换为公网&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="NAT协议" scheme="https://sqwyyy.github.io/tags/NAT%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/22/%E8%BF%9B%E7%A8%8B/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/22/%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-07-22T13:40:01.000Z</published>
    <updated>2020-07-23T14:28:48.223Z</updated>
    
    <content type="html"><![CDATA[<p>进程由进程控制块（PCB）、程序段、数据段三部分组成。</p><ul><li><p>进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。</p><ul><li><p>标识符：与进程相关的唯一标识符，用来区分其他进程。</p></li><li><p>状态：进程有不同的状态，例如运行，就绪，阻塞等。</p></li><li>优先级：为了给处理机调度提供支持，优先级用来区分各种进程的先后执行顺序</li><li>程序计数器：程序中即将执行的下一条指令的地址</li><li>内存指针：包括程序代码的进程相关数据的指针，以及与其他进程贡献那个内存块的指针。</li><li>上下文：进程是需要切换的，切换进程时需要保留进程的上下文信息，以防进程在切换时丢 失现场数据。</li><li>i/o状态信息：包括显示i/o请求，分配给进程的i/o设备和被进程使用的文件列表等。</li><li>记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li></ul></li><li>代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。</li><li>数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据</li></ul><a id="more"></a><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><ol><li>无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li><li>FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li><li>消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li><li>信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li><li>共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。</li></ol><h2 id="进程间五种通信方式的比较"><a href="#进程间五种通信方式的比较" class="headerlink" title="进程间五种通信方式的比较"></a>进程间五种通信方式的比较</h2><ul><li>管道：速度慢，容量有限，只有父子进程能通讯。</li><li>FIFO：任何进程间都能通讯，但速度慢。</li><li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</li><li>信号量：不能传递复杂消息，只能用来同步。</li><li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li></ul><h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><p>线程之间的通信机制有两种，<strong>共享内存和消息传递</strong></p><ul><li>使用volatile是属于共享内存模型</li><li>使用wait和notify方法属于消息传递(wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁)<br><a href="https://blog.csdn.net/jisuanji12306/article/details/86363390" target="_blank" rel="noopener">代码实例</a></li></ul><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p><a href="https://blog.csdn.net/kuangsonghan/article/details/80674777" target="_blank" rel="noopener">来源</a><br>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><p>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><h2 id="关于线程与进程的选取"><a href="#关于线程与进程的选取" class="headerlink" title="关于线程与进程的选取"></a>关于线程与进程的选取</h2><ol><li><p>需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。</p></li><li><p>线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p></li><li><p>因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；</p></li><li><p>并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；</p></li><li><p>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</p></li></ol><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>串行：一次只能取得一个任务并执行这一个任务<br>并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务<br>并发是一种现象：同时运行多个程序或多个任务需要被处理的现象<br><a href="https://www.cnblogs.com/f-ck-need-u/p/11161481.html" target="_blank" rel="noopener">来源</a></p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ol><li>新建：就是刚使用new方法，new出来的线程；</li><li>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li><li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</li><li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li><li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;<br><a href="https://www.cnblogs.com/marsitman/p/11228684.html" target="_blank" rel="noopener">来源</a><br><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt=""></li></ol><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>​      在进程A切换到进程B的过程中，<strong>先保存A进程的上下文</strong>，以便于等A恢复运行的时候，能够知道A进程的下一条指令是什么。然后将<strong>要运行的B进程的上下文恢复到寄存器中</strong>，这个过程被称为<strong>上下文切换</strong>。</p><p>  上下文切换的主要开销有:</p><ol><li>切换页表全局目录</li><li>切换内核态堆栈</li><li>切换硬件上下文</li><li>刷新TLB</li><li>系统调用器的代码执行</li></ol><p><a href="https://zhuanlan.zhihu.com/p/52845869" target="_blank" rel="noopener">上下文切换</a></p><h2 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h2><p><strong>僵尸进程</strong>：</p><p><strong>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><p><strong>孤儿进程</strong>：</p><p><strong>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>孤儿进程并不会有什么危害，真正会对系统构成威胁的是僵尸进程</strong></p><p><strong>僵尸进程产生的问题：</strong></p><p>设想有这样一个父进程：它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵尸进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程</p><p><strong>解决僵尸进程的方法:</strong></p><p>当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶枪毙掉（通过kill发送SIGTERM或者SIGKILL信号）。</p><p>枪毙了元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经“僵尸”的孤儿进程就能瞑目而去了。</p><p><a href="https://www.zhihu.com/question/26432067/answer/70643183" target="_blank" rel="noopener">僵尸进程与孤儿进程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程由进程控制块（PCB）、程序段、数据段三部分组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标识符：与进程相关的唯一标识符，用来区分其他进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态：进程有不同的状态，例如运行，就绪，阻塞等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;优先级：为了给处理机调度提供支持，优先级用来区分各种进程的先后执行顺序&lt;/li&gt;
&lt;li&gt;程序计数器：程序中即将执行的下一条指令的地址&lt;/li&gt;
&lt;li&gt;内存指针：包括程序代码的进程相关数据的指针，以及与其他进程贡献那个内存块的指针。&lt;/li&gt;
&lt;li&gt;上下文：进程是需要切换的，切换进程时需要保留进程的上下文信息，以防进程在切换时丢 失现场数据。&lt;/li&gt;
&lt;li&gt;i/o状态信息：包括显示i/o请求，分配给进程的i/o设备和被进程使用的文件列表等。&lt;/li&gt;
&lt;li&gt;记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。&lt;/li&gt;
&lt;li&gt;数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="https://sqwyyy.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的线程</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/22/JAVA%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/22/JAVA%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-07-22T13:36:31.000Z</published>
    <updated>2020-08-13T11:47:33.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。<strong>调用sleep不会释放对象锁</strong>,在多线程异步时可能用到。</p><p>wait是Object类的方法，对此对象调用wait方法<strong>导致本线程放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池<strong>准备</strong>获得对象锁进入运行状态。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，</span></span><br><span class="line">            <span class="comment">// 我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。</span></span><br><span class="line">            <span class="comment">// 我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MultiThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"enter thread1..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread1 is waiting"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁有两种方式，第一种方式是程序自然离开监视器的范围，</span></span><br><span class="line">                    <span class="comment">// 也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字</span></span><br><span class="line">                    <span class="comment">// 管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。</span></span><br><span class="line">                    MultiThread<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"thread1 is going on..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread1 is being over!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MultiThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"enter thread2..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 notify other thread can release wait status.."</span>);</span><br><span class="line">                <span class="comment">// 由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，</span></span><br><span class="line">                <span class="comment">// 但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。</span></span><br><span class="line">                MultiThread<span class="class">.<span class="keyword">class</span>.<span class="title">notify</span>()</span>;</span><br><span class="line">                System.out.println(<span class="string">"thread2 is sleeping ten millisecond..."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"thread2 is going on..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 is being over!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter thread1...</span><br><span class="line">thread1 is waiting</span><br><span class="line">enter thread2...</span><br><span class="line">thread2 notify other thread can release wait status..</span><br><span class="line">thread2 is sleeping ten millisecond...</span><br><span class="line">thread2 is going on...</span><br><span class="line">thread2 is being over!</span><br><span class="line">thread1 is going on...</span><br><span class="line">thread1 is being over!</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/ab05baf75d75" target="_blank" rel="noopener">来源</a></p><h3 id="中断线程的方法"><a href="#中断线程的方法" class="headerlink" title="中断线程的方法"></a>中断线程的方法</h3><ol><li>使用interrupt()方法中断当前线程：interrupt()其本身并不是一个强制打断线程的方法，其仅仅会修改线程的interrupt标志位，然后让线程自行去读标志位，自行判断是否需要中断。在设计里，如果线程处于休眠状态，那一旦其被调用interrupt()方法，则就没有必要继续休眠下去了，直接抛出异常InterruptedException，让被打断线程去做收尾操作，及时释放线程资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i&#x3D;202053</span><br><span class="line">i&#x3D;202054</span><br><span class="line">i&#x3D;202055</span><br><span class="line">i&#x3D;202056</span><br></pre></td></tr></table></figure><ol><li>如果使用线程池可将线程池的状态修改为STOP状态(该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；)</li></ol><h3 id="控制多个线程按顺序执行"><a href="#控制多个线程按顺序执行" class="headerlink" title="控制多个线程按顺序执行"></a>控制多个线程按顺序执行</h3><p>join方法:</p><ol><li>在子线程中通过join()方法指定顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread2.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//下面三行代码顺序可随意调整，程序运行结果不受影响，因为我们在子线程中通过“join()方法”已经指定了运行顺序。</span></span><br><span class="line">        thread3.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在主线程中通过join()方法指定顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMainJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建单一化线程池newSingleThreadExecutor()实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span> ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(thread1);</span><br><span class="line">        executorService.submit(thread2);</span><br><span class="line">        executorService.submit(thread3);</span><br><span class="line">        executorService.shutdown();        <span class="comment">//使用完毕记得关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jqc874789596/article/details/100557300" target="_blank" rel="noopener">来源</a></p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;wait和sleep的区别&quot;&gt;&lt;a href=&quot;#wait和sleep的区别&quot; class=&quot;headerlink&quot; title=&quot;wait和sleep的区别&quot;&gt;&lt;/a&gt;wait和sleep的区别&lt;/h3&gt;&lt;p&gt;sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。&lt;strong&gt;调用sleep不会释放对象锁&lt;/strong&gt;,在多线程异步时可能用到。&lt;/p&gt;
&lt;p&gt;wait是Object类的方法，对此对象调用wait方法&lt;strong&gt;导致本线程放弃对象锁&lt;/strong&gt;，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池&lt;strong&gt;准备&lt;/strong&gt;获得对象锁进入运行状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="线程" scheme="https://sqwyyy.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>springboot整合swagger</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/10/springboot%E6%95%B4%E5%90%88swagger/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/10/springboot%E6%95%B4%E5%90%88swagger/</id>
    <published>2020-07-10T11:17:56.506Z</published>
    <updated>2020-07-10T11:19:44.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot整合swagger"><a href="#springboot整合swagger" class="headerlink" title="springboot整合swagger"></a>springboot整合swagger</h1><a id="more"></a><h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="新建配置类"><a href="#新建配置类" class="headerlink" title="新建配置类"></a>新建配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 createRestApi函数来构建一个DocketBean</span></span><br><span class="line"><span class="comment">     * 函数名,可以随意命名,喜欢什么命名就什么命名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())<span class="comment">//调用apiInfo方法,创建一个ApiInfo实例,里面是展示在文档页面信息内容</span></span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//控制暴露出去的路径下的实例</span></span><br><span class="line">                <span class="comment">//如果某个接口不想暴露,可以使用以下注解</span></span><br><span class="line">                <span class="comment">//@ApiIgnore 这样,该接口就不会暴露在 swagger2 的页面下</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.example.zwd.springbootswagger2.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建 api文档的详细信息函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                <span class="comment">//页面标题</span></span><br><span class="line">                .title(<span class="string">"Spring Boot Swagger2 构建RESTful API"</span>)</span><br><span class="line">                <span class="comment">//条款地址</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">"http://despairyoke.github.io/"</span>)</span><br><span class="line">                .contact(<span class="string">"zwd"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                <span class="comment">//描述</span></span><br><span class="line">                .description(<span class="string">"API 描述"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此时启动项目，输入<a href="http://localhost:8080/swagger-ui.html，能够看到如下页面，说明已经配置成功了：" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html，能够看到如下页面，说明已经配置成功了：</a></li><li><img src="https://img-blog.csdnimg.cn/20190324120135562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly93YW5nc29uZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt=""></li></ul><h2 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"用户管理相关接口"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"添加用户的接口"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParams</span>(&#123;</span><br><span class="line">            <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"username"</span>, value = <span class="string">"用户名"</span>, defaultValue = <span class="string">"李四"</span>),</span><br><span class="line">            <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"address"</span>, value = <span class="string">"用户地址"</span>, defaultValue = <span class="string">"深圳"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">addUser</span><span class="params">(String username, @RequestParam(required = <span class="keyword">true</span>)</span> String address) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"根据id查询用户的接口"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"id"</span>, value = <span class="string">"用户id"</span>, defaultValue = <span class="string">"99"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"根据id更新用户的接口"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUserById</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>@Api注解可以用来标记当前Controller的功能。</p></li><li><p>@ApiOperation注解用来标记一个方法的作用。</p></li><li><p>@ApiImplicitParam注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。</p></li><li><p>如果有多个参数，则需要使用多个@ApiImplicitParam注解来描述，多个@ApiImplicitParam注解需要放在一个@ApiImplicitParams注解中。</p></li><li><p>需要注意的是，@ApiImplicitParam注解中虽然可以指定参数是必填的，但是却不能代替@RequestParam(required = true)，前者的必填只是在Swagger2框架内必填，抛弃了Swagger2，这个限制就没用了，所以假如开发者需要指定一个参数必填，@RequestParam(required = true)注解还是不能省略。</p></li><li><p>如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中。例如下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户地址"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190324120155527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly93YW5nc29uZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt=""></p></li></ol><p><a href="https://blog.csdn.net/u012702547/article/details/88775298" target="_blank" rel="noopener">来源</a></p><p><a href="https://www.jianshu.com/p/406e9d203300" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;springboot整合swagger&quot;&gt;&lt;a href=&quot;#springboot整合swagger&quot; class=&quot;headerlink&quot; title=&quot;springboot整合swagger&quot;&gt;&lt;/a&gt;springboot整合swagger&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round #645 (Div. 2)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/27/Codeforces-Round-645-Div-2/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/27/Codeforces-Round-645-Div-2/</id>
    <published>2020-05-27T14:06:35.000Z</published>
    <updated>2020-05-27T15:02:04.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Celex-Update"><a href="#Celex-Update" class="headerlink" title="Celex Update"></a><a href="https://codeforces.com/contest/1358/problem/C" target="_blank" rel="noopener">Celex Update</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p><img src="https://espresso.codeforces.com/ab3c49666e913d52a14ebf7f09d741f3f712bacb.png" alt=""></p><p>给定两点坐标，问从一点到另外一点所需权值的不同值有多少。权值即路径上方块值的和</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><img src="https://img2020.cnblogs.com/blog/1626919/202005/1626919-20200527105926672-418175495.png" alt=""></p><p>会发现图中标出的路线每个田字格右上和左下的数字相差1，而这两条路线的数字之和只差1。一直往右再往下是和最小的走法。往右再往下的路径为一条，带有往下再往右拐点的路径（图中紫色路径）为(x1-x2)*(y1-y2)条，加起来输出即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span>)(x2-x1)*(y2-y1)+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-Best-Vacation"><a href="#The-Best-Vacation" class="headerlink" title="The Best Vacation"></a><a href="https://codeforces.com/contest/1358/problem/D" target="_blank" rel="noopener">The Best Vacation</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h2><script type="math/tex; mode=display">一个数组，a[i]表示第i月有a[i]天。在某个月的第j天去会得到j个拥抱，问连续x天最多可以得到的拥抱</script><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>连续的x天可能不在同一年，所以可以将数组存储两遍。</p><script type="math/tex; mode=display">sum1[i]表示a[1]-a[i]的总天数，sum[2]表示a[1]-a[i]的总拥抱数\\</script><p>1~2*n间寻找区间左端点，然后找满足条件的最大值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line">ll t,n,m,x,a[N],sum1[N],sum2[N];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*(<span class="number">1</span>+a)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],a[i+n]=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  sum1[i]=sum1[i<span class="number">-1</span>]+a[i];</span><br><span class="line">sum2[i]=sum2[i<span class="number">-1</span>]+cal(a[i]);</span><br><span class="line">&#125; </span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sum1[i]&lt;=x)&#123;<span class="comment">//如果总天数小于等于x，则ans可取当前的总拥抱数。</span></span><br><span class="line">ans=<span class="built_in">max</span>(ans,sum2[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll l=<span class="number">0</span>,r=i;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)<span class="comment">//找区间左端点</span></span><br><span class="line">&#123;</span><br><span class="line">ll mid = l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sum1[i]-sum1[mid]&lt;x) r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;sum1[i]-sum1[l+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">ll res=sum2[i]-sum2[l+<span class="number">1</span>];<span class="comment">//l+1月的天数可能没有用完</span></span><br><span class="line">ll tmp=x-sum1[i]+sum1[l+<span class="number">1</span>];</span><br><span class="line">res+=(cal(a[l+<span class="number">1</span>])-cal(a[l+<span class="number">1</span>]-tmp));</span><br><span class="line">ans=<span class="built_in">max</span>(ans,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Celex-Update&quot;&gt;&lt;a href=&quot;#Celex-Update&quot; class=&quot;headerlink&quot; title=&quot;Celex Update&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1358/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Celex Update&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://espresso.codeforces.com/ab3c49666e913d52a14ebf7f09d741f3f712bacb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;给定两点坐标，问从一点到另外一点所需权值的不同值有多少。权值即路径上方块值的和&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>hashcode</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/hashcode/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/hashcode/</id>
    <published>2020-05-25T13:41:08.000Z</published>
    <updated>2020-08-17T09:58:11.168Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h1><p><strong>值类型是存储在内存中的堆栈（以后简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。</strong></p><p>  <strong>==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。</strong></p><p> <strong>equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。</strong></p><p><strong>==比较的是两个对象的地址，而equals比较的是两个对象的内容。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String a = <span class="string">"qqq"</span>;</span><br><span class="line">String b = <span class="string">"qqq"</span>;  <span class="comment">//保存到字符串缓冲池里，当有相同值的对象，就引用该对象，否则重新创建字符串</span></span><br><span class="line">System.out.println(a==b);  <span class="comment">//比较的是地址</span></span><br><span class="line">System.out.println(a.equals(b));  <span class="comment">//比较的是值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>程序在运行的时候会创建一个字符串缓冲池当使用 b = “qqq” 这样的表达是创建字符串的时候，程序首先会在这个String缓冲池中寻找相同值的对象，在第一个程序中，a先被放到了池中，所以在b被创建的时候，程序找到了具有相同值的 a</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String a = <span class="string">"money"</span>;</span><br><span class="line">  String b = <span class="keyword">new</span> String(<span class="string">"money"</span>);</span><br><span class="line">  System.out.println(a==b);  <span class="comment">//比较的是地址</span></span><br><span class="line">System.out.println(a.equals(b));  <span class="comment">//比较的是值</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p> <strong>第二段程序中，使用了 new 操作符，他明白的告诉程序：”我要一个新的！不要旧的！”于是一个新的”money”Sting对象被创建在内存中。他们的值相同，但是位置不同。</strong></p><p><a href="https://blog.csdn.net/zxl1148377834/article/details/82858192" target="_blank" rel="noopener">equals与==的区别</a></p><h2 id="为什么重写equals要重写hashcode"><a href="#为什么重写equals要重写hashcode" class="headerlink" title="为什么重写equals要重写hashcode"></a>为什么重写equals要重写hashcode</h2><p>因为在hashmap等集合类中要根据各个类的hashcode来计算哈希值，如果根据equals来进行比较，两个相同的类在hashmap中存储的位置不同。</p><ul><li>默认情况下equals是比较对象的内存地址</li><li>hashcode也是根据对象的内存地址计算</li></ul><p><a href="https://www.zhihu.com/search?type=content&amp;q=%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E8%A6%81%E9%87%8D%E5%86%99hashcode" target="_blank" rel="noopener">为什么重写equals要重写hashcode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;equals与-的区别&quot;&gt;&lt;a href=&quot;#equals与-的区别&quot; class=&quot;headerlink&quot; title=&quot;equals与==的区别&quot;&gt;&lt;/a&gt;equals与==的区别&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;值类型是存储在内存中的堆栈（以后简称栈
      
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/tags/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%AD%BB%E9%94%81/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%AD%BB%E9%94%81/</id>
    <published>2020-05-25T13:37:13.000Z</published>
    <updated>2020-05-25T13:38:10.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><a id="more"></a><h2 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h2><p>死锁的出现必须同时满足以下四个条件，缺一不可。</p><ul><li><p>互斥：所谓互斥就是进程在某一时间内独占资源（更准确得说，对于某个资源访问有限制。若资源数量有限，也有可能产生死锁）。</p></li><li><p>请求与保持：已经持有某一资源的进程不必释放当前拥有的资源，就可以申请并获得更多的资源。</p></li><li>不可剥夺：进程已获得资源，在末使用完之前，不能强行剥夺。</li><li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系，每个进程都在等待循环链中另一进程持有的资源。</li></ul><h2 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h2><ul><li><p>打破互斥条件。</p><ul><li><p>即允许进程同时访问某些资源。</p></li><li><p>但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。</p></li></ul></li><li><p>打破请求与保持条件</p><ul><li><p>进程在运行前一次性地向系统申请它所需要的全部资源。</p></li><li><p>如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。</p></li><li>由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。</li></ul></li><li><p>打破不可剥夺条件</p><ul><li><p>允许进程强行从占有者那里夺取某些资源。</p></li><li><p>当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。</p></li></ul></li><li><p>打破循环等待条件</p><ul><li><p>前面三种预防策略都很棘手，所以大部分预防死锁的算法都把重心放在这里。</p></li><li><p>为预防循环等待条件的出现，可以实行资源<strong>有序分配策略</strong>。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成循环链。<strong>所有进程对资源的请求必须严格按资源序号递增的顺序提出</strong>。进程占用了小号资源，才能申请大号资源，就不会产生循环链，从而预防了死锁。</p></li></ul></li></ul><h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><p>可以使用<strong>银行家算法</strong>来避免死锁产生<br>银行家算法有以下数据结构</p><ul><li><p>可利用资源向量Available<br>是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果- Available[j]=K，则表示系统中现有Rj类资源K个。</p></li><li><p>最大需求矩阵Max<br>这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。</p></li><li>3 分配矩阵Allocation<br>这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。</li><li>4 需求矩阵Need。<br>这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。</li></ul><p>列子：<br>| Process | Allocation | Need    | Available |<br>| ———- | ————— | ———- | ————- |<br>| P0      | 0,0,3,2    | 0,0,1,2 | 1,6,2,2   |<br>| P1      | 1,0,0,0    | 1,7,5,0 |           |<br>| P2      | 1,3,5,4    | 2,3,5,6 |           |<br>| P3      | 0,3,3,2    | 0,6,5,2 |           |<br>| P4      | 0,0,1,4    | 0,6,5,6 |           |<br>(1)该进程是否安全<br>(2)若进程P2提出请求（1，2，2，2）后，系统能否将资源分配给它</p><p>(1)<br>| Process | Allocation | Need    | Allocation | Work+Allocation | Finsh |<br>| ———- | ————— | ———- | ————— | ———————- | ——- |<br>| P0      | 0,0,3,2    | 0,0,1,2 | 0,0,3,2    | 1,6,5,4         | true  |<br>| P1      | 1,0,0,0    | 1,7,5,0 | 0,3,3,2    | 1,9,8,6         | true  |<br>| P2      | 1,3,5,4    | 2,3,5,6 | 0,0,1,4    | 1,9,9,10        | true  |<br>| P3      | 0,3,3,2    | 0,6,5,2 | 1,0,0,0    | 2,9,9,10        | true  |<br>| P4      | 0,0,1,4    | 0,6,5,6 | 1,3,5,4    | 3,12,14,14      | true  |</p><p>存在一个安全序列{P0,P3,P4,P1,P2}</p><p>(2) P2提出请求（1，2，2，2）后，因Request&lt;=Need,Request&lt;=Available,故系统可考虑将资源分配给它，分配后Available变成（0，4，0，0）进行安全性检测，发现不能满足任何进程的需求，系统进入不安全状态，所以系统不能向P2分配资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;h2 id=&quot;什么是死锁&quot;&gt;&lt;a href=&quot;#什么是死锁&quot; class=&quot;headerlink&quot; title=&quot;什么是死锁&quot;&gt;&lt;/a&gt;什么是死锁&lt;/h2&gt;&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="https://sqwyyy.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础知识</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-25T13:36:34.000Z</published>
    <updated>2020-05-27T14:19:48.649Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-05-25T13:33:47.000Z</published>
    <updated>2020-05-25T13:38:10.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本类型和引用类型在内存中的保存"><a href="#基本类型和引用类型在内存中的保存" class="headerlink" title="基本类型和引用类型在内存中的保存"></a>基本类型和引用类型在内存中的保存</h1><p>Java中数据类型分为两大类：<strong>基本类型和对象类型</strong><br>变量也有两种类型：<strong>基本类型和引用类型</strong></p><p><strong>基本类型的变量保存原始值，即它代表的值就是数值本身</strong><br><strong>引用类型的变量保存引用值，”引用值”指向内存空间的地址，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置</strong>。<br>基本类型包括：byte,short,int,long,char,float,double,boolean<br>引用类型包括：类类型，接口类型和数组</p><a id="more"></a><h1 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h1><p>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，<strong>后面方法中的操作都是对形参这个值的修改，不影响实际参数的值</strong>。</p><h1 id="引用传递："><a href="#引用传递：" class="headerlink" title="引用传递："></a>引用传递：</h1><p>也称为传地址。方法调用时，<strong>实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址</strong>；<br>在方法执行中，形参和实参内容相同，指向同一块内存地址，<strong>方法执行中对引用的操作将会影响到实际对象</strong>。</p><p><strong>在java中无论是浅拷贝还是深拷贝都要实现Clonenable接口，并且重写clone方法</strong></p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number=<span class="number">123</span>;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.setNumber(number);</span><br><span class="line">        Student stu2 =stu1;</span><br><span class="line">        stu2.setNumber(<span class="number">321</span>);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        System.out.println(stu1 == stu2);</span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());</span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">true</span><br><span class="line">学生1：321</span><br><span class="line">学生2：123</span><br></pre></td></tr></table></figure></p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number=<span class="number">123</span>;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.setNumber(number);</span><br><span class="line">        Student stu2 = (Student)stu1.clone();</span><br><span class="line">        stu2.setNumber(<span class="number">321</span>);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        System.out.println(stu1 == stu2);</span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());</span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Student stu = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                stu = (Student)<span class="keyword">super</span>.clone();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">false</span><br><span class="line">学生1：321</span><br><span class="line">学生2：123</span><br></pre></td></tr></table></figure></p><h1 id="clone和new的区别"><a href="#clone和new的区别" class="headerlink" title="clone和new的区别"></a>clone和new的区别</h1><ul><li><p>共同点：都是分配内存，对象都是指向不同的内存地址</p></li><li><p>不同点：new创建一个对象，clone复制一个对象。new是返回的新对象，而调用clone()方法时，拷贝对象已经包含了一些原来对象的信息，而不是对象的初始信息</p></li></ul><h1 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h1><p>在Object类的clone()是一个native方法，如果实现clone()方法的类没有实现Cloneable接口，并调用了Object的clone()方法（也就是调用了 super.clone()方法），那么Object的clone()方法就会抛出CloneNotSupportedException异常</p><p><a href="https://www.jianshu.com/p/e8c6155d9694" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本类型和引用类型在内存中的保存&quot;&gt;&lt;a href=&quot;#基本类型和引用类型在内存中的保存&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型在内存中的保存&quot;&gt;&lt;/a&gt;基本类型和引用类型在内存中的保存&lt;/h1&gt;&lt;p&gt;Java中数据类型分为两大类：&lt;strong&gt;基本类型和对象类型&lt;/strong&gt;&lt;br&gt;变量也有两种类型：&lt;strong&gt;基本类型和引用类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本类型的变量保存原始值，即它代表的值就是数值本身&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;引用类型的变量保存引用值，”引用值”指向内存空间的地址，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置&lt;/strong&gt;。&lt;br&gt;基本类型包括：byte,short,int,long,char,float,double,boolean&lt;br&gt;引用类型包括：类类型，接口类型和数组&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JAVA拷贝" scheme="https://sqwyyy.github.io/tags/JAVA%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-05-25T13:32:05.000Z</published>
    <updated>2020-05-25T13:40:14.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用阻塞队列"><a href="#为什么要用阻塞队列" class="headerlink" title="为什么要用阻塞队列"></a>为什么要用阻塞队列</h1><p>在并发编程中，有时候需要使用<strong>线程安全的队列</strong>。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。</p><ol><li>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li><li>非阻塞的实现方式则可以使用循环CAS的方式来实现。</li></ol><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<strong>这两个附加的操作支持阻塞的插入和移除方法</strong>, 意指再读取和插入操作情况下可能(注意是可能)会出现阻塞。</p><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>该阻塞队列是<strong>基于数组实现的，必须制定大小且不可变</strong>，同时使用ReentrantLock来实现并发问题的解决。同时需要注意的是<strong>ArrayBlockingQueue只有一把锁，put和take操作会相互阻塞</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;  <span class="comment">//队列的底层为数组，是个循环数组</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;  <span class="comment">//从队列中取元素的索引，用于take、poll、remove</span></span><br><span class="line"><span class="keyword">int</span> putIndex;  <span class="comment">//向队列中存放元素的索引，用于put、offer、add</span></span><br><span class="line"><span class="keyword">int</span> count;  <span class="comment">//队列中的元素数</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock; <span class="comment">//队列中的锁机制，可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">//notEmpty条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  <span class="comment">//notFull条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;  <span class="comment">//迭代器对象</span></span><br></pre></td></tr></table></figure><p>put操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Objects.requireNonNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>take 操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>LinkedBlockingQueue和ArrayBlockingQueue十分相似，其底层是<strong>借由链表</strong>实现。除此之外，还有一个不同点，<strong>LinkedBlockingQueue拥有两个锁，因此put和take的线程可以同时运行</strong>,count元素是用AtomicInteger来修饰的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;  <span class="comment">//元素</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//next指针</span></span><br><span class="line">        </span><br><span class="line">        Node(E x) &#123;  <span class="comment">//有参构造函数</span></span><br><span class="line">          item = x;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;  <span class="comment">//容量，默认为 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();  <span class="comment">//队列中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;  <span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//拿锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();  <span class="comment">//拿锁的条件，队列不为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">//放锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();  <span class="comment">//放锁的条件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>put操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">             * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">             * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">             * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">             * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">             * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>take操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E x;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p>PriorityBlockingQueue可以根据自定义的优先级来构建一个有序的二叉堆数据结构，这种结构在插入数据的时候就能够根据自定义的排序规则（对象实现Compareable和Comparator）来生成一个有序的堆，通过这样来定义一个按优先级顺序的队列集合，不再是默认的先进先出规则，需要注意的是优先级队列的put方法并不阻塞，默认的数组的长度是11，在插入满的时候会扩容。take方法在队列为空的时候会进入阻塞状态。</p><h1 id="生产者消费者模型的实现"><a href="#生产者消费者模型的实现" class="headerlink" title="生产者消费者模型的实现"></a>生产者消费者模型的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/29 - 18:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; q;</span><br><span class="line">    <span class="keyword">public</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> Condition producelock = lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> Condition wastelock = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span>  <span class="title">produce</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(cnt == num) &#123;</span><br><span class="line">                    producelock.await();</span><br><span class="line">                &#125;</span><br><span class="line">                String tmp = <span class="string">"生产线程"</span>+Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">"我已经制造了"</span>+Thread.currentThread().getName());</span><br><span class="line">                cnt++;</span><br><span class="line">                q.add(tmp);</span><br><span class="line">                wastelock.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">wate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    wastelock.await();</span><br><span class="line">                &#125;</span><br><span class="line">                String tmp = q.poll();</span><br><span class="line">                System.out.println(tmp);</span><br><span class="line">                <span class="comment">//System.out.println("我已经消耗了"+Thread.currentThread().getName()+" "+tmp);</span></span><br><span class="line">                cnt--;</span><br><span class="line">                producelock.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool(<span class="number">3</span>);</span><br><span class="line">        produce p = pool.<span class="keyword">new</span> produce();</span><br><span class="line">        wate w = pool.<span class="keyword">new</span> wate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(p).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(w).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 为什么要用阻塞队列</span><br><span class="line">在并发编程中，有时候需要使用**线程安全的队列**。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 非阻塞的实现方式则可以使用循环CAS的方式来实现。</span><br><span class="line"></span><br><span class="line"># 基本概念</span><br><span class="line">阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。**这两个附加的操作支持阻塞的插入和移除方法**, 意指再读取和插入操作情况下可能(注意是可能)会出现阻塞。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ArrayBlockingQueue</span><br><span class="line">该阻塞队列是**基于数组实现的，必须制定大小且不可变**，同时使用ReentrantLock来实现并发问题的解决。同时需要注意的是**ArrayBlockingQueue只有一把锁，put和take操作会相互阻塞**。</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">    <span class="keyword">final</span> Object[] items;  <span class="comment">//队列的底层为数组，是个循环数组</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;  <span class="comment">//从队列中取元素的索引，用于take、poll、remove</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;  <span class="comment">//向队列中存放元素的索引，用于put、offer、add</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">//队列中的元素数</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock; <span class="comment">//队列中的锁机制，可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">//notEmpty条件对象，由lock创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  <span class="comment">//notFull条件对象，由lock创建</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;  <span class="comment">//迭代器对象</span></span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>put操作:<br>​```java<br>public void put(E e) throws InterruptedException {<br>        Objects.requireNonNull(e);<br>        final ReentrantLock lock = this.lock;<br>        lock.lockInterruptibly();<br>        try {<br>            while (count == items.length)<br>                notFull.await();<br>            enqueue(e);<br>        } finally {<br>            lock.unlock();<br>        }<br>    }</p><p>​<code>take 操作​</code>java<br>public E take() throws InterruptedException {<br>        final ReentrantLock lock = this.lock;<br>        lock.lockInterruptibly();<br>        try {<br>            while (count == 0)<br>                notEmpty.await();<br>            return dequeue();<br>        } finally {<br>            lock.unlock();<br>        }<br>    }</p><p>​```</p><h1 id="LinkedBlockingQueue-1"><a href="#LinkedBlockingQueue-1" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>LinkedBlockingQueue和ArrayBlockingQueue十分相似，其底层是<strong>借由链表</strong>实现。除此之外，还有一个不同点，<strong>LinkedBlockingQueue拥有两个锁，因此put和take的线程可以同时运行</strong>,count元素是用AtomicInteger来修饰的<br>​```java<br>static class Node<E> {<br>        E item;  //元素<br>        Node<E> next;//next指针</p><pre><code>    Node(E x) {  //有参构造函数      item = x;      }private final int capacity;  //容量，默认为 Integer.MAX_VALUEprivate final AtomicInteger count = new AtomicInteger();  //队列中元素的数量transient Node&lt;E&gt; head;  //头节点private transient Node&lt;E&gt; last;  //尾节点private final ReentrantLock takeLock = new ReentrantLock(); //拿锁private final Condition notEmpty = takeLock.newCondition();  //拿锁的条件，队列不为空private final ReentrantLock putLock = new ReentrantLock();  //放锁private final Condition notFull = putLock.newCondition();  //放锁的条件}</code></pre><p>​<code>put操作:​</code>java<br>public void put(E e) throws InterruptedException {<br>        if (e == null) throw new NullPointerException();<br>        final int c;<br>        final Node<E> node = new Node<E>(e);<br>        final ReentrantLock putLock = this.putLock;<br>        final AtomicInteger count = this.count;<br>        putLock.lockInterruptibly();<br>        try {<br>            /*</p><pre><code>         * Note that count is used in wait guard even though it is         * not protected by lock. This works because count can         * only decrease at this point (all other puts are shut         * out by lock), and we (or some other waiting put) are         * signalled if it ever changes from capacity. Similarly         * for all other uses of count in other wait guards.         */        while (count.get() == capacity) {            notFull.await();        }        enqueue(node);        c = count.getAndIncrement();        if (c + 1 &lt; capacity)            notFull.signal();    } finally {        putLock.unlock();    }    if (c == 0)        signalNotEmpty();}</code></pre><p>​<code>take操作:​</code>java<br>public E take() throws InterruptedException {<br>        final E x;<br>        final int c;<br>        final AtomicInteger count = this.count;<br>        final ReentrantLock takeLock = this.takeLock;<br>        takeLock.lockInterruptibly();<br>        try {<br>            while (count.get() == 0) {<br>                notEmpty.await();<br>            }<br>            x = dequeue();<br>            c = count.getAndDecrement();<br>            if (c &gt; 1)<br>                notEmpty.signal();<br>        } finally {<br>            takeLock.unlock();<br>        }<br>        if (c == capacity)<br>            signalNotFull();<br>        return x;<br>    }</p><p>​```</p><h1 id="PriorityBlockingQueue-1"><a href="#PriorityBlockingQueue-1" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p>PriorityBlockingQueue可以根据自定义的优先级来构建一个有序的二叉堆数据结构，这种结构在插入数据的时候就能够根据自定义的排序规则（对象实现Compareable和Comparator）来生成一个有序的堆，通过这样来定义一个按优先级顺序的队列集合，不再是默认的先进先出规则，需要注意的是优先级队列的put方法并不阻塞，默认的数组的长度是11，在插入满的时候会扩容。take方法在队列为空的时候会进入阻塞状态。</p><h1 id="生产者消费者模型的实现-1"><a href="#生产者消费者模型的实现-1" class="headerlink" title="生产者消费者模型的实现"></a>生产者消费者模型的实现</h1><p>​```java<br>package test;</p><p>import java.util.LinkedList;<br>import java.util.Queue;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.locks.Condition;<br>import java.util.concurrent.locks.ReentrantLock;</p><p>/**</p><ul><li><p>@date 2020/3/29 - 18:42<br>*/<br>public class Pool {<br> private int num;<br> private volatile int cnt;<br> private Queue<String> q;<br> public ReentrantLock lock = new ReentrantLock();<br> public Condition producelock = lock.newCondition();<br> public Condition wastelock = lock.newCondition();</p><p> public Pool(int num){</p><pre><code> this.num = num; q = new LinkedList&lt;&gt;(); cnt = 0;</code></pre><p> }</p><p> class  produce implements Runnable{</p><pre><code> @Override public void run() {     lock.lock();     try {         while(cnt == num) {             producelock.await();         }         String tmp = &quot;生产线程&quot;+Thread.currentThread().getName();         System.out.println(&quot;我已经制造了&quot;+Thread.currentThread().getName());         cnt++;         q.add(tmp);         wastelock.signalAll();     } catch (InterruptedException e) {         e.printStackTrace();     }     finally {         lock.unlock();     } }</code></pre><p> }</p><p> class wate implements Runnable{</p><pre><code> public void run(){     lock.lock();     try {         while(cnt == 0) {             wastelock.await();         }         String tmp = q.poll();         System.out.println(tmp);         //System.out.println(&quot;我已经消耗了&quot;+Thread.currentThread().getName()+&quot; &quot;+tmp);         cnt--;         producelock.signalAll();     } catch (InterruptedException e) {         e.printStackTrace();     }     finally {         lock.unlock();     } }</code></pre><p> }</p><p> public static void main(String[] args) {</p><pre><code> Pool pool = new Pool(3); produce p = pool.new produce(); wate w = pool.new wate(); for(int i = 0 ; i&lt;5;i++){     new Thread(p).start();     new Thread(w).start(); }</code></pre><p> }</p></li></ul><p>}</p><p>​```</p><p>```</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要用阻塞队列&quot;&gt;&lt;a href=&quot;#为什么要用阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;为什么要用阻塞队列&quot;&gt;&lt;/a&gt;为什么要用阻塞队列&lt;/h1&gt;&lt;p&gt;在并发编程中，有时候需要使用&lt;strong&gt;线程安全的队列&lt;/strong&gt;。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。&lt;/li&gt;
&lt;li&gt;非阻塞的实现方式则可以使用循环CAS的方式来实现。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/categories/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/tags/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis常见问题</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-25T13:30:21.000Z</published>
    <updated>2020-05-25T13:31:20.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis快的原因"><a href="#redis快的原因" class="headerlink" title="redis快的原因"></a>redis快的原因</h1><a id="more"></a><h2 id="IO多路复用阻塞机制"><a href="#IO多路复用阻塞机制" class="headerlink" title="IO多路复用阻塞机制"></a>IO多路复用阻塞机制</h2><h3 id="为什么需要使用IO多路复用"><a href="#为什么需要使用IO多路复用" class="headerlink" title="为什么需要使用IO多路复用"></a>为什么需要使用IO多路复用</h3><p>Redis 是跑在<strong>单线程</strong>中的，所有的操作都是按照顺序线性执行的，但是<strong>由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务</strong>，而 I/O 多路复用就是为了解决这个问题而出现的。</p><h3 id="什么是I-O-多路复用"><a href="#什么是I-O-多路复用" class="headerlink" title="什么是I/O 多路复用"></a>什么是I/O 多路复用</h3><p><strong>I/O 多路复用其实是在单个线程中通过记录跟踪每一个sock（I/O流） 的状态来管理多个I/O流</strong>。<br>select, poll, epoll 都是I/O多路复用的具体的实现。epoll性能比其他几者要好。redis中的I/O多路复用的所有功能通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的。</p><h2 id="数据结构简单，操作节省时间"><a href="#数据结构简单，操作节省时间" class="headerlink" title="数据结构简单，操作节省时间"></a>数据结构简单，操作节省时间</h2><h2 id="运行在内存中"><a href="#运行在内存中" class="headerlink" title="运行在内存中"></a>运行在内存中</h2><h1 id="Redis的数据淘汰机制"><a href="#Redis的数据淘汰机制" class="headerlink" title="Redis的数据淘汰机制"></a>Redis的数据淘汰机制</h1><ul><li><p>volatile-lru 从<strong>已设置过期时间</strong>的数据集中挑选<strong>最近最少使用的数据</strong>淘汰</p></li><li><p>volatile-ttl 从<strong>已设置过期时间</strong>的数据集中挑选将<strong>要过期的数据</strong>淘汰</p></li><li>volatile-random从<strong>已设置过期时间</strong>的数据集中<strong>任意选择数据</strong>淘汰</li><li>allkeys-lru从<strong>所有数据集</strong>中挑选<strong>最近最少使用</strong>的数据淘汰</li><li>allkeys-random从<strong>所有数据集</strong>中<strong>任意选择数据进行淘汰noeviction禁止驱逐数据</strong></li></ul><h1 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h1><ul><li><p>RDB 持久化</p><ol><li><p>RDB持久化是将某个时间点上Redis中的数据保存到一个RDB文件中,该文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时Redis中的数据</p></li><li><p>Redis提供了2个命令来创建RDB文件，一个是SAVE，另一个是BGSAVE。</p><ul><li>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li><li>BGSAVE命令会派生出一个<strong>子进程</strong>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</li></ul></li><li>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</li><li>如果数据量很大，保存快照的时间会很长。</li></ol></li><li><p>AOF 持久化</p><ol><li><p>AOF持久化是通过将Redis服务器执行的所有写命令保存到AOF文件中来实现持久化的</p></li><li><p><strong>将写命令添加到 AOF 文件（Append Only File）的末尾</strong>。</p><ul><li><p>当AOF持久化功能处于打开状态时，Redis服务器在<strong>执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的AOF缓冲区的末尾</strong>，然后<strong>Redis服务器会根据配置文件中appendfsync选项的值来决定何时将AOF缓冲区中的内容写入和同步到AOF文件*</strong>里面有以下同步选项：</p><ol><li><p>always 选项会严重减低服务器的性能,<strong>服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件</strong>，并且同步AOF文件；</p></li><li><p>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，<strong>因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行同步</strong>；</p></li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量,<strong>因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制</strong></li></ol></li></ul><ol><li><p>为了解决AOF文件体积越来越大的问题，Redis提供了AOF文件重写功能<br>实现原理:</p><ol><li><strong>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令</strong>。</li></ol><p>AOF后台重写:</p><ol><li><p>服务器进程创建<strong>子进程</strong>，子进程开始AOF文件重写</p></li><li><p>从创建子进程开始，服务器进程执行的所有写命令不仅要写入AOF缓冲区，还要写入AOF重写缓冲区<br>写入AOF缓冲区的目的是为了同步到原有的AOF文件。<br>写入AOF重写缓冲区的目的是因为子进程在进行AOF文件重写期间，服务器进程还在继续处理命令请求，<br>而新的命令可能会对现有的数据库进行修改，从而使得服务器当前的数据库数据和重写后的AOF文件所<br>保存的数据库数据不一致。</p></li><li><p>子进程完成AOF重写工作，向父进程发送一个信号，父进程在接收到该信号后，会执行以下操作：</p><ol><li><p>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这样就保证了新AOF文件所保存的数据库数据和服务器当前的数据库数据是一致的。</p></li><li><p>对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p></li></ol></li></ol></li><li><p>采用子进程的好处:</p><ol><li><p>子进程进行AOF文件重写期间，服务器进程（父进程）可以继续处理命令请求。<br>子进程带有服务器进程的数据副本，</p></li><li><p>使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</p></li></ol></li></ol></li></ol></li></ul><p><a href="https://zhuanlan.zhihu.com/p/106997927" target="_blank" rel="noopener">RDB与AOF详解</a></p><h1 id="缓存穿透，缓存雪崩以及缓存击穿"><a href="#缓存穿透，缓存雪崩以及缓存击穿" class="headerlink" title="缓存穿透，缓存雪崩以及缓存击穿"></a>缓存穿透，缓存雪崩以及缓存击穿</h1><ul><li><p>缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。</p></li><li><p>缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中</p></li><li>缓存雪崩：就是大量数据同一时间失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</li><li>打个比方，你是个很有钱的人，开满了百度云，腾讯视频各种杂七杂八的会员，但是你就是没有netflix的会员，然后你把这些账号和密码发布到一个你自己做的网站上，然后你有一个朋友每过十秒钟就查询你的网站，发现你的网站没有Netflix的会员后打电话向你要。你就相当于是个数据库，网站就是Redis。这就是缓存穿透。</li><li>大家都喜欢看腾讯视频上的《水果传》，但是你的会员突然到期了，大家在你的网站上看不到腾讯视频的账号，纷纷打电话向你询问，这就是缓存击穿</li><li>你的各种会员突然同一时间都失效了，那这就是缓存雪崩了。</li></ul><p>解决方法</p><ul><li><p>缓存穿透：</p><ol><li><p>使用布隆过滤器判断改数据是否存在 <a href="https://zhuanlan.zhihu.com/p/72378274" target="_blank" rel="noopener">布隆过滤器</a></p></li><li><p>缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击</p></li></ol></li><li><p>缓存击穿：</p><ol><li>最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员</li></ol></li><li><p>缓存雪崩：</p><ol><li><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p></li><li><p>通过加锁或者队列来控制读数据库写缓存的线程数量。</p></li><li>通过synchronized+双重检查机制：某个key只让一个线程查询，阻塞其它线程</li></ol></li></ul><h1 id="缓存和数据库间的一致性问题"><a href="#缓存和数据库间的一致性问题" class="headerlink" title="缓存和数据库间的一致性问题"></a>缓存和数据库间的一致性问题</h1><p>读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：<strong>数据库和缓存更新</strong>，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。</p><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p><ol><li><p>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p></li><li><p>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p></li></ol><p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><ul><li><p>采用延时双删策略</p><ul><li>先删除缓存；</li><li>再写数据库；</li><li>休眠500毫秒；</li><li>再次删除缓存。</li></ul></li><li><p>设置缓存过期时间<br>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p></li><li><p>该方案的弊端<br>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p></li></ul><h3 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h3><p>技术整体思路：</p><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><ul><li><p>读Redis：热数据基本都在Redis</p></li><li><p>写MySQL:增删改都是操作MySQL</p></li><li>更新Redis数据：MySQ的数据操作binlog，来更新到Redis<br>Redis更新</li></ul><ol><li><p>数据操作主要分为两大块：</p><ul><li><p>一个是全量(将全部数据一次写入到redis)</p></li><li><p>一个是增量（实时更新）<br>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p></li></ul></li><li><p>读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</p></li><li><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p></li><li><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p></li><li><p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p></li><li><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p></li></ol><p><a href="https://zhuanlan.zhihu.com/p/58536781" target="_blank" rel="noopener">解决redis和数据库间数据一致性的问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis快的原因&quot;&gt;&lt;a href=&quot;#redis快的原因&quot; class=&quot;headerlink&quot; title=&quot;redis快的原因&quot;&gt;&lt;/a&gt;redis快的原因&lt;/h1&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>springboot整合redis</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/springboot%E6%95%B4%E5%90%88redis/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/springboot%E6%95%B4%E5%90%88redis/</id>
    <published>2020-05-25T13:28:32.000Z</published>
    <updated>2020-05-25T13:31:20.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导入maven依赖"><a href="#导入maven依赖" class="headerlink" title="导入maven依赖"></a>导入maven依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 添加Redis缓存支持 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--spring2.0集成redis所需common-pool2--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 必须加上，jedis依赖此  --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- spring boot 2.0 的操作手册有标注 大家可以去看看 地址是：https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="配置application-properties文件"><a href="#配置application-properties文件" class="headerlink" title="配置application.properties文件"></a>配置application.properties文件</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>= <span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">60s</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">-1</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1s</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">500</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure><h1 id="创建一个RedisCaCheConfig"><a href="#创建一个RedisCaCheConfig" class="headerlink" title="创建一个RedisCaCheConfig"></a>创建一个RedisCaCheConfig</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DigestUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/22 - 23:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">//private Logger logger = LoggerFactory.getLogger(RedisCacheConfig.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LettuceConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新配置缓存</span></span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置缓存的默认超时时间：30分钟</span></span><br><span class="line">        redisCacheConfiguration = redisCacheConfiguration.entryTtl(Duration.ofMinutes(<span class="number">30L</span>))</span><br><span class="line">                .disableCachingNullValues()</span><br><span class="line">                .disableKeyPrefix()</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer((<span class="keyword">new</span> GenericJackson2JsonRedisSerializer())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. entryTtl: 定义默认的cache time-to-live.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2. disableCachingNullValues: 禁止缓存Null对象. 这个识需求而定.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3. computePrefixWith: 此处定义了cache key的前缀, 避免公司不同项目之间的key名称冲突.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4. serializeKeysWith, serializeValuesWith: 定义key和value的序列化协议, 同时的hash key和hash value也被定义.</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(RedisCacheWriter</span><br><span class="line">                .nonLockingRedisCacheWriter(redisConnectionFactory))</span><br><span class="line">                .cacheDefaults(redisCacheConfiguration).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  设置自动key的生成规则，配置spring boot的注解，进行方法级别的缓存,使用：进行分割，可以很多显示出层级关系</span></span><br><span class="line">        <span class="comment">// 这里其实就是new了一个KeyGenerator对象，只是这是lambda表达式的写法，我感觉很好用，大家感兴趣可以去了解下</span></span><br><span class="line">        <span class="keyword">return</span> (target, method, params) -&gt; &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(target.getClass().getName());</span><br><span class="line">            sb.append(<span class="string">":"</span>);</span><br><span class="line">            sb.append(method.getName());</span><br><span class="line">            <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                sb.append(<span class="string">":"</span> + String.valueOf(obj));</span><br><span class="line">            &#125;</span><br><span class="line">            String rsToUse = String.valueOf(sb);</span><br><span class="line">            System.out.println(<span class="string">"调用Redis缓存Key : "</span> + rsToUse);</span><br><span class="line">            <span class="keyword">return</span> rsToUse;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建一个Redisconfig"><a href="#创建一个Redisconfig" class="headerlink" title="创建一个Redisconfig"></a>创建一个Redisconfig</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.AutoConfigureAfter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(RedisAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置key和value的序列化规则</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/5 - 13:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span>  String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findUserbyId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">test</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.findUserById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;导入maven依赖&quot;&gt;&lt;a href=&quot;#导入maven依赖&quot; class=&quot;headerlink&quot; title=&quot;导入maven依赖&quot;&gt;&lt;/a&gt;导入maven依赖&lt;/h1&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-cache&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 添加Redis缓存支持 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-redis&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.4.3.RELEASE&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--spring2.0集成redis所需common-pool2--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 必须加上，jedis依赖此  --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- spring boot 2.0 的操作手册有标注 大家可以去看看 地址是：https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.commons&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-pool2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.5.0&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
      <category term="缓存" scheme="https://sqwyyy.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/redis/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/redis/</id>
    <published>2020-05-25T13:27:14.000Z</published>
    <updated>2020-05-25T13:31:20.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>Redis 有 5 种基础数据结构，它们分别是：<strong>string、list、字典、压缩列表和跳跃表</strong>。</p><a id="more"></a><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis中的每一个对象都由一个redisObject结构表示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><br>对于Redis数据库保持的键值对来说，<strong>键总是一个字符串对象</strong>，值可以是<strong>字符串对象，列表对象，哈希对象，集合对象或者有序集合对象</strong></p><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>SDS是<strong>一种动态字符串</strong>，在redis中，它并未使用C语言中的字符串，而是自己实现了<strong>一种叫做SDS的数据结构</strong>，它的结构表示如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用字节的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中剩余空间的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[]; <span class="comment">//字节数组，用于存储字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="SDS相比于char字符数组的优势"><a href="#SDS相比于char字符数组的优势" class="headerlink" title="SDS相比于char字符数组的优势"></a>SDS相比于char字符数组的优势</h2><ul><li>获取字符串长度为 O(1) 级别的操作</li><li>可以避免缓冲区溢出/内存泄漏 </li><li>二进制安全，C字符串的字符必须符合某种编码（ASCII）,SDS可以保持像图片，视频等这样的二进制文件。在C中的字符数组以’\0’结束，在SDS中可以允许多个’\0’的存在。<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2>双向链表的插入删除的时间复杂度为O(1)，查询的时间复杂度为O(N)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;<span class="comment">//节点的值</span></span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);<span class="comment">//节点赋值函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);<span class="comment">//节点释放函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);<span class="comment">//节点对比函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;<span class="comment">//双向链表的长度</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Redis的字典使用哈希表作为底层实现,<strong>一个字典中有两个哈希表，一个哈希表里面可以有多个哈希表节点，每个哈希表节点就保存字典中的一个键值对</strong>。<br>字典:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><p>哈希表:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><br>Hash表节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">// 单链表结构</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><br>dict结构大概如上所示，</p><ul><li>dictht ht[2]：在dict的内部，维护了两张哈希表，作用等同于是一对滚动数组，一张表是旧表，一张表是新表，当hashtable的大小需要动态改变的时候，旧表中的元素就往新开辟的新表中迁移，当下一次变动大小，当前的新表又变成了旧表，以此达到资源的复用和效率的提升</li><li>dictht::table：哈希表内部的table结构使用了<strong>链地址法来解决哈希冲突</strong>，这其实是一个指向数组的指针，数组中的每一项都是entry链表的头结点</li><li>rehashidx：因为是渐进式的哈希，数据的迁移并不是一步完成的，所以需要有一个索引来指示当前的rehash进度。当rehashidx为-1时，代表没有哈希操作。</li></ul><ol><li><p>Reids的Hash采用<strong>链地址法来处理冲突，然后它没有使用红黑树优化</strong>。</p></li><li><p>哈希表节点采用<strong>单链表结构</strong>。</p></li><li><p>rehash优化。</p></li></ol><h2 id="rehash优化"><a href="#rehash优化" class="headerlink" title="rehash优化"></a>rehash优化</h2><p><strong>渐进式哈希的精髓在于：数据的迁移不是一次性完成的，而是可以通过dictRehash()这个函数分步规划的，并且调用方可以及时知道是否需要继续进行渐进式哈希操作。如果dict数据结构中存储了海量的数据，那么一次性迁移势必带来redis性能的下降，别忘了redis是单线程模型，在实时性要求高的场景下这可能是致命的。而渐进式哈希则将这种代价可控地分摊了，调用方可以在dict做插入，删除，更新的时候执行dictRehash()，最小化数据迁移的代价。<br>在迁移的过程中，数据是在新表还是旧表中并不是一个非常急迫的需求，迁移的过程并不会丢失数据，在旧表中找不到再到新表中寻找就是了。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://blog.csdn.net/cqk0100/article/details/80400811" target="_blank" rel="noopener">渐进式rahash讲解</a></p><p>rehash过程的图解:<br><img src="http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png" alt=""></p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>Redis的跳跃表由zskiplistNode(跳跃表节点)与zskiplist（跳跃表头）组成<br>跳跃表性质:</p><ol><li><p>由很多层结构组成；</p></li><li><p>每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</p></li><li>最底层的链表包含了所有的元素；</li><li>如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</li><li>链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</li></ol><p><img src="https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt=""></p><p>zskiplist的结构:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点和尾节点</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">     <span class="comment">//表中节点的数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">     <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">     <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure></p><ul><li><p>header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)</p></li><li><p>tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)</p></li><li><p>level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。</p></li><li><p>length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</p></li></ul><p>跳跃表节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">     <span class="comment">//后退指针</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="keyword">double</span> sorce;</span><br><span class="line">     <span class="comment">//成员对象</span></span><br><span class="line">     robj *obj;</span><br><span class="line">     <span class="comment">//层</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">         <span class="comment">//前进指针</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">foward</span>;</span></span><br><span class="line">         <span class="comment">//跨度</span></span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">     &#125;level[];</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure></p><ul><li><p>层(level):</p><p>  每个层都带有两个属性:<strong>前进指针和跨度</strong>。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。<br>  每次<strong>创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小</strong>,这个大小就是层的“高度”。</p></li><li><p>跨度<br><strong>跨度实际是用来计算排位次序的，在查看某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位次序</strong></p></li><li><p>后退(backward)指针：<br>节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。</p></li><li><p>分值(score):<br> 各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。</p></li><li><p>成员对象(oj):<br>  各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,<strong>各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的</strong>:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p></li></ul><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><ul><li>赋值:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure></li><li>取值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure></li><li>取值并赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSET key value</span><br></pre></td></tr></table></figure></li><li>递增数字(当value为整形数据时，才可以）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure></li><li>递增数字(当value为整形数据时，才可以）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></table></figure></li><li>减少指定的整数(当value为整形数据时，才可以）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECRBY key decrement(指定整数)</span><br></pre></td></tr></table></figure></li><li>仅当不存在时赋值（使用该命令可以实现分布式锁的功能）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure></li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p>HSET 命令不区分插入和更新操作，当执行插入操作时 HSET 命令返回1，当执行更新操作时返回0。</p><ul><li><p>一次给一个字段赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br><span class="line"></span><br><span class="line">hset user username AlanShelby</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p>一次给多个字段赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMSET key field value [field value ...]</span><br><span class="line"></span><br><span class="line">hmset user username AlanShelby password admin name AlanShelby</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>一次取一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line">hget user username</span><br><span class="line">&quot;AlanShelby&quot;</span><br></pre></td></tr></table></figure></li><li><p>一次取多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br><span class="line"></span><br><span class="line">hmget user username password</span><br><span class="line">1) &quot;AlanShelby&quot;</span><br><span class="line">2) &quot;admin&quot;</span><br></pre></td></tr></table></figure></li><li><p>一次取所有的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br><span class="line">hgetall user</span><br><span class="line">1) &quot;username&quot; (filed)</span><br><span class="line">2) &quot;AlanShelby&quot;(vaule)</span><br><span class="line">3) &quot;password&quot;(filed)</span><br><span class="line">4) &quot;admin&quot;(vaule)</span><br><span class="line">5) &quot;name&quot;</span><br><span class="line">6) &quot;AlanShelby&quot;</span><br><span class="line">7) &quot;age&quot;</span><br><span class="line">8) &quot;24&quot;</span><br></pre></td></tr></table></figure></li><li><p>删除字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br><span class="line"></span><br><span class="line">hdel user age name</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><p>增加数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br><span class="line"></span><br><span class="line">hincrby user age 2</span><br><span class="line">(integer) 26</span><br></pre></td></tr></table></figure></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li><p>向两边添加元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">向左边添加元素</span><br><span class="line">LPUSH key value [value ...]</span><br><span class="line"></span><br><span class="line">lpush nameList tom lucy jack</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">向右边添加元素</span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"></span><br><span class="line">rpush nameList alan kim joy</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></li><li><p>查看列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br><span class="line">当索引是-1时表示是最后一个元素</span><br><span class="line"></span><br><span class="line">lrange nameList 0 5</span><br><span class="line">1) &quot;jack&quot;</span><br><span class="line">2) &quot;lucy&quot;</span><br><span class="line">3) &quot;tom&quot;</span><br><span class="line">4) &quot;alan&quot;</span><br><span class="line">5) &quot;kim&quot;</span><br><span class="line">6) &quot;joy&quot;</span><br></pre></td></tr></table></figure></li><li><p>从列表两端弹出元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">左弹出LPOP key 右弹出：RPOP key</span><br><span class="line"></span><br><span class="line">lpop nameList</span><br><span class="line">&quot;jack&quot;</span><br><span class="line"></span><br><span class="line">rpop nameList</span><br><span class="line">&quot;joy&quot;</span><br></pre></td></tr></table></figure></li><li>获取列表中元素个数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br><span class="line"></span><br><span class="line">LLEN nameList</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li><p>增加元素（重复的元素是无法添加进去的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br><span class="line"></span><br><span class="line">sadd nameSet tom bob ben lucy</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></li><li><p>删除元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br><span class="line"></span><br><span class="line">srem nameSet tom lucy</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><p>获取集合中的所有元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br><span class="line"></span><br><span class="line">smembers nameSet</span><br><span class="line">1) &quot;ben&quot;</span><br><span class="line">2) &quot;bob&quot;</span><br></pre></td></tr></table></figure></li><li><p>判断元素是否在集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br><span class="line"></span><br><span class="line">sismember nameSet bob</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p>集合运算命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">集合的差集运算 A-B</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd setA 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd setB 2 3 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sdiff setA setB</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff setB setA</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line"></span><br><span class="line">集合的交集运算 A ∩ B</span><br><span class="line"></span><br><span class="line">语法：SINTER key [key ...]</span><br><span class="line">127.0.0.1:6379&gt; sinter setA setB</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line"></span><br><span class="line">集合的并集运算 A ∪ B</span><br><span class="line"></span><br><span class="line">语法：SUNION key [key ...]</span><br><span class="line">127.0.0.1:6379&gt; sunion setA setB</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><ul><li><p>增加元素<br>增加元素向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：ZADD key score member [score member ...]</span><br><span class="line">127.0.0.1:6379&gt; zadd scoreSet 80 tom 90 lucy 89 alan 97 jack</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zadd scoreSet 94 lucy</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li><p>获取排名在某个范围的元素列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">按照元素分数从小到大的顺序返回索引从 start 到 stop 之间的所有元素:</span><br><span class="line"></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">127.0.0.1:6379&gt; zrange scoreSet 0 2</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;alan&quot;</span><br><span class="line">3) &quot;lucy&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange scoreSet 0 2 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;80&quot;</span><br><span class="line">3) &quot;alan&quot;</span><br><span class="line">4) &quot;89&quot;</span><br><span class="line">5) &quot;lucy&quot;</span><br><span class="line">6) &quot;94&quot;</span><br><span class="line"></span><br><span class="line">按照元素分数从大到小的顺序返回索引从 start 到 stop 之间的所有元素（包含两端的元素）</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrevrange scoreSet 0 2</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;alan&quot;</span><br><span class="line">3) &quot;lucy&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange scoreSet 0 2 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;80&quot;</span><br><span class="line">3) &quot;alan&quot;</span><br><span class="line">4) &quot;89&quot;</span><br><span class="line">5) &quot;lucy&quot;</span><br><span class="line">6) &quot;94&quot;</span><br><span class="line"></span><br><span class="line">注意：如果需要获得元素的分数的可以在命令尾部加上 WITHSCORES 参数</span><br></pre></td></tr></table></figure></li><li>获取元素的分数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br><span class="line">127.0.0.1:6379&gt; zscore scoreSet jack</span><br><span class="line">&quot;97&quot;</span><br></pre></td></tr></table></figure></li><li><p>删除元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem scoreSet tom jack</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange scoreSet 0 1</span><br><span class="line">1) &quot;alan&quot;</span><br><span class="line">2) &quot;lucy&quot;</span><br></pre></td></tr></table></figure></li><li><p>Keys 命令用于查找所有符合给定模式 pattern 的 key </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET w3c1 redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; SET w3c2 mysql</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; SET w3c3 mongodb</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; KEYS w3c*</span><br><span class="line">1) &quot;w3c3&quot;</span><br><span class="line">2) &quot;w3c1&quot;</span><br><span class="line">3) &quot;w3c2&quot;</span><br><span class="line"></span><br><span class="line">获取 redis 中所有的 key 可用使用 *</span><br><span class="line">redis 127.0.0.1:6379&gt; KEYS *</span><br><span class="line">1) &quot;w3c3&quot;</span><br><span class="line">2) &quot;w3c1&quot;</span><br><span class="line">3) &quot;w3c2&quot;</span><br></pre></td></tr></table></figure></li><li>SCAN指令<br>当<strong>redis中key数量越大，keys 命令执行越慢，而且最重要的会阻塞服务器</strong></li><li>SCAN 命令用于迭代当前数据库中的数据库键。</li><li>SSCAN 命令用于迭代集合键中的元素。</li><li>HSCAN 命令用于迭代哈希键中的键值对。</li><li>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以用count 参数指定返回数据量：</span><br><span class="line">127.0.0.1:6379&gt; scan 0 count 1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) 1) &quot;w3c3&quot;</span><br><span class="line"></span><br><span class="line">可以用match参数来匹配模式</span><br><span class="line">127.0.0.1:6379&gt; scan 0 match w3c*</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;w3c3&quot;</span><br><span class="line">   2) &quot;w3c2&quot;</span><br><span class="line">   3) &quot;w3c1&quot;</span><br></pre></td></tr></table></figure>优点:</li></ul><ol><li>不会阻塞服务器</li></ol><p>缺点:</p><ol><li>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回</li><li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责</li></ol><p><a href="http://doc.redisfans.com/key/scan.html#scan" target="_blank" rel="noopener">scan指令详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h1&gt;&lt;p&gt;Redis 有 5 种基础数据结构，它们分别是：&lt;strong&gt;string、list、字典、压缩列表和跳跃表&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
      <category term="redis基础使用" scheme="https://sqwyyy.github.io/tags/redis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/JVM/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/JVM/</id>
    <published>2020-05-25T13:26:15.000Z</published>
    <updated>2020-05-25T13:31:20.661Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下都是以hotspot虚拟机为准</strong></p><h1 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h1><p>Java虚拟机在执行java程序的过程中会把它所管理的内存划分为几个不同的数据区域，分别是<br><strong>程序计数器，java虚拟机栈，本地方法栈，堆，方法区</strong>。</p><a id="more"></a><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，<strong>为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储</strong>。</p><p><strong>如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空</strong>。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。</p><h2 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h2><p><strong>每个方法被执行的时候都会创建一个栈帧</strong>用于存储<strong>局部变量表，操作栈，动态链接，方法出口</strong>等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><a href="https://www.cnblogs.com/noKing/p/8167700.html" target="_blank" rel="noopener">局部变量等详解</a></p><ul><li>局部变量表（内存）<ul><li>存放方法参数和局部变量，必须显式初始化</li><li>若是非静态方法，在index[0]位置上存储方法所属对象的实例引用（占4字节），随后存储参数和局部变量</li><li>字节码中STORE指令：将操作栈中计算完成的布局变量写回局部变量表</li><li>操作栈</li><li>动态链接<ul><li>每个栈帧中包含一个在常量池中对当前方法的引用</li></ul></li><li>方法返回地址 </li></ul></li></ul><p>出现的异常:</p><ol><li>线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。</li><li>虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。</li></ol><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++</p><p>出现的异常与java虚拟机栈的异常相同</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的时存放对象实例</strong>。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代。</p><p>出现的异常:</p><ol><li>如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误</li></ol><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。<strong>用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中</strong>。<br>出现的异常:</p><ol><li>当方法区无法满足新的内存分配需求时,将抛出OOM异常</li></ol><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池时方法去的一部分</strong>，用于<strong>存放编译期间生成的各种字面量和符号引用</strong></p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象在内存中存储的布局：<strong>1.对象头 2.实例数据 3.对齐填充</strong></p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头主要存储两类信息，第一类时用于存储对象自身的运行时数据，<strong>如哈希码，GC分代年龄，锁的状态标志，线程持有的锁，偏向线程ID，偏向时间戳</strong><br>第二类则是<strong>类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象时哪个类的实例</strong>。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。<br>分配策略:相同宽度的字段总是放在一起，比如double和long</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。并不是必然存在的。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>java程序需要<strong>通过引用(ref)数据来操作堆上面的对象</strong>，主要有两种方式:</p><ol><li>句柄访问对象</li><li>直接指针访问对象<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3>java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3>reference中存储的就是对象实例数据与类型数据各自具体的地址信息。</li></ol><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h2><p>Java堆是GC回收的“重点区域”。堆中基本存放着所有对象实例，gc进行回收前，第一件事就是确认哪些对象存活，哪些死去[即不可能再被引用]</p><p>为了高效的回收，jvm将堆分为三个区域</p><ol><li>新生代（Young Generation）NewSize和MaxNewSize分别可以控制年轻代的初始大小和最大的大小</li><li>老年代（Old Generation）</li></ol><p>可作为GC Roots的对象有四种:</p><ul><li>虚拟机栈(栈桢中的本地变量表)中的引用的对象，就是平时所指的java对象，存放在堆中。</li><li>方法区中的类静态属性引用的对象，一般指被static修饰引用的对象，加载类的时候就加载到内存中。</li><li>方法区中的常量引用的对象,</li><li>本地方法栈中JNI（native方法)引用的对象</li></ul><hr><ul><li>部分收集(Partial GC):指目标不是完整收集整个java堆的垃圾收集，其中又分为:<ul><li>新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集</li><li>老年代收集(Major GC/old GC):指目标只是老年代的垃圾收集（目前只有CMS收集器会单独收集老年代）</li><li>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。(目前只有G1收集器会有这样的行为</li></ul></li><li>整堆收集:收集整个java堆和方法区的垃圾收集</li><li><p>major gc有可能是指老年代收集也有可能是指整堆收集</p></li><li><p>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</p></li><li>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC</li></ul><h2 id="什么时候回收内存"><a href="#什么时候回收内存" class="headerlink" title="什么时候回收内存"></a>什么时候回收内存</h2><ol><li><p>在程序空闲时。</p></li><li><p>程序不可预知的时候/手动调用 System.gc() 。不要手动调用GC，不管是 JVM 自己调用还是手动调用都会使系统陷入短暂的停顿，给垃圾回收让路，手动调用就违背了我们优化 GC 的初衷了</p></li><li><p>堆内存不足时 GC 会被调用。当应用线程在运行，并在运行过程中穿件对象，若这时内存空间不足，JVM就会强制的调用 GC ，一遍回收内存用于新的分配。若GC 一次之后仍不满足内存分配的要求，JVM会再次进行两次 GC 做进一步尝试，若还是不满足需求则会抛出 “out of memort” 的错误使应用异常停止</p></li></ol><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><ul><li><p>引用计数算法<br>早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。<br>优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。<br>缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。</p></li><li><p>可达性分析算法<br>目前主流的商用语言[如java、c#]采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。<br>它的基本思路是<strong>通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的</strong>。</p></li></ul><p><strong>上述两种算法都要依据引用来实现</strong></p><p>对象的引用分为四种:</p><ul><li><p>强引用<br>如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello"</span>;    <span class="comment">// 强引用</span></span><br><span class="line">str = <span class="keyword">null</span>;              <span class="comment">// 取消强引用</span></span><br></pre></td></tr></table></figure></li><li><p>软引用<br>在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收；只有在内存空间不足时，软引用才会被垃圾回收器回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softName = <span class="keyword">new</span>  SoftReference&lt;&gt;(<span class="string">"张三"</span>);</span><br></pre></td></tr></table></figure></li><li><p>弱引用<br>当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; weakName = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p>虚引用<br>如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收<br>虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;String&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>), queue);</span><br></pre></td></tr></table></figure></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ol><li>标记/清除算法</li><li>复制算法</li><li>标记/整理算法<h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记/清除"></a>标记/清除</h3><strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</strong></li></ol><p>缺点:</p><ol><li><strong>效率低</strong>,标记和清除两个阶段的效率都不高，因为这两个阶段都需要遍历内存中的对象，很多时候内存中的对象实例数量是非常庞大的，这无疑很耗费时间，而且GC时需要停止应用程序，这会导致非常差的用户体验。</li><li><strong>清除之后会产生大量的空间碎片</strong>，内存空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><strong>将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把这一块内存所有的对象一次性清理掉</strong>。</p><p>优点: 优化了标记/清除算法的效率低、内存碎片多的问题<br>缺点:</p><ol><li>将内存缩小为原来的一半，浪费了一半的内存空间。</li><li>如果对象的存活率很高，极端一点的情况假设对象存活率为100%，那么我们需要将所有存活的对象复制一遍</li></ol><p>由于新生代中的对象几乎都是“朝生夕死”的（达到98%），现在的商业虚拟机都采用复制算法来回收新生代。由于新生代的对象存活率低，所以并不需要按照1：1的比例来划分内存空间，而是将<strong>内存分为一块较大的Eden空间和两块较小的From Survivor空间、To Survivor空间，三者的比例为8:1:1</strong>.每次使用Eden和From Survivor区域，To Survivor作为保留空间。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的。GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着， From Survivor区和To Survivor区会交换它们的角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区</p><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记/整理"></a>标记/整理</h3><p>首先标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边线以外的内存。</p><p>优点：回收后可回收对象被清理掉了，存活的对象按规则排列存放在内存中。<br>缺点：效率也不高，不仅要标记存活对象，还要整理所有存活对象的引用地址</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法的思想是<strong>按对象的存活周期不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法</strong>。</p><p> 新生代：朝生夕灭，存活时间很短。</p><p> 老年代：经过多次Minor GC而存活下来，存活周期长。</p><ul><li>在新生代中每次垃圾回收都发现有大量的对象死去，只有少量存活，因此采用<strong>复制算法回收新生代</strong>，只需要付出少量对象的复制成本就可以完成收集；</li><li>老年代中对象的存活率高，不适合采用复制算法，而且如果老年代采用复制算法，它是没有额外的空间进行分配担保的，因此必须使用<strong>标记/清理算法或者标记/整理算法</strong>来进行回收。</li></ul><h3 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h3><p>对传统的、基本的GC实现来说，由于它们<strong>在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情</strong>。如果说<strong>收集整个GC堆耗时太长，那不如只收集其中的一部分</strong>？于是就有好几种不同的划分（partition）GC堆的方式来实现部分收集，而分代式GC就是这其中的一个思路。</p><p><a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="noopener">分代的解析</a></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul><li>年轻代收集器 Serial、ParNew、Parallel Scavenge</li><li>老年代收集器 Serial Old、Parallel Old、CMS收集器</li><li>特殊收集器 G1收集器[新型，不在年轻、老年代范畴内]</li></ul><h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2><p>Serial是单线程收集器，Serial收集器只能使用一条线程进行收集工作，在收集的时候必须得停掉其它线程，<strong>采用复制算法</strong>，等待收集工作完成其它线程才可以继续工作。</p><h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><p>可以认为是Serial的升级版，因为它支持多线程[GC线程]，而且收集算法、Stop The World、回收策略和Serial一样，就是可以有多个GC线程并发运行</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS<strong>采用的是”标记-清除”算法，而且是支持并发</strong><br>它的运作分为4个阶段:</p><ul><li>初始标记:标记一下GC Roots能直接关联到的对象，速度很快</li><li>并发标记:GC Roots Tarcing过程，即可达性分析</li><li>重新标记:为了修正因并发标记期间用户程序运作而产生变动的那一部分对象的标记记录，会有些许停顿，时间上一般 初始标记 &lt; 重新标记 &lt; 并发标记</li><li>并发清除</li></ul><p>以上<strong>初始标记和重新标记</strong>需要停掉其他运行的线程</p><p>优点:CMS收集器的内存回收工作是可以和用户线程一起并发执行。<br>缺点:</p><ul><li>cpu敏感</li><li>无法处理浮动垃圾</li><li>由于使用的标记-清除算法会产生垃圾碎片</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1的特别之处在于<strong>它强化了分区，弱化了分代的概念，是区域化、增量式的收集器，它不属于新生代也不属于老年代收集器，用到的算法为标记-清理、复制算法</strong>。<br>G1是区域化的，它将java堆内存划分为若干个大小相同的区域。<br>G1提供三种垃圾回收模式 young gc、mixed gc 和 full gc,不像其它的收集器，根据区域而不是分代，新生代老年代的对象它都能回收<br>它的运作分为4个阶段:</p><ul><li><p>初始标记:标记一下GC Roots能直接关联到的对象，速度很快</p></li><li><p>并发标记:GC Roots Tarcing过程，即可达性分析</p></li><li>最终标记:</li><li>筛选回收</li></ul><p>以上<strong>初始标记和最终标记和筛选回收</strong>需要停掉其他运行的线程<br><a href="https://www.jianshu.com/p/76959115d486" target="_blank" rel="noopener">深入理解JVM和GC</a></p><h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><ul><li>对象优先在Eden分配<ol><li>Eden空间不足直接触发Minor GC</li></ol></li><li><p>大对象直接进入老年代</p><ol><li>需要大量连续内存空间的 Java 对象。例如那种很长的字符串或者数组。</li><li>防止新生代复制大对象消耗资源</li></ol></li><li>长期存活对象进入老年代<ol><li>固定对象年龄判定： 虚拟机给每个对象定义一个年龄计数器，对象每在 Survivor 中熬过一次 Minor GC，年龄 +1，达到 -XX:MaxTenuringThreshold 设定值后，会被晋升到老年代，-XX:MaxTenuringThreshold 默认为 15；</li><li>动态对象年龄判定： Survivor 中有相同年龄的对象的空间总和大于 Survivor 空间的一半，那么，年龄大于或等于该年龄的对象直接晋升到老年代。</li></ol><ul><li>空间分配担保<ol><li>如果Eden中所有新生代对象都要存活，但剩下的一个Survivor空间明显不够，就要老年代空间来进行担保</li><li>如果老年代空间不够，尝试进行Full GC</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下都是以hotspot虚拟机为准&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;JVM分区&quot;&gt;&lt;a href=&quot;#JVM分区&quot; class=&quot;headerlink&quot; title=&quot;JVM分区&quot;&gt;&lt;/a&gt;JVM分区&lt;/h1&gt;&lt;p&gt;Java虚拟机在执行java程序的过程中会把它所管理的内存划分为几个不同的数据区域，分别是&lt;br&gt;&lt;strong&gt;程序计数器，java虚拟机栈，本地方法栈，堆，方法区&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA虚拟机" scheme="https://sqwyyy.github.io/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://sqwyyy.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JMM</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/JMM/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/JMM/</id>
    <published>2020-05-25T13:23:39.000Z</published>
    <updated>2020-05-25T13:31:20.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范</strong>。</p><a id="more"></a><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p><strong>它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。可以保证并发编程场景中的原子性、可见性和有序性</strong>。</p><h1 id="JVM对Java内存模型的实现"><a href="#JVM对Java内存模型的实现" class="headerlink" title="JVM对Java内存模型的实现"></a>JVM对Java内存模型的实现</h1><p>在JVM内部，<strong>Java内存模型把内存分成了两部分：线程栈区和堆区</strong></p><p>所有原始类型(boolean,byte,short,char,int,long,float,double)的局部变量都直接保存在<strong>线程栈当中，对于它们的值各个线程之间都是独立的</strong>。</p><p>堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的局部变量，它都会被存储在堆区。</p><p>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。</p><p><strong>Java的内存模型在并发的情况下如何处理原子性，有序性，可见性</strong></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>java内存模型保证原子性变量操作包括read，load，assign，use，store，write，lock，unlock。<strong>基本数据类型的访问，读写都是具有原子性的（除了long和double的非原子性协定）</strong></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>java内存模型时<strong>通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值</strong>这种依赖主内存作为传递媒介的方式实现可见性。</p><ul><li><p>volatile可见性的实现就是借助了CPU的lock指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则:</p><ol><li><p>写volatile时处理器会将缓存写回到主内存。</p></li><li><p>一个处理器的缓存写回到内存会导致其他处理器的缓存失效。</p></li></ol></li><li><p>锁实现可见性的原理是</p><ol><li><p>当线程<strong>释放锁</strong>时，<strong>JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</strong>。</p></li><li><p>当线程<strong>获取锁</strong>时，<strong>JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量</strong>。</p></li></ol></li><li><p>final的可见性是因为一旦初始化完成就无法修改，对于线程而言值不会改变。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span>[] Arrary   <span class="comment">//假设修饰一个数组</span></span><br><span class="line"><span class="keyword">int</span> i=Arrary[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>实际上可分解为2个子操作:</p><ol><li>读取数组引用地址，由于volatile修饰数组，这步子操作是volatile有效的，</li><li>在取到数组引用后根据下标读取具体元素,这步与volatile是无关的</li></ol><p><strong>对于引用型的对象，volatile只是能保障对象的引用，至于该引用所指向的对象实例中的值volatile无法保障</strong><br>类似于数组声明为volatile时，引用地址具有可见性，元素本身不具有可见性<br>如果要使数组内的元素也能触发volatile作用，<strong>可以使用AtomicIntegerArray</strong></p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>java语言中有一个<strong>先行发生</strong>原则来实现有序性</p><ol><li>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序是允许的(对编译器和处理器</li></ol><p>Happens-Before规则-无需任何同步手段就可以保证的</p><ol><li><p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p></li><li><p>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</p></li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li><li>线程中断规则:对线程interrupt方法的调用happens-before于被中断线程的代码检测到中断事件的发生。</li></ol><ul><li><p>volatile有序性的实现——<strong>JMM对volatile的内存屏障</strong>插入策略：</p><ol><li><p>在每个volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。</p></li><li><p>在每个volatile读操作的后面插入一个LoadLoad屏障。在每个volatile读操作的后面插入一个LoadStore屏障。</p></li></ol></li><li><p>锁有序性的实现——互斥锁:一个变量在同一时刻只允许一条线程对其进行lock操作</p></li></ul><p><strong>synchronized并没有实现禁止指令重排序</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA虚拟机" scheme="https://sqwyyy.github.io/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://sqwyyy.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
