<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-09-03T07:55:59.700Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面经整理</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/03/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/03/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</id>
    <published>2020-09-03T07:26:54.000Z</published>
    <updated>2020-09-03T07:55:59.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HASHMAP"><a href="#HASHMAP" class="headerlink" title="HASHMAP"></a>HASHMAP</h1><ol><li>HashMap 底层数据结构？为什么不直接用红黑树，还要用链表？</li><li>HashMap 什么时候扩容？装载因子和临界值默认是多少？扩容成多大？为什么容量是2的幂次方？</li><li>线程安全的Map？分段锁是如何实现的？JDK 1.8之后有哪些优化？</li><li>HashMap 的线程安全性</li><li>hashmap的实现，怎么扩容的</li></ol><h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><ol><li>finally 中 return 会发生什么？</li><li>Java参数传递是值传递还是引用传递并举例说明。</li><li>有哪些常见的Exception，怎么避免空指针异常</li><li>ArrayList、LinkedList</li><li>ArrayList源码相关，怎么扩容的，扩容是不是一定1.5倍？</li></ol><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ol><li>线程池实现原理？实现方式？拒绝策略？阻塞队列？</li><li>并发？Lock和Synchronized区别？AQS实现？锁优化？</li><li>synchronized原理</li><li>volatile</li><li>多线程的优缺点</li><li>多线程会产生的问题？死锁？（怎么解决死锁）内存泄露？（如何解决内存泄露，举个例子，我：Threadlocal，不会解决）</li><li>有哪些锁？讲一下乐观锁和悲观锁的区别</li><li>公平锁与非公平锁是怎么实现的，使用非公平锁，当前获取不到锁，加入等待队列，之后会怎么处理？</li></ol><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li>堆内部空间的划分？</li><li>垃圾回收算法？垃圾回收器？CMS？</li><li>类加载？双亲委派？为什么？破坏双亲委派？</li><li>一个父类加载器能不能加载一个子类加载器，为什么</li><li>java 对象的创建过程</li><li></li><li>垃圾回收为什么分区？分为几个区？各区的占比？为什么要survior区？survior为什么分为from和to区？ </li><li>如何减少Full GC的次数，比较消耗内存？（不会，面试官说增大老年区内存大小，可以设置）</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ol><li>对数据库三范式的理解，并举例实际的例子说明为什么不满足</li><li>MySQL中有一张表，id和name，name有很多重复行，怎么去除重复的数据？</li><li>怎么防止SQL注入，举一个SQL注入的实例</li><li>索引怎么优化</li><li>B+树为什么适合做索引？和红黑树，B树相比，优点是什么（我自己总结了四点，从速度、稳定性、区间查询、全表扫描来分析）</li><li>Mysql的存储引擎？</li><li>数据库的隔离级别？每一级别出现的问题？</li><li>解释下聚簇索引和非聚簇索引</li><li>如果有abc联合索引，只查c会怎样，只查ac会怎样，为什么</li><li>联合索引底层结构</li><li>非聚簇索引会查几次</li><li>数据库是如何做范围读取的？mysql中记录是如何存储的</li><li>如何保证数据库断电不丢失？redo日志，先写日志，掉电了，如何确定数据有没有写到盘上。redo日志重做的细节（如何确定数据有没有写到盘上:  查看页结构File Header 头部的Fil_Page_LSN字段是否在checkpoint_lsn之后）</li></ol><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ol><li>关闭浏览器之后重新输入url后，还会保存登录信息吗</li><li>http get/post区别</li><li>HTTP原理</li><li>tcp三次握手之后如果客户端断网了怎么办</li><li>tcp三次握手</li><li>http长短连接</li></ol><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ol><li>进程间的通信方式</li><li>共享内存</li><li>协程</li><li>解释虚拟内存</li><li>缺页中断</li></ol><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><ol><li>redis基本数据类型</li><li>怎么实现分布式锁</li><li>redis分布式锁有什么缺点，怎么解决</li><li>Redis 集群 主从</li><li>布隆过滤器</li><li>Redis缓存怎么更新,以及怎么保证和数据库的一致性</li><li>zset和list使用上的区别</li><li>zset底层结构，如何实现范围查找</li><li>Redis 发布订阅模式如何实现</li></ol><h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><ol><li>spring一个事务中调用另外一个事务，另一个事务发生异常会怎么样</li><li>Bean的生命周期是什么</li><li>Spring运用了哪些设计模式（ioc单例、aop动态代理）</li><li>Spring AOP默认的动态代理是什么？想使用CGlib怎么设置（配置文件）？</li><li>什么时候用JDK动态代理，什么时候用CGlib动态代理？</li><li>Spring IOC底层实现？工厂+反射。</li><li>BeanFactory和ApplicationContext的区别是什么？</li><li>SpringBoot 启动流程，与 Spring 的区别</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>海量数据求频率最多的100个</li><li>select和epoll的区别</li><li>红黑树是如何旋转调整的？红黑树的性质？各种操作的时间复杂度？</li><li>快排具体实现，最差情况下时间复杂度，什么情况是最差情况</li><li>加密算法说几个</li><li>token怎么保证安全</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HASHMAP&quot;&gt;&lt;a href=&quot;#HASHMAP&quot; class=&quot;headerlink&quot; title=&quot;HASHMAP&quot;&gt;&lt;/a&gt;HASHMAP&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;HashMap 底层数据结构？为什么不直接用红黑树，还要用链表？&lt;/li&gt;
&lt;li&gt;Ha
      
    
    </summary>
    
    
      <category term="面试" scheme="https://sqwyyy.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>redis的bitmap</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/02/redis%E7%9A%84bitmap/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/02/redis%E7%9A%84bitmap/</id>
    <published>2020-09-02T11:36:21.000Z</published>
    <updated>2020-09-02T13:39:24.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BitMap是什么"><a href="#BitMap是什么" class="headerlink" title="BitMap是什么"></a>BitMap是什么</h1><p>​      就是通过一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道<strong>8个bit可以组成一个Byte</strong>，所以bitmap本身会极大的节省储存空间。</p><a id="more"></a><h1 id="Redos的BitMap"><a href="#Redos的BitMap" class="headerlink" title="Redos的BitMap"></a>Redos的BitMap</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br><span class="line"></span><br><span class="line">get key offset</span><br><span class="line"></span><br><span class="line">bitcount key start end&#x2F;&#x2F;获取key中start到end字节 值为1的个数</span><br><span class="line"></span><br><span class="line">BITOP AND destkey key [key ...]  ，对一个或多个key求逻辑并，并将结果保存到destkey</span><br><span class="line"></span><br><span class="line">BITOP OR destkey key [key ...] ，对一个或多个key求逻辑或，并将结果保存到destkey</span><br><span class="line"></span><br><span class="line">BITOP XOR destkey key [key ...] ，对一个或多个key求逻辑异或，并将结果保存到destkey</span><br><span class="line"></span><br><span class="line">BITOP NOT destkey key ，对给定key求逻辑非，并将结果保存到destkey</span><br></pre></td></tr></table></figure><ul><li><p>value的值只能是0或者1</p></li><li><p>bitcount的start和end指的是byte为单位</p><ul><li>比如 K1 【01000001 01000000 00000000 00100001】，对应【0，1，2，3】</li><li>bitcount K1 1 2 ： 统计下标1、2字节组中bit=1的个数，即01000000 00000000</li></ul></li><li><p>bitop操作</p><ul><li><p>```txt<br>redis&gt; SETBIT bits-1 0 1        # bits-1 = 1001<br>(integer) 0</p><p>redis&gt; SETBIT bits-1 3 1<br>(integer) 0</p><p>redis&gt; SETBIT bits-2 0 1        # bits-2 = 1011<br>(integer) 0</p><p>redis&gt; SETBIT bits-2 1 1<br>(integer) 0</p><p>redis&gt; SETBIT bits-2 3 1<br>(integer) 0</p><p>redis&gt; BITOP AND and-result bits-1 bits-2<br>(integer) 1</p><p>redis&gt; GETBIT and-result 0      # and-result = 1001<br>(integer) 1</p><p>redis&gt; GETBIT and-result 1<br>(integer) 0</p><p>redis&gt; GETBIT and-result 2<br>(integer) 0</p><p>redis&gt; GETBIT and-result 3<br>(integer) 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[bitcount注意事项](https:&#x2F;&#x2F;blog.csdn.net&#x2F;u011957758&#x2F;article&#x2F;details&#x2F;74783347)</span><br><span class="line"></span><br><span class="line">## 用户签到</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;txt</span><br><span class="line">127.0.0.1:6379&gt; setbit 2020902 123 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit 2020901 121 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit 20200901 121</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>key设置为年月日</p><p>offset设置为用户id</p><h2 id="用户在线"><a href="#用户在线" class="headerlink" title="用户在线"></a>用户在线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit online 123 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit online 121 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit online 121</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li><p>使用bitmap是一个节约空间效率又高的一种方法，只需要一个key，然后用户ID为offset，如果在线就设置为1</p></li><li><p>如果两亿的数字做排序排重，我们大概要占用好几G的空间，如果用bitmap方式，最少只需要200000000/8/1024= 24M的空间就够了</p></li></ul><h2 id="统计七天内登陆果的活跃用户"><a href="#统计七天内登陆果的活跃用户" class="headerlink" title="统计七天内登陆果的活跃用户"></a>统计七天内登陆果的活跃用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit Monday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Monday 8298191 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Tuesday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Tuesday 8892198 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Wednesday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Wednesday 8892198 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Thursday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Thursday 8892198 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Friday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Friday 8892198 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Saturday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Saturday 8892198 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Sunday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Sunday 8892198 0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>最后计算7天内登录过的活跃用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitop OR result Monday Tuesday Wednesday Thursday Friday Saturday Sunday</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BitMap是什么&quot;&gt;&lt;a href=&quot;#BitMap是什么&quot; class=&quot;headerlink&quot; title=&quot;BitMap是什么&quot;&gt;&lt;/a&gt;BitMap是什么&lt;/h1&gt;&lt;p&gt;​      就是通过一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道&lt;strong&gt;8个bit可以组成一个Byte&lt;/strong&gt;，所以bitmap本身会极大的节省储存空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/02/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/02/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2020-09-02T07:08:56.000Z</published>
    <updated>2020-09-02T09:55:23.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找vim的进程id"><a href="#查找vim的进程id" class="headerlink" title="查找vim的进程id"></a>查找vim的进程id</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep vim</span><br></pre></td></tr></table></figure><h2 id="强制杀死某个进程"><a href="#强制杀死某个进程" class="headerlink" title="强制杀死某个进程"></a>强制杀死某个进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 id</span><br></pre></td></tr></table></figure><p><strong>ps查看的结果不是动态连续的，想要动态的显示进程信息，就可以用top命令</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查找vim的进程id&quot;&gt;&lt;a href=&quot;#查找vim的进程id&quot; class=&quot;headerlink&quot; title=&quot;查找vim的进程id&quot;&gt;&lt;/a&gt;查找vim的进程id&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://sqwyyy.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>sql语句练习</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/01/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0-1/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/01/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0-1/</id>
    <published>2020-09-01T15:04:25.000Z</published>
    <updated>2020-09-01T15:04:25.628Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>静态变量和实例变量的区别</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/01/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/01/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-09-01T13:11:49.000Z</published>
    <updated>2020-09-01T13:17:11.149Z</updated>
    
    <content type="html"><![CDATA[<p>​       在Java中，静态变量和实例变量可以<strong>统称为成员变量</strong>。首先，明白什么是静态变量，什么是实例变量，他们定义的形式。<strong>静态变量也叫做类变量，独立于方法之外的变量，有static修饰</strong>。<strong>实例变量同样独立也是独立于方法之外 的变量，但没有static修饰</strong>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticInt = <span class="number">2</span>;<span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> random = <span class="number">2</span>;<span class="comment">//实例变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        staticInt++;</span><br><span class="line">        random++;</span><br><span class="line">        System.out.println(<span class="string">"staticInt = "</span>+staticInt+<span class="string">"  random = "</span>+random);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticTest test = <span class="keyword">new</span> StaticTest();</span><br><span class="line">        StaticTest test2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">staticInt &#x3D; 3  random &#x3D; 3</span><br><span class="line">staticInt &#x3D; 4  random &#x3D; 3</span><br></pre></td></tr></table></figure><ul><li><p>实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。结合上述给出的例子。每创建一个实例对象，就会分配一个random，实例对象之间的random是互不影响的，所以就可以解释为什么输出的两个random值是相同的了。</p></li><li><p>静态变量不属于某个实例对象，而是属于整个类。只要程序加载了类的字节码，不用创建任何实例对象，静态变量就回被分配空间，静态变量就可以被使用了。结合上述给出的例子，无论创建多少个实例对象，永远都只分配一个staticInt 变量，并且每创建一个实例对象,staticInt就会加一。</p></li><li><p>总之，实例变量必须创建对象后，才可以通过这个对象来使用；静态变量则可以直接使用类名来引用（如果实例对象存在，也可以通过实例对象来引用）。</p></li></ul><p><a href="https://blog.csdn.net/yong_zi/article/details/81285049" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​       在Java中，静态变量和实例变量可以&lt;strong&gt;统称为成员变量&lt;/strong&gt;。首先，明白什么是静态变量，什么是实例变量，他们定义的形式。&lt;strong&gt;静态变量也叫做类变量，独立于方法之外的变量，有static修饰&lt;/strong&gt;。&lt;strong&gt;实例变量同样独立也是独立于方法之外 的变量，但没有static修饰&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>BigDecimal</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/31/BigDecimal/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/31/BigDecimal/</id>
    <published>2020-08-31T11:44:14.000Z</published>
    <updated>2020-08-31T11:55:28.563Z</updated>
    
    <content type="html"><![CDATA[<p>float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上<strong>提供较为精确的快速近似计算而精心设计的</strong>。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> num1 = <span class="number">0.02</span>;</span><br><span class="line">        <span class="keyword">double</span> num2 = <span class="number">0.03</span>;</span><br><span class="line">        <span class="keyword">double</span> num3 = num2 - num1;</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:0.009999999999999998</p><h1 id="浮点型运算造成精度丢失的原因"><a href="#浮点型运算造成精度丢失的原因" class="headerlink" title="浮点型运算造成精度丢失的原因"></a>浮点型运算造成精度丢失的原因</h1><p>数据最后都是以<strong>二进制的形式存储在计算机中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(1) 十进制整数如何转化为二进制数</span><br><span class="line"> </span><br><span class="line">           算法很简单。举个例子，11表示成二进制数：</span><br><span class="line"> </span><br><span class="line">                     11&#x2F;2&#x3D;5 余   1</span><br><span class="line"> </span><br><span class="line">                       5&#x2F;2&#x3D;2   余   1</span><br><span class="line"> </span><br><span class="line">                       2&#x2F;2&#x3D;1   余   0</span><br><span class="line"> </span><br><span class="line">                       1&#x2F;2&#x3D;0   余   1</span><br><span class="line"> </span><br><span class="line">                          0结束         11二进制表示为(从下往上):1011</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">      (2) 十进制小数如何转化为二进制数</span><br><span class="line"> </span><br><span class="line">           算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数</span><br><span class="line"> </span><br><span class="line">                     0.9*2&#x3D;1.8   取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.8(1.8的小数部分)*2&#x3D;1.6    取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.6*2&#x3D;1.2   取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.2*2&#x3D;0.4   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                     0.4*2&#x3D;0.8   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                     0.8*2&#x3D;1.6 取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.6*2&#x3D;1.2   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                              .........      </span><br><span class="line">                     0.9二进制表示为(从上往下): 1100100100100......</span><br><span class="line"> </span><br><span class="line">           注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分</span><br><span class="line">           这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>当需要某些类型准确表示货币的时候，<strong>BigDecimal</strong>是最为合适的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.02"</span>);</span><br><span class="line">        BigDecimal num2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.03"</span>);</span><br><span class="line">        System.out.println(num1.add(num2));</span><br><span class="line">        System.out.println(num1.subtract(num2));</span><br><span class="line">        System.out.println(num1.multiply(num2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.05</span><br><span class="line">-0.01</span><br><span class="line">0.0006</span><br></pre></td></tr></table></figure><p>数据库中也可以采用decimal类型来定义货币（需要比较精确的数据)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上&lt;strong&gt;提供较为精确的快速近似计算而精心设计的&lt;/strong&gt;。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>double精度不准备问题</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/31/double%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%87%86%E5%A4%87%E9%97%AE%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/31/double%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%87%86%E5%A4%87%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-31T11:27:13.000Z</published>
    <updated>2020-08-31T11:55:28.570Z</updated>
    
    <content type="html"><![CDATA[<p>​       float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上<strong>提供较为精确的快速近似计算而精心设计的</strong>。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> num1 = <span class="number">0.02</span>;</span><br><span class="line">        <span class="keyword">double</span> num2 = <span class="number">0.03</span>;</span><br><span class="line">        <span class="keyword">double</span> num3 = num2 - num1;</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:0.009999999999999998</p><h1 id="浮点型运算造成精度丢失的原因"><a href="#浮点型运算造成精度丢失的原因" class="headerlink" title="浮点型运算造成精度丢失的原因"></a>浮点型运算造成精度丢失的原因</h1><p>数据最后都是以<strong>二进制的形式存储在计算机中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(1) 十进制整数如何转化为二进制数</span><br><span class="line"> </span><br><span class="line">           算法很简单。举个例子，11表示成二进制数：</span><br><span class="line"> </span><br><span class="line">                     11&#x2F;2&#x3D;5 余   1</span><br><span class="line"> </span><br><span class="line">                       5&#x2F;2&#x3D;2   余   1</span><br><span class="line"> </span><br><span class="line">                       2&#x2F;2&#x3D;1   余   0</span><br><span class="line"> </span><br><span class="line">                       1&#x2F;2&#x3D;0   余   1</span><br><span class="line"> </span><br><span class="line">                          0结束         11二进制表示为(从下往上):1011</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">      (2) 十进制小数如何转化为二进制数</span><br><span class="line"> </span><br><span class="line">           算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数</span><br><span class="line"> </span><br><span class="line">                     0.9*2&#x3D;1.8   取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.8(1.8的小数部分)*2&#x3D;1.6    取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.6*2&#x3D;1.2   取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.2*2&#x3D;0.4   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                     0.4*2&#x3D;0.8   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                     0.8*2&#x3D;1.6 取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.6*2&#x3D;1.2   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                              .........      </span><br><span class="line">                     0.9二进制表示为(从上往下): 1100100100100......</span><br><span class="line"> </span><br><span class="line">           注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分</span><br><span class="line">           这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>当需要某些类型准确表示货币的时候，<strong>BigDecimal</strong>是最为合适的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.02"</span>);</span><br><span class="line">        BigDecimal num2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.03"</span>);</span><br><span class="line">        System.out.println(num1.add(num2));</span><br><span class="line">        System.out.println(num1.subtract(num2));</span><br><span class="line">        System.out.println(num1.multiply(num2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.05</span><br><span class="line">-0.01</span><br><span class="line">0.0006</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​       float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上&lt;strong&gt;提供较为精确的快速近似计算而精心设计的&lt;/strong&gt;。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>三个线程依次输出ABC</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/30/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BE%9D%E6%AC%A1%E8%BE%93%E5%87%BAABC/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/30/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BE%9D%E6%AC%A1%E8%BE%93%E5%87%BAABC/</id>
    <published>2020-08-30T06:54:46.000Z</published>
    <updated>2020-08-31T07:59:49.352Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="采用synchronized"><a href="#采用synchronized" class="headerlink" title="采用synchronized"></a>采用synchronized</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"ABC"</span>;</span><br><span class="line">        Main Main = <span class="keyword">new</span> Main();</span><br><span class="line">        ThreadA threadA = Main.<span class="keyword">new</span> ThreadA();</span><br><span class="line">        ThreadB threadB = Main.<span class="keyword">new</span> ThreadB();</span><br><span class="line">        ThreadC threadC = Main.<span class="keyword">new</span> ThreadC();</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">28</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">29</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印C</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"++++++"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"------"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要采用synchronzied锁住代码块，然后通过volatile变量来控制输出ABC</li></ul><h2 id="采用Lock和Condition"><a href="#采用Lock和Condition" class="headerlink" title="采用Lock和Condition"></a>采用Lock和Condition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionA = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionB = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionC = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main printABC = <span class="keyword">new</span> Main();</span><br><span class="line">        ThreadA threadA = printABC.<span class="keyword">new</span> ThreadA();</span><br><span class="line">        ThreadB threadB = printABC.<span class="keyword">new</span> ThreadB();</span><br><span class="line">        ThreadC threadC = printABC.<span class="keyword">new</span> ThreadC();</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (count%<span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        conditionA.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"A"</span>);</span><br><span class="line">                    count ++;</span><br><span class="line">                    conditionB.signalAll();    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"ThreadA 中执行了 unlock"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (count%<span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">                        conditionB.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"B"</span>);</span><br><span class="line">                    count ++;</span><br><span class="line">                    conditionC.signalAll();                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"ThreadB 中执行了 unlock"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印C</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (count%<span class="number">3</span> != <span class="number">2</span>) &#123;</span><br><span class="line">                        conditionC.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"C"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"+++++++"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">                    count ++;</span><br><span class="line">                    <span class="keyword">if</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                        conditionA.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"ThreadC 中执行了 unlock"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>采用lock和condition结合使用即可</li><li>condition的await相当于Object的wait</li><li>condition的signal对于Object的notify</li><li>Condition中的signalAll()对应Object的notifyAll()</li><li>condition必须要在lock与unlock之间使用</li></ul><p><a href="https://www.jianshu.com/p/e3c6d4a5dd4b" target="_blank" rel="noopener">condition原理讲解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;采用synchronized&quot;&gt;&lt;a href=&quot;#采用synchronized&quot; class=&quot;headerlink&quot; title=&quot;采用synchronized&quot;&gt;&lt;/a&gt;采用synchronized&lt;/h1&gt;&lt;figure
      
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 最大子矩阵</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/30/leetcode-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/30/leetcode-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</id>
    <published>2020-08-30T01:52:59.000Z</published>
    <updated>2020-08-30T02:04:36.228Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/" target="_blank" rel="noopener">题目来源</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个正整数和负整数组成的 N × M 矩阵，编写代码<strong>找出元素总和最大的子矩阵</strong>。</p><p>返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">   [-1,0],</span><br><span class="line">   [0,-1]</span><br><span class="line">]</span><br><span class="line">输出: [0,1,0,1]</span><br><span class="line">解释: 输入中标粗的元素即为输出所表示的矩阵</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>枚举k1与k2确定这个矩阵的高</p><p>然后将k1-k2之间每一列(求出每一列的累计的和)看出一维数组的一项，在其中求最大子数组</p><p>即这个最大子数组的值就是子矩阵的和</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum[n+<span class="number">10</span>][m+<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) sum[i][j] = matrix[i][j];</span><br><span class="line">                <span class="keyword">else</span> sum[i][j] += sum[i<span class="number">-1</span>][j] + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r1,c1,r2,c2,maxx = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k1=<span class="number">0</span>;k1&lt;n;k1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k2=k1;k2&lt;n;k2++)&#123;</span><br><span class="line">                <span class="keyword">int</span> dp[n+<span class="number">10</span>],<span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">compressSum</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k1 == <span class="number">0</span>) compressSum[i] = sum[k2][i];</span><br><span class="line">                    <span class="keyword">else</span> compressSum[i] = sum[k2][i] - sum[k1 - <span class="number">1</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) dp[i] = compressSum[i];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> nums = compressSum[i];</span><br><span class="line">                        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>] + nums, nums);</span><br><span class="line">                        <span class="keyword">if</span> (dp[i] == nums) <span class="built_in">begin</span> = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i] &gt; maxx)&#123;</span><br><span class="line">                        maxx = dp[i];</span><br><span class="line">                        r1 = k1;</span><br><span class="line">                        c1 = <span class="built_in">begin</span>;</span><br><span class="line">                        r2 = k2;</span><br><span class="line">                        c2 = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">        ans.push_back(r1);</span><br><span class="line">        ans.push_back(c1);</span><br><span class="line">        ans.push_back(r2);</span><br><span class="line">        ans.push_back(c2);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/max-submatrix-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目来源&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个正整数和负整数组成的 N × M 矩阵，编写代码&lt;strong&gt;找出元素总和最大的子矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [-1,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [0,-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [0,1,0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 输入中标粗的元素即为输出所表示的矩阵&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="动态规划" scheme="https://sqwyyy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>美团笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/23/%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/23/%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-23T13:47:30.000Z</published>
    <updated>2020-08-23T13:56:15.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并金币"><a href="#合并金币" class="headerlink" title="合并金币"></a>合并金币</h1><p><a href="https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0?f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。  </p><p>其中，1 &lt;= N &lt;= 30，1 &lt;= C[i] &lt;= 100</p><a id="more"></a><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 2 4 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>区间dp</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合并金币&quot;&gt;&lt;a href=&quot;#合并金币&quot; class=&quot;headerlink&quot; title=&quot;合并金币&quot;&gt;&lt;/a&gt;合并金币&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0?f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。  &lt;/p&gt;
&lt;p&gt;其中，1 &amp;lt;= N &amp;lt;= 30，1 &amp;lt;= C[i] &amp;lt;= 100&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节2020春招笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/18/%E5%AD%97%E8%8A%822020%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/18/%E5%AD%97%E8%8A%822020%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-18T14:10:30.000Z</published>
    <updated>2020-08-23T15:12:59.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="万万没想到之抓捕孔连顺"><a href="#万万没想到之抓捕孔连顺" class="headerlink" title="万万没想到之抓捕孔连顺"></a>万万没想到之抓捕孔连顺</h1><p><a href="https://www.nowcoder.com/questionTerminal/c0803540c94848baac03096745b55b9b?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议</p><ol><li><p>我们在字节跳动大街的N个建筑中选定3个埋伏地点。</p></li><li><p>为了相互照应，我们决定相距最远的两名特工间的距离不超过D。</p></li></ol><p>我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！</p><p>……</p><p>万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！</p><p>请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。</p><p>注意：</p><ol><li><p>两个特工不能埋伏在同一地点</p></li><li><p>三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用</p></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每读取一个数字，就判断窗口是否满足最大值减去最小值不大于距离D；<br>由于每次进行计算组合之后，窗口的begin都会往前移动一位，所以计算组合应该采用固定首位的方法，即固定首位有一人，接下来的位置的可能性，这样就可以保证窗口移动过程不会出现重复，因为下一次判断已经不包含上一个的首位置了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n<span class="number">-1</span>) * n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, D; <span class="built_in">cin</span>&gt;&gt; N &gt;&gt; D;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>, <span class="built_in">begin</span> = <span class="number">0</span>; <span class="built_in">end</span> &lt; N; <span class="built_in">end</span>++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; res[<span class="built_in">end</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">end</span> &gt;= <span class="number">2</span> &amp;&amp; (res[<span class="built_in">end</span>] - res[<span class="built_in">begin</span>]) &gt; D) &#123;</span><br><span class="line">            <span class="built_in">begin</span>++;<span class="comment">//不满足则begin往前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        count += C(<span class="built_in">end</span> - <span class="built_in">begin</span>);<span class="comment">//由于判断一次往前移动（for循环中的end++），即可以采用每次固定首位的组合。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count % <span class="number">99997867</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="雀魂启动！"><a href="#雀魂启动！" class="headerlink" title="雀魂启动！"></a>雀魂启动！</h1><p><a href="https://www.nowcoder.com/questionTerminal/448127caa21e462f9c9755589a8f2416?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。</p><p>于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下：</p><ol><li>总共有36张牌，每张牌是1~9。每个数字4张牌。</li><li>你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌</li></ol><ul><li>14张牌中有2张相同数字的牌，称为雀头。</li><li>除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777）</li></ul><p>例如：</p><p>1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌</p><p>1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌</p><p>1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。</p><p>现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>依次尝试加入0~9的其中一个数字然后对其14个数字进行dfs判定是否可以和牌，符合和牌规则的加入答案</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>], helpArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">            state[num - <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state[i] &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = i + <span class="number">1</span>;</span><br><span class="line">                System.arraycopy(state, <span class="number">0</span>, helpArr, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">                helpArr[i]++;</span><br><span class="line">                <span class="keyword">if</span> (canHu(helpArr, <span class="number">14</span>, <span class="keyword">false</span>)) res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.isEmpty()) System.out.println(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuffer sbf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            sbf.append(res.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">                sbf.append(<span class="string">" "</span>);</span><br><span class="line">                sbf.append(res.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sbf.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canHu</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> total, <span class="keyword">boolean</span> hasHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (total == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasHead) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    arr[i] -= <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (canHu(arr, total - <span class="number">2</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    arr[i] += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[i] &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        arr[i] -= <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">if</span> (canHu(arr, total - <span class="number">3</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        arr[i] += <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> &lt; <span class="number">9</span> &amp;&amp; arr[i + <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; arr[i + <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        arr[i]--;</span><br><span class="line">                        arr[i + <span class="number">1</span>]--;</span><br><span class="line">                        arr[i + <span class="number">2</span>]--;</span><br><span class="line">                        <span class="keyword">if</span> (canHu(arr, total - <span class="number">3</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        arr[i]++;</span><br><span class="line">                        arr[i + <span class="number">1</span>]++;</span><br><span class="line">                        arr[i + <span class="number">2</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().sln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="毕业旅行问题"><a href="#毕业旅行问题" class="headerlink" title="毕业旅行问题"></a>毕业旅行问题</h1><p><a href="https://www.nowcoder.com/questionTerminal/3d1adf0f16474c90b27a9954b71d125d?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><p>超时只过50%</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">99997867</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pr&gt;g[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn],mpt[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1e5</span>,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep,<span class="keyword">int</span> s,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(total&gt;ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;<span class="number">1</span> &amp;&amp; s==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;=n)&#123;</span><br><span class="line">        total += mpt[s][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;total&lt;&lt;endl;</span></span><br><span class="line">        ans = <span class="built_in">min</span>(total,ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[s])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v.first])&#123;</span><br><span class="line">            vis[v.first] = <span class="number">1</span>;</span><br><span class="line">            dfs(dep+<span class="number">1</span>,v.first,total+v.second);</span><br><span class="line">            vis[v.first] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> price;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;price;</span><br><span class="line">            mpt[i][j] = price;</span><br><span class="line">            <span class="keyword">if</span>(j == i) <span class="keyword">continue</span>;</span><br><span class="line">            g[i].push_back(make_pair(j,price));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="机器人跳跃问题"><a href="#机器人跳跃问题" class="headerlink" title="机器人跳跃问题"></a>机器人跳跃问题</h1><p><a href="https://www.nowcoder.com/questionTerminal/7037a3d57bbd4336856b8e16a9cafd71?f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 </p><p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) &gt; E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。</p><p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>假设跳跃前能力为E,要跳的高度为H，那么跳跃后的能量就是2E-H，那么跳跃后的能量加上高度就是跳跃前的两倍，然后从后往前逆推。假设跳到最后一步的能力值设为0</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">99997867</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        ans = (ans+a[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2020-8-23第一题"><a href="#2020-8-23第一题" class="headerlink" title="2020.8.23第一题"></a>2020.8.23第一题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个n，l，r。构造一个长度为n的数组</p><ol><li>数组的元素的值a[i]需要在区间(l,r)之内</li><li>数组元素之和能与3相余为0</li></ol><p>则构造此数组的方法有多少种，答案模1e9+7</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><strong>dp(i,j)表示以a[i]为结尾且（数组和）%3=j的数组个数</strong>。</p><p>由于a[i]的可选值属于[l,r]，因此先算出[l,r]内%3=0，%3=1，%3=2的数的数量，分别记为x0,x1,x2。那么转移方程为</p><p>dp(i,0)= (dp(i-1,0)<em>x0%mod + dp(i-1,1)</em>x2%mod + dp(i-1,2)*x1%mod)%mod</p><p>dp(i,1)和dp(i,2)的类似</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>],b[<span class="number">3</span>],dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,l,r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">int</span> len = (r-l+<span class="number">1</span>);</span><br><span class="line">    a[<span class="number">0</span>] = l/<span class="number">3</span>;</span><br><span class="line">    a[<span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">    a[<span class="number">2</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(l%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">        a[<span class="number">1</span>]++;</span><br><span class="line">        a[<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        a[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">0</span>] = r/<span class="number">3</span>;</span><br><span class="line">    b[<span class="number">1</span>] = b[<span class="number">0</span>];</span><br><span class="line">    b[<span class="number">2</span>] = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(r%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">        b[<span class="number">1</span>]++;</span><br><span class="line">        b[<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        b[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x0 = b[<span class="number">0</span>] - a[<span class="number">0</span>], x1 = b[<span class="number">1</span>] - a[<span class="number">1</span>] , x2 = b[<span class="number">2</span>] - a[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = x0;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = x1;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = x2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] += dp[i<span class="number">-1</span>][<span class="number">0</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">1</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">1</span>] += dp[i<span class="number">-1</span>][<span class="number">1</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">0</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">2</span>] += dp[i<span class="number">-1</span>][<span class="number">2</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">0</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">1</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">0</span>] %= mod;</span><br><span class="line">        dp[i][<span class="number">1</span>] %= mod;</span><br><span class="line">        dp[i][<span class="number">2</span>] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;万万没想到之抓捕孔连顺&quot;&gt;&lt;a href=&quot;#万万没想到之抓捕孔连顺&quot; class=&quot;headerlink&quot; title=&quot;万万没想到之抓捕孔连顺&quot;&gt;&lt;/a&gt;万万没想到之抓捕孔连顺&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/c0803540c94848baac03096745b55b9b?answerType=1&amp;amp;f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>final</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/17/final/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/17/final/</id>
    <published>2020-08-17T09:58:39.000Z</published>
    <updated>2020-08-17T10:21:28.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h1><p>final关键字是用来修饰Java中的变量，方法，类的。修饰变量表示这个变量引用的地址不能变化，修饰方法表示这个方法不可覆盖，修饰类表示这个类无法继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;final关键字的作用&quot;&gt;&lt;a href=&quot;#final关键字的作用&quot; class=&quot;headerlink&quot; title=&quot;final关键字的作用&quot;&gt;&lt;/a&gt;final关键字的作用&lt;/h1&gt;&lt;p&gt;final关键字是用来修饰Java中的变量，方法，类的。修饰变量表示
      
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="final" scheme="https://sqwyyy.github.io/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBffuer、StringBuilder</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/17/String%E3%80%81StringBffuer%E3%80%81StringBuilder/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/17/String%E3%80%81StringBffuer%E3%80%81StringBuilder/</id>
    <published>2020-08-17T08:31:16.000Z</published>
    <updated>2020-08-17T13:00:21.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p> 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ <strong>可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的</strong>。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><a id="more"></a><p><strong>区分对象和对象引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);  </span><br><span class="line"></span><br><span class="line">s = <span class="string">"123456"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>首先创建一个String对象s，然后让s的值为“ABCabc”， 然后又让s的值为“123456”。 从打印结果可以看出，s的值确实改变了。那么怎么还说String对象是不可变的呢？ 其实这里存在一个误区： ==s只是一个String对象的引用，并不是对象本身。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。==</p><p>也就是说，s只是一个引用，它指向了一个具体的对象，当s=“123456”; 这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个新的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。</p><h1 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h1><p>​      StringBuffer 和 StringBuilder 都继承<strong>抽象类AbstractStringBuilder</strong>。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><hr><p>​     StringBuilder 类在 Java 5 中被提出，它和 <strong>StringBuffer</strong> 之间的最大不同在于 StringBuilder 的方法<strong>不是线程安全</strong>的（不能同步访问）。</p><hr><h2 id="StringBuiler为什么线程安全以及StringBuffer为什么线程不安全"><a href="#StringBuiler为什么线程安全以及StringBuffer为什么线程不安全" class="headerlink" title="StringBuiler为什么线程安全以及StringBuffer为什么线程不安全"></a>StringBuiler为什么线程安全以及StringBuffer为什么线程不安全</h2><p>以StringBuilder的append()方法为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>.    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">3</span>.        <span class="keyword">return</span> appendNull();</span><br><span class="line"><span class="number">4</span>.    <span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="number">5</span>.    ensureCapacityInternal(count + len);</span><br><span class="line"><span class="number">6</span>.    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line"><span class="number">7</span>.    count += len;</span><br><span class="line"><span class="number">8</span>.    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">9</span>.&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p><strong>count += len不是一个原子操作.</strong><br>假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12</p></li><li><p>ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容</p></li><li><p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面.</p></li></ol><p><strong>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count=5。</strong><br><strong>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</strong></p><hr><p><strong>StringBuffer则根据synchronized关键字实现线程安全</strong></p><p><a href="https://zhuanlan.zhihu.com/p/85867299" target="_blank" rel="noopener">来源1</a><br><a href="https://blog.csdn.net/u011702479/article/details/82262823" target="_blank" rel="noopener">来源2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;p&gt; 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ &lt;strong&gt;可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的&lt;/strong&gt;。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/categories/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Sting" scheme="https://sqwyyy.github.io/tags/Sting/"/>
    
  </entry>
  
  <entry>
    <title>腾讯2020校招笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/16/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/16/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-16T05:58:44.000Z</published>
    <updated>2020-08-23T13:58:10.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逛街"><a href="#逛街" class="headerlink" title="逛街"></a>逛街</h1><p><a href="https://www.nowcoder.com/questionTerminal/35fac8d69f314e958a150c141894ef6a?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。</p><p>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用单调栈实现，开辟一个数组rightLook 保留往右看得到的数量，从右往左遍历，利用单调栈将看得到的数量保留在数组 rightLook 中 ，再从左往右遍历，获取往左看的计数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r[maxn],a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">     r[i] = q.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>(!q.empty() &amp;&amp; a[i] &gt;= a[q.top()])&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">     &#125;</span><br><span class="line">     q.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">     <span class="keyword">int</span> num = r[i] + <span class="number">1</span> + q.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>(!q.empty() &amp;&amp; a[i] &gt;= a[q.top()])&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">     q.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="假期"><a href="#假期" class="headerlink" title="假期"></a>假期</h1><p><a href="https://www.nowcoder.com/questionTerminal/7cd9a140387e455a972e8fea0e74be2c?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>dp(i,0) , dp(i,1), dp(i,2) 分别记录第i天 休息/锻炼/工作 累计的最小休息天数</p><p>如果第i天休息，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,1), dp(i,2)中的最小值+1</p><p>如果第i天工作，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,1)中的最小值</p><p>如果第i天健身，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,2)中的最小值</p><p>答案就是dp(n,0) , dp(n,1), dp(n,2)中的最小值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( b[i] == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="comment">// 可以锻炼</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">min</span>( dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( a[i] == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="comment">// 可以工作</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">min</span>( dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], <span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">min</span>(dp[n][<span class="number">0</span>], <span class="built_in">min</span>(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="视野争夺"><a href="#视野争夺" class="headerlink" title="视野争夺"></a>视野争夺</h1><p><a href="https://www.nowcoder.com/questionTerminal/61e1e66e39f348cdb6495de91ac36a41?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。</p><p>这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。 </p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>根据贪心算法，将数组按照左节点排序</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;逛街&quot;&gt;&lt;a href=&quot;#逛街&quot; class=&quot;headerlink&quot; title=&quot;逛街&quot;&gt;&lt;/a&gt;逛街&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/35fac8d69f314e958a150c141894ef6a?answerType=1&amp;amp;f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-03T13:43:27.000Z</published>
    <updated>2020-08-12T15:02:58.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h1><h2 id="内存的含义"><a href="#内存的含义" class="headerlink" title="内存的含义"></a>内存的含义</h2><p><strong>内存就是用于存放数据的硬件。程序执行前需要放到内存中才能被CPU处理。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存的基础知识&quot;&gt;&lt;a href=&quot;#内存的基础知识&quot; class=&quot;headerlink&quot; title=&quot;内存的基础知识&quot;&gt;&lt;/a&gt;内存的基础知识&lt;/h1&gt;&lt;h2 id=&quot;内存的含义&quot;&gt;&lt;a href=&quot;#内存的含义&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存管理" scheme="https://sqwyyy.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JWT实现</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/28/JWT%E5%AE%9E%E7%8E%B0/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/28/JWT%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-28T14:19:50.000Z</published>
    <updated>2020-08-03T10:38:50.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><ul><li><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</p></li><li><p>是一种<strong>认证授权机制</strong>。</p></li><li><p>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p></li><li><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p></li></ul><a id="more"></a><h2 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h2><p><img src="https://pic3.zhimg.com/v2-aa19a381cbae00402e82b710f2db6e06_b.jpg" alt=""></p><p><strong>JWT 认证流程：</strong></p><ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</li><li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li><p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</p></li><li><p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</p></li><li><p>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</p></li><li><p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</p></li></ul><h2 id="Token和JWT的区别"><a href="#Token和JWT的区别" class="headerlink" title="Token和JWT的区别"></a>Token和JWT的区别</h2><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>区别：</strong></p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul><h2 id="使用JWT时需要考虑的问题"><a href="#使用JWT时需要考虑的问题" class="headerlink" title="使用JWT时需要考虑的问题"></a>使用JWT时需要考虑的问题</h2><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/164696755" target="_blank" rel="noopener">JWT详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是JWT&quot;&gt;&lt;a href=&quot;#什么是JWT&quot; class=&quot;headerlink&quot; title=&quot;什么是JWT&quot;&gt;&lt;/a&gt;什么是JWT&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JSON Web Token（简称 JWT）是目前最流行的&lt;strong&gt;跨域认证&lt;/strong&gt;解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是一种&lt;strong&gt;认证授权机制&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JWT 是为了在网络应用环境间&lt;strong&gt;传递声明&lt;/strong&gt;而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JWT" scheme="https://sqwyyy.github.io/categories/JWT/"/>
    
    
      <category term="JWT" scheme="https://sqwyyy.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>NAT协议</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/25/NAT%E5%8D%8F%E8%AE%AE/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/25/NAT%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-07-25T14:47:52.000Z</published>
    <updated>2020-07-27T14:51:28.898Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决ip地址稀缺问题，采用NAT技术使内网（私网）转换为公网</p><a id="more"></a><p>具体的转换规则:</p><p>对于TCP/UDP使用：</p><p>Host’s 私有IPv4 + Port &lt;——-&gt; NAT 公网IPv4 + Port</p><p>对于ICMP使用</p><p>Host’s 私有IPv4 + session ID &lt;——-&gt; NAT 公网IPv4 + session ID</p><p>session ID在NAT设备上是独一无二的</p><p><a href="https://www.jianshu.com/p/4cd76e25b894" target="_blank" rel="noopener">NAT技术</a></p><p><a href="https://www.zhihu.com/question/31332694/answer/118410360" target="_blank" rel="noopener">NAT转换对应规则</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了解决ip地址稀缺问题，采用NAT技术使内网（私网）转换为公网&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="NAT协议" scheme="https://sqwyyy.github.io/tags/NAT%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/22/%E8%BF%9B%E7%A8%8B/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/22/%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-07-22T13:40:01.000Z</published>
    <updated>2020-07-23T14:28:48.223Z</updated>
    
    <content type="html"><![CDATA[<p>进程由进程控制块（PCB）、程序段、数据段三部分组成。</p><ul><li><p>进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。</p><ul><li><p>标识符：与进程相关的唯一标识符，用来区分其他进程。</p></li><li><p>状态：进程有不同的状态，例如运行，就绪，阻塞等。</p></li><li>优先级：为了给处理机调度提供支持，优先级用来区分各种进程的先后执行顺序</li><li>程序计数器：程序中即将执行的下一条指令的地址</li><li>内存指针：包括程序代码的进程相关数据的指针，以及与其他进程贡献那个内存块的指针。</li><li>上下文：进程是需要切换的，切换进程时需要保留进程的上下文信息，以防进程在切换时丢 失现场数据。</li><li>i/o状态信息：包括显示i/o请求，分配给进程的i/o设备和被进程使用的文件列表等。</li><li>记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li></ul></li><li>代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。</li><li>数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据</li></ul><a id="more"></a><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><ol><li>无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li><li>FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li><li>消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li><li>信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li><li>共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。</li></ol><h2 id="进程间五种通信方式的比较"><a href="#进程间五种通信方式的比较" class="headerlink" title="进程间五种通信方式的比较"></a>进程间五种通信方式的比较</h2><ul><li>管道：速度慢，容量有限，只有父子进程能通讯。</li><li>FIFO：任何进程间都能通讯，但速度慢。</li><li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</li><li>信号量：不能传递复杂消息，只能用来同步。</li><li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li></ul><h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><p>线程之间的通信机制有两种，<strong>共享内存和消息传递</strong></p><ul><li>使用volatile是属于共享内存模型</li><li>使用wait和notify方法属于消息传递(wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁)<br><a href="https://blog.csdn.net/jisuanji12306/article/details/86363390" target="_blank" rel="noopener">代码实例</a></li></ul><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p><a href="https://blog.csdn.net/kuangsonghan/article/details/80674777" target="_blank" rel="noopener">来源</a><br>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><p>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><h2 id="关于线程与进程的选取"><a href="#关于线程与进程的选取" class="headerlink" title="关于线程与进程的选取"></a>关于线程与进程的选取</h2><ol><li><p>需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。</p></li><li><p>线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p></li><li><p>因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；</p></li><li><p>并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；</p></li><li><p>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</p></li></ol><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>串行：一次只能取得一个任务并执行这一个任务<br>并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务<br>并发是一种现象：同时运行多个程序或多个任务需要被处理的现象<br><a href="https://www.cnblogs.com/f-ck-need-u/p/11161481.html" target="_blank" rel="noopener">来源</a></p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ol><li>新建：就是刚使用new方法，new出来的线程；</li><li>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li><li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</li><li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li><li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;<br><a href="https://www.cnblogs.com/marsitman/p/11228684.html" target="_blank" rel="noopener">来源</a><br><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt=""></li></ol><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>​      在进程A切换到进程B的过程中，<strong>先保存A进程的上下文</strong>，以便于等A恢复运行的时候，能够知道A进程的下一条指令是什么。然后将<strong>要运行的B进程的上下文恢复到寄存器中</strong>，这个过程被称为<strong>上下文切换</strong>。</p><p>  上下文切换的主要开销有:</p><ol><li>切换页表全局目录</li><li>切换内核态堆栈</li><li>切换硬件上下文</li><li>刷新TLB</li><li>系统调用器的代码执行</li></ol><p><a href="https://zhuanlan.zhihu.com/p/52845869" target="_blank" rel="noopener">上下文切换</a></p><h2 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h2><p><strong>僵尸进程</strong>：</p><p><strong>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><p><strong>孤儿进程</strong>：</p><p><strong>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>孤儿进程并不会有什么危害，真正会对系统构成威胁的是僵尸进程</strong></p><p><strong>僵尸进程产生的问题：</strong></p><p>设想有这样一个父进程：它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵尸进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程</p><p><strong>解决僵尸进程的方法:</strong></p><p>当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶枪毙掉（通过kill发送SIGTERM或者SIGKILL信号）。</p><p>枪毙了元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经“僵尸”的孤儿进程就能瞑目而去了。</p><p><a href="https://www.zhihu.com/question/26432067/answer/70643183" target="_blank" rel="noopener">僵尸进程与孤儿进程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程由进程控制块（PCB）、程序段、数据段三部分组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标识符：与进程相关的唯一标识符，用来区分其他进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态：进程有不同的状态，例如运行，就绪，阻塞等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;优先级：为了给处理机调度提供支持，优先级用来区分各种进程的先后执行顺序&lt;/li&gt;
&lt;li&gt;程序计数器：程序中即将执行的下一条指令的地址&lt;/li&gt;
&lt;li&gt;内存指针：包括程序代码的进程相关数据的指针，以及与其他进程贡献那个内存块的指针。&lt;/li&gt;
&lt;li&gt;上下文：进程是需要切换的，切换进程时需要保留进程的上下文信息，以防进程在切换时丢 失现场数据。&lt;/li&gt;
&lt;li&gt;i/o状态信息：包括显示i/o请求，分配给进程的i/o设备和被进程使用的文件列表等。&lt;/li&gt;
&lt;li&gt;记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。&lt;/li&gt;
&lt;li&gt;数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="https://sqwyyy.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的线程</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/22/JAVA%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/22/JAVA%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-07-22T13:36:31.000Z</published>
    <updated>2020-08-30T13:09:22.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。<strong>调用sleep不会释放对象锁</strong>,在多线程异步时可能用到。</p><p>wait是Object类的方法，对此对象调用wait方法<strong>导致本线程放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池<strong>准备</strong>获得对象锁进入运行状态。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，</span></span><br><span class="line">            <span class="comment">// 我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。</span></span><br><span class="line">            <span class="comment">// 我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MultiThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"enter thread1..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread1 is waiting"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁有两种方式，第一种方式是程序自然离开监视器的范围，</span></span><br><span class="line">                    <span class="comment">// 也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字</span></span><br><span class="line">                    <span class="comment">// 管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。</span></span><br><span class="line">                    MultiThread<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"thread1 is going on..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread1 is being over!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MultiThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"enter thread2..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 notify other thread can release wait status.."</span>);</span><br><span class="line">                <span class="comment">// 由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，</span></span><br><span class="line">                <span class="comment">// 但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。</span></span><br><span class="line">                MultiThread<span class="class">.<span class="keyword">class</span>.<span class="title">notify</span>()</span>;</span><br><span class="line">                System.out.println(<span class="string">"thread2 is sleeping ten millisecond..."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"thread2 is going on..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 is being over!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter thread1...</span><br><span class="line">thread1 is waiting</span><br><span class="line">enter thread2...</span><br><span class="line">thread2 notify other thread can release wait status..</span><br><span class="line">thread2 is sleeping ten millisecond...</span><br><span class="line">thread2 is going on...</span><br><span class="line">thread2 is being over!</span><br><span class="line">thread1 is going on...</span><br><span class="line">thread1 is being over!</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/ab05baf75d75" target="_blank" rel="noopener">来源</a></p><h3 id="中断线程的方法"><a href="#中断线程的方法" class="headerlink" title="中断线程的方法"></a>中断线程的方法</h3><ol><li>使用interrupt()方法中断当前线程：interrupt()其本身并不是一个强制打断线程的方法，其仅仅会修改线程的interrupt标志位，然后让线程自行去读标志位，自行判断是否需要中断。在设计里，如果线程处于休眠状态，那一旦其被调用interrupt()方法，则就没有必要继续休眠下去了，直接抛出异常InterruptedException，让被打断线程去做收尾操作，及时释放线程资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i&#x3D;202053</span><br><span class="line">i&#x3D;202054</span><br><span class="line">i&#x3D;202055</span><br><span class="line">i&#x3D;202056</span><br></pre></td></tr></table></figure><ol><li>如果使用线程池可将线程池的状态修改为STOP状态(该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；)</li></ol><h3 id="控制多个线程按顺序执行"><a href="#控制多个线程按顺序执行" class="headerlink" title="控制多个线程按顺序执行"></a>控制多个线程按顺序执行</h3><p>join方法:</p><ol><li>在子线程中通过join()方法指定顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread2.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//下面三行代码顺序可随意调整，程序运行结果不受影响，因为我们在子线程中通过“join()方法”已经指定了运行顺序。</span></span><br><span class="line">        thread3.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在主线程中通过join()方法指定顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMainJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建单一化线程池newSingleThreadExecutor()实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span> ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(thread1);</span><br><span class="line">        executorService.submit(thread2);</span><br><span class="line">        executorService.submit(thread3);</span><br><span class="line">        executorService.shutdown();        <span class="comment">//使用完毕记得关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jqc874789596/article/details/100557300" target="_blank" rel="noopener">来源</a></p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;wait和sleep的区别&quot;&gt;&lt;a href=&quot;#wait和sleep的区别&quot; class=&quot;headerlink&quot; title=&quot;wait和sleep的区别&quot;&gt;&lt;/a&gt;wait和sleep的区别&lt;/h3&gt;&lt;p&gt;sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。&lt;strong&gt;调用sleep不会释放对象锁&lt;/strong&gt;,在多线程异步时可能用到。&lt;/p&gt;
&lt;p&gt;wait是Object类的方法，对此对象调用wait方法&lt;strong&gt;导致本线程放弃对象锁&lt;/strong&gt;，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池&lt;strong&gt;准备&lt;/strong&gt;获得对象锁进入运行状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://sqwyyy.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>springboot整合swagger</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/10/springboot%E6%95%B4%E5%90%88swagger/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/10/springboot%E6%95%B4%E5%90%88swagger/</id>
    <published>2020-07-10T11:17:56.506Z</published>
    <updated>2020-07-10T11:19:44.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot整合swagger"><a href="#springboot整合swagger" class="headerlink" title="springboot整合swagger"></a>springboot整合swagger</h1><a id="more"></a><h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="新建配置类"><a href="#新建配置类" class="headerlink" title="新建配置类"></a>新建配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 createRestApi函数来构建一个DocketBean</span></span><br><span class="line"><span class="comment">     * 函数名,可以随意命名,喜欢什么命名就什么命名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())<span class="comment">//调用apiInfo方法,创建一个ApiInfo实例,里面是展示在文档页面信息内容</span></span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//控制暴露出去的路径下的实例</span></span><br><span class="line">                <span class="comment">//如果某个接口不想暴露,可以使用以下注解</span></span><br><span class="line">                <span class="comment">//@ApiIgnore 这样,该接口就不会暴露在 swagger2 的页面下</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.example.zwd.springbootswagger2.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建 api文档的详细信息函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                <span class="comment">//页面标题</span></span><br><span class="line">                .title(<span class="string">"Spring Boot Swagger2 构建RESTful API"</span>)</span><br><span class="line">                <span class="comment">//条款地址</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">"http://despairyoke.github.io/"</span>)</span><br><span class="line">                .contact(<span class="string">"zwd"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                <span class="comment">//描述</span></span><br><span class="line">                .description(<span class="string">"API 描述"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此时启动项目，输入<a href="http://localhost:8080/swagger-ui.html，能够看到如下页面，说明已经配置成功了：" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html，能够看到如下页面，说明已经配置成功了：</a></li><li><img src="https://img-blog.csdnimg.cn/20190324120135562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly93YW5nc29uZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt=""></li></ul><h2 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"用户管理相关接口"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"添加用户的接口"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParams</span>(&#123;</span><br><span class="line">            <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"username"</span>, value = <span class="string">"用户名"</span>, defaultValue = <span class="string">"李四"</span>),</span><br><span class="line">            <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"address"</span>, value = <span class="string">"用户地址"</span>, defaultValue = <span class="string">"深圳"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">addUser</span><span class="params">(String username, @RequestParam(required = <span class="keyword">true</span>)</span> String address) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"根据id查询用户的接口"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"id"</span>, value = <span class="string">"用户id"</span>, defaultValue = <span class="string">"99"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"根据id更新用户的接口"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUserById</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>@Api注解可以用来标记当前Controller的功能。</p></li><li><p>@ApiOperation注解用来标记一个方法的作用。</p></li><li><p>@ApiImplicitParam注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。</p></li><li><p>如果有多个参数，则需要使用多个@ApiImplicitParam注解来描述，多个@ApiImplicitParam注解需要放在一个@ApiImplicitParams注解中。</p></li><li><p>需要注意的是，@ApiImplicitParam注解中虽然可以指定参数是必填的，但是却不能代替@RequestParam(required = true)，前者的必填只是在Swagger2框架内必填，抛弃了Swagger2，这个限制就没用了，所以假如开发者需要指定一个参数必填，@RequestParam(required = true)注解还是不能省略。</p></li><li><p>如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中。例如下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户地址"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190324120155527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly93YW5nc29uZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt=""></p></li></ol><p><a href="https://blog.csdn.net/u012702547/article/details/88775298" target="_blank" rel="noopener">来源</a></p><p><a href="https://www.jianshu.com/p/406e9d203300" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;springboot整合swagger&quot;&gt;&lt;a href=&quot;#springboot整合swagger&quot; class=&quot;headerlink&quot; title=&quot;springboot整合swagger&quot;&gt;&lt;/a&gt;springboot整合swagger&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
