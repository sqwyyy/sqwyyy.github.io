<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sqwyyy.com/"/>
  <updated>2020-05-07T16:49:37.768Z</updated>
  <id>http://sqwyyy.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 907</title>
    <link href="http://sqwyyy.com/2020/05/08/907/"/>
    <id>http://sqwyyy.com/2020/05/08/907/</id>
    <published>2020-05-07T16:45:18.000Z</published>
    <updated>2020-05-07T16:49:37.768Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。<br />由于答案可能很大，因此返回答案模 10^9 + 7</p><a id="more"></a><hr /><p>输入：[3,1,2,4]<br />输出：17<br />解释：<br />子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。<br />最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</p><hr /><ol><li>找出这个数字左边有几个，右边有几个，赋值为m、n；</li><li>计算以这个数字为最小值的情况有集中：(m+1)*(n+1);</li><li>遍历数组A的每一个元素，以其为最小数的次数乘其本身，再求和就是最后结果啦。</li><li>正常情况下，找出数组中每一个元素左边和右边各有几个连续的、比它小的数字的复杂度为n的二次方，怎样可以优化算法复杂度呢。</li><li><mark>是否可以维护一个栈，只存比当前栈顶元素更大的元素，在一个元素入栈之前要将所有比它小的数都弹出栈，那么，在这个元素入栈的时候，可以知道左边（连续）比他大的数有几个，出栈的时候会知道右边的数有几个。这样，复杂度变为了O（N）.</mark></li></ol><hr /><pre><div class="hljs"><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{        <span class="hljs-keyword">long</span> mod = <span class="hljs-number">1000000007</span>;        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(A==<span class="hljs-keyword">null</span>||A.length==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len = A.length;        <span class="hljs-keyword">int</span>[] left=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        Stack&lt;Integer&gt;stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++){            <span class="hljs-keyword">while</span>(!stack.empty()&amp;&amp;A[i]&lt;=A[stack.peek()]){                <span class="hljs-keyword">int</span> pos = stack.pop();                right[pos]=i-pos-<span class="hljs-number">1</span>;            }            <span class="hljs-keyword">if</span>(stack.empty()){                left[i]=i;            }            <span class="hljs-keyword">else</span>{                left[i]=i-stack.peek()-<span class="hljs-number">1</span>;            }            stack.push(i);        }        <span class="hljs-keyword">while</span>(!stack.empty()){            <span class="hljs-keyword">int</span> pos = stack.pop();            right[pos]=len-pos-<span class="hljs-number">1</span>;        }        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++){            ans+=((left[i]+<span class="hljs-number">1</span>)*(right[i]+<span class="hljs-number">1</span>)%mod)*A[i]%mod;        }        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(ans % mod);    }}<p></code></div></pre></p><p><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/onfu-za-du-de-javajie-fa-by-mei-shou-gan/" target="_blank">来源</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。&lt;br /&gt;
由于答案可能很大，因此返回答案模 10^9 + 7&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="单调栈" scheme="http://sqwyyy.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>单调栈经典题</title>
    <link href="http://sqwyyy.com/2020/05/07/%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
    <id>http://sqwyyy.com/2020/05/07/%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%8F%E5%85%B8%E9%A2%98/</id>
    <published>2020-05-07T12:04:23.000Z</published>
    <updated>2020-05-07T16:47:48.295Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给出一个序列，要求的是一个区间，这个区间的最小值乘以这个区间数字的和是最大值</p><a id="more"></a><p><mark>单调栈处理的问题就是对每一个节点进行扩展的问题，<br />这个题目要维护的是一个单调递减栈，即从栈顶元素到栈底元素，值是单调递减的，即栈顶元素的值始终是栈的最大值。然后每一个值有属于自己的区间，这个区间目的是为了记录之后的元素向前延伸的用处。<br />向后延伸就靠从1到n扫描元素，(维护单调递减栈)这样当扫描的元素大于栈顶元素时，直接入栈。<br />当扫描的元素等于栈顶元素时，不记录，只将区间延伸到后面。<br />当扫描的元素小于栈顶元素时，这时要计算栈内当前的值。因为扫描的元素时小于栈顶元素的，要求的是一个区间的最小值，所以栈内那些大于该元素的值你会发现没有用处了，只需要将它们的那些区间留下来就对了，这就是向前扩展。</mark></p><hr /><p>3 1 6 4 5 2</p><p>一开始每一个数都有自己的区间：</p><p>3(1,1)  1(2,2)  6(3,3)  4(4,4)  5(5,5)  2(6,6)  -1(7,7)后面加一个最小值，为了最后计算栈内元素使用。</p><p>先是3入栈。栈内元素 3(1,1)</p><p>1&lt;3，首先计算一下栈内元素的值，记录下来。然后要把栈内大于1的全部弹出来，但是把它们的区间留下，栈内就变成了1(1,2)。实际上此时就会知道(1,2)这段区间之内的最小值是1。<br />6&gt;1，直接入栈，栈内元素变为1(1,2)，6(3,3)。<br />4&lt;6，将6弹出，弹出之前计算值。然后栈内就变为1(1,2)，4(3,4)。<br />5&gt;4，直接入栈。栈内元素是1(1,2),4(3,4),5(5,5)。会发现因为5没有办法向前扩展了所以会知道5只能够在(5,5)的区间内最小，所以说站内元素是在自己区间的左端点与栈顶元素的右端点，这段区间之内满足着最小值的关系。1是在(1,5)这段区间内最小，4是在(3,5)这段区间内最小。这些值都会在碰到扫描的元素小于该元素时计算，记录下来，就是这样单调栈完成了对每一个元素进行左右扩展的目的。<br />2&lt;5,2&lt;4。要把5(5,5) 4(3,4)分别弹出，它们走之前要计算各自区间的值。<br />最后是-1，目的就是要将栈内所有元素弹出，计算每一个元素左右扩展的值。</p><hr /><pre><div class="hljs"><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100001</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> a[N], lef[N], s[N], top;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum[N];<p><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>{<br>    ios_base::sync_with_stdio(<span class="hljs-number">0</span>), <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>), <span class="hljs-built_in">cout</span>.tie(<span class="hljs-number">0</span>);<br>    ll ans = <span class="hljs-number">-1</span>, tmp;<br>    <span class="hljs-keyword">int</span> i, j, n;<br>    <span class="hljs-keyword">int</span> ll, rr;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-built_in">memset</span>(sum, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sum));<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    {<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>    }<br>    a[++n] = <span class="hljs-number">-1</span>;<br>    top = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    {<br>        <span class="hljs-keyword">if</span> (top == <span class="hljs-number">0</span> || a[i] &gt; a[s[top - <span class="hljs-number">1</span>]])<br>        {<br>            s[top++] = i;<br>            lef[i] = i;<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (a[i] == a[s[top - <span class="hljs-number">1</span>]])<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">while</span> (top &gt;= <span class="hljs-number">1</span> &amp;&amp; a[i] &lt; a[s[top - <span class="hljs-number">1</span>]])<br>        {<br>            –top;<br>            tmp = <span class="hljs-number">1L</span>L*a[s[top]] * (sum[i - <span class="hljs-number">1</span>] - sum[lef[s[top]] - <span class="hljs-number">1</span>]);</p><pre><code>        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (tmp &amp;gt; ans)        {            ll = lef[s[top]];            rr = i - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;            ans = tmp;        }    }    lef[i] = lef[s[top]];    s[top++] = i;}&lt;span class=&quot;hljs-built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;&amp;lt;&amp;lt;l&amp;lt;&amp;lt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; &quot;&lt;/span&gt;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;endl&lt;/span&gt;;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;</code></pre><p>}</p><p></code></div></pre></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给出一个序列，要求的是一个区间，这个区间的最小值乘以这个区间数字的和是最大值&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://sqwyyy.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单调栈" scheme="http://sqwyyy.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
</feed>
