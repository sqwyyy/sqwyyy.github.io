<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-05-25T13:22:03.391Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字链路层</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%95%B0%E5%AD%97%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%95%B0%E5%AD%97%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-05-25T13:21:13.000Z</published>
    <updated>2020-05-25T13:22:03.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链路层的意义"><a href="#链路层的意义" class="headerlink" title="链路层的意义"></a>链路层的意义</h1><p>物理层的线路有传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用<strong>差错检测、封装成帧和透明传输</strong>等方法，向网络层提供高质量的数据传输服务。</p><p><strong>数据链路层的最基本的功能是向上层提供透明的和可靠的数据传送基本服务</strong></p><a id="more"></a><h1 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h1><p>数据链路层使用的信道主要有两种类型：</p><ul><li>点对点信道：也就是字面意思，点对点得通信方式。</li><li>广播信道：这种信道是一对多的方式，所以整个过程也比较复杂。必须使用一些信道协议来协调网络中的主机数据发送。</li></ul><h1 id="点到点信道"><a href="#点到点信道" class="headerlink" title="点到点信道"></a>点到点信道</h1><ol><li><p>节点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。 </p></li><li><p>节点A把封装好的帧发送给节点B的数据链路层。 </p></li><li>若节点B的数据链路层收到的帧无差错，则从收到的帧当中提取出IP数据报上交给上面的网络层，否则丢弃这个帧。</li></ol><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>其实就是在帧的前后添加首部和尾部。这个时候我们就需要考虑，我们如何来识别一个帧，所以这里提出了一个帧定界的概念，使用两个控制字符，一个控制字符SOH放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT标识帧的结束</p><p>一帧多大呢？<strong>MTU就是帧的数据部分的最大长度，也就是IP数据报的最大长度</strong>。</p><h3 id="MTU-和-MSS-区别"><a href="#MTU-和-MSS-区别" class="headerlink" title="MTU 和 MSS 区别"></a>MTU 和 MSS 区别</h3><ul><li>MTU： Maximum Transmit Unit，最大传输单元，即物理接口（数据链路层）提供给其上层（通常是IP层）最大一次传输数据的大小</li><li>MSS：Maximum Segment Size ，TCP一次能够传输的数据(不包括协议头的开销)的最大值</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>在帧的有效数据当中，可能出现和帧定界的控制字符一样的字符，为了防止将这些字符当中帧定界的字符，使用<strong>字节填充法</strong></p><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符”ESC”。而在接收端的数据链路层在将数据送往网络层之前删除这个插入的转义字符。我们把这种方法叫做字节填充法</p><h2 id="差错检错"><a href="#差错检错" class="headerlink" title="差错检错"></a>差错检错</h2><p>数据链路层点对点传输的第三个问题就是差错检测。就是我们所说的比特在传出过程当中可能会产生差错，1可能会变成0，0可能会变成1.</p><p>解决方法: CRC</p><p>CRC的基本思想就是将传输的数据当作一个位数很长的数，将这个数除以另外的一个数。得到的余数作为校验数据附加到原数据后面。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;链路层的意义&quot;&gt;&lt;a href=&quot;#链路层的意义&quot; class=&quot;headerlink&quot; title=&quot;链路层的意义&quot;&gt;&lt;/a&gt;链路层的意义&lt;/h1&gt;&lt;p&gt;物理层的线路有传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用&lt;strong&gt;差错检测、封装成帧和透明传输&lt;/strong&gt;等方法，向网络层提供高质量的数据传输服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据链路层的最基本的功能是向上层提供透明的和可靠的数据传送基本服务&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="数字链路层" scheme="https://sqwyyy.github.io/tags/%E6%95%B0%E5%AD%97%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络常见面试题</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-05-25T13:20:05.000Z</published>
    <updated>2020-05-25T13:20:48.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI，TCP-IP，五层协议的体系结构，以及各层协议"><a href="#OSI，TCP-IP，五层协议的体系结构，以及各层协议" class="headerlink" title="OSI，TCP/IP，五层协议的体系结构，以及各层协议"></a>OSI，TCP/IP，五层协议的体系结构，以及各层协议</h1><ul><li><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p></li><li><p>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。</p></li><li><p>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</p></li></ul><ol><li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）</li><li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li><li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li><li>传输层：TCP、UDP、SPX</li><li>会话层：NFS、SQL、NETBIOS、RPC</li><li>表示层：JPEG、MPEG、ASII</li><li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li></ol><a id="more"></a><h1 id="从浏览器中输入URL到页面展示到底发生了什么"><a href="#从浏览器中输入URL到页面展示到底发生了什么" class="headerlink" title="从浏览器中输入URL到页面展示到底发生了什么"></a>从浏览器中输入URL到页面展示到底发生了什么</h1><ol><li><p>浏览器获取输入的域名URL</p></li><li><p>浏览器向DNS查找域名的IP地址</p></li><li>域名系统DNS解析出域名服务器的IP地址</li><li>浏览器与该服务器建立TCP连接(默认端口号80)</li><li>浏览器发出HTTP请求，请求页面</li><li>服务器通过HTTP响应把html文件发送给浏览器</li><li>TCP连接释放</li><li>浏览器将html文件进行解析，并显示给用户。</li></ol><p><a href="https://zhuanlan.zhihu.com/p/79350395" target="_blank" rel="noopener">解析</a><br>涉及到的协议</p><ul><li><p>应用层：HTTP(WWW访问协议)，DNS(域名解析服务)</p></li><li><p>传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)</p></li><li><p>网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)</p></li></ul><h2 id="DNS查找域名的IP地址"><a href="#DNS查找域名的IP地址" class="headerlink" title="DNS查找域名的IP地址"></a>DNS查找域名的IP地址</h2><p>比如网址时www.qq.com,真正的写法应该时<strong>www.qq.com.</strong>，.代表的就是根域名服务，.com代表的就是顶级域名,.qq代表的则是次级域名</p><ol><li><p>请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会<strong>首先查看本地硬盘的 hosts 文件</strong>，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p></li><li><p>如果在本地的 hosts 文件没有能够找到对应的 ip 地址，<strong>浏览器会发出一个 DNS请求到本地DNS服务器</strong> 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p></li><li><p>查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</strong></p></li><li><p><strong>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出顶级域服务器的地址</strong>。这种过程是迭代的过程。</p></li><li><p>本地DNS服务器继续向顶级域服务器发出请求，在这个例子中，请求的对象是.com域服务器。<strong>.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的次级域名服务器的地址</strong>。</p></li><li><p>最后，<strong>本地DNS服务器向次级域名服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中</strong>，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p></li></ol><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><strong>ARP是地址解析协议</strong></p><ol><li><p>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p></li><li><p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</p></li><li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p></li><li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。</p></li></ol><h2 id="icmp协议"><a href="#icmp协议" class="headerlink" title="icmp协议"></a>icmp协议</h2><p><a href="https://blog.csdn.net/baidu_37964071/article/details/80514340" target="_blank" rel="noopener">icmp</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OSI，TCP-IP，五层协议的体系结构，以及各层协议&quot;&gt;&lt;a href=&quot;#OSI，TCP-IP，五层协议的体系结构，以及各层协议&quot; class=&quot;headerlink&quot; title=&quot;OSI，TCP/IP，五层协议的体系结构，以及各层协议&quot;&gt;&lt;/a&gt;OSI，TCP/IP，五层协议的体系结构，以及各层协议&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）&lt;/li&gt;
&lt;li&gt;数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）&lt;/li&gt;
&lt;li&gt;网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）&lt;/li&gt;
&lt;li&gt;传输层：TCP、UDP、SPX&lt;/li&gt;
&lt;li&gt;会话层：NFS、SQL、NETBIOS、RPC&lt;/li&gt;
&lt;li&gt;表示层：JPEG、MPEG、ASII&lt;/li&gt;
&lt;li&gt;应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp与udp</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/tcp%E4%B8%8Eudp/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/tcp%E4%B8%8Eudp/</id>
    <published>2020-05-25T13:16:29.000Z</published>
    <updated>2020-05-25T13:17:38.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h1><p><img src="https://img-blog.csdn.net/20140609125220296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><a id="more"></a><ul><li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li><li>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li><li>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li><li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li><li>保留，占6位，保留今后使用，但目前应都位0；</li><li>标志位 SYN ACK PSH FIN RST URG(</li><li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；<br>检验和，占2字节，校验首部和数据这两部分；<br>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；<br>选项，长度可变，定义一些其他的可选的参数。</li></ul><p><a href="https://www.jianshu.com/p/e0b8a66cf875" target="_blank" rel="noopener">来源</a></p><ol><li>TCP的6种标志位和2种序号</li><li>SYN(synchronous) :建立连接，请求同步标志，为1的时候为有效</li><li>ACK(acknowledgement 确认) :应答标志，表示接受到所发的数据，1为有效</li><li>PSH(push传送) ：接收方应该尽快把这个报文交给应用层</li><li>FIN(finish结束) :释放一个连接</li><li>RST(reset) ：重置连接</li><li>URG(urgent紧急)：紧急指针有效</li></ol><p>顺序序号（sequence number）：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>确认序号（acknowledge number）：ack序号，占32位，只有标志位ACK为1时，确认序号字段才有效，Ack=Seq+1。</p><h1 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h1><ul><li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p></li><li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p></li><li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p> 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ul><h1 id="为什么连接时不能两次握手或者时四次握手"><a href="#为什么连接时不能两次握手或者时四次握手" class="headerlink" title="为什么连接时不能两次握手或者时四次握手"></a>为什么连接时不能两次握手或者时四次握手</h1><h2 id="为什么要进行三次握手"><a href="#为什么要进行三次握手" class="headerlink" title="为什么要进行三次握手"></a>为什么要进行三次握手</h2><p><strong>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</strong></p><p>第一次握手：客户端发送网络包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。</p><p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><h2 id="如果是用两次握手，则会出现下面这种情况"><a href="#如果是用两次握手，则会出现下面这种情况" class="headerlink" title="如果是用两次握手，则会出现下面这种情况:"></a>如果是用两次握手，则会出现下面这种情况:</h2><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p><h2 id="假设可以四次握手"><a href="#假设可以四次握手" class="headerlink" title="假设可以四次握手:"></a>假设可以四次握手:</h2><ol><li><p>A 发送同步信号SYN + A的初始化序列号</p></li><li><p>B 确认收到A的同步信号并且记录A的初始化序列号 (ack报文)</p></li><li>B 发送同步信号SYN + B的初始化序列号 (seq报文)</li><li>A 确认收到B的同步信号并且记录B的初始化序列号</li></ol><p>由以上可得2.3步骤可以合并，只需要三次握手，可以提高连接的速度与效率</p><h1 id="如果中途有包丢失"><a href="#如果中途有包丢失" class="headerlink" title="如果中途有包丢失"></a>如果中途有包丢失</h1><ul><li><p>第一个包，即A发给B的SYN 中途被丢，没有到达B</p><p>A会周期性超时重传，直到收到B的确认</p></li><li><p>第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A</p><p>B会周期性超时重传，直到收到A的确认</p></li><li><p>第三个包，即A发给B的ACK 中途被丢，没有到达B</p><p>A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：</p></li></ul><ol><li><p>假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。</p></li><li><p>假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。</p></li><li><p>假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</p></li></ol><p><a href="https://www.zhihu.com/question/24853633/answer/115173386" target="_blank" rel="noopener">来源</a></p><h1 id="三次握手过程中可以携带数据吗"><a href="#三次握手过程中可以携带数据吗" class="headerlink" title="三次握手过程中可以携带数据吗"></a>三次握手过程中可以携带数据吗</h1><p>其实<strong>第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</strong></p><p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h1 id="ISN-Initial-Sequence-Number-是固定的吗"><a href="#ISN-Initial-Sequence-Number-是固定的吗" class="headerlink" title="ISN(Initial Sequence Number)是固定的吗"></a>ISN(Initial Sequence Number)是固定的吗</h1><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p><p>三次握手的其中一个重要功能是<strong>客户端和服务端交换 ISN(Initial Sequence Number),以便让对方知道接下来接收数据的时候如何按序列号组装数据</strong>.如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><h1 id="什么是半连接队列"><a href="#什么是半连接队列" class="headerlink" title="什么是半连接队列"></a>什么是半连接队列</h1><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p><p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于SYN-ACK 重传次数的问题：</p><p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h1 id="SYN攻击是什么"><a href="#SYN攻击是什么" class="headerlink" title="SYN攻击是什么"></a>SYN攻击是什么</h1><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。<strong>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪</strong>。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h1 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h1><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p><p> 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p></li><li><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p><p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），<strong>服务端进入CLOSE_WAIT（关闭等待）状态</strong>，此时的TCP处于半关闭状态，客户端到服务端的连接释放。<strong>客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态</strong>，等待服务端发出的连接释放报文段。</p></li><li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><p> 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p></li></ul><h1 id="为什么连接的时候是三次握手，关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手</h1><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h1 id="服务器出现大量的CLOSE-WAIT"><a href="#服务器出现大量的CLOSE-WAIT" class="headerlink" title="服务器出现大量的CLOSE_WAIT"></a>服务器出现大量的CLOSE_WAIT</h1><p><strong>close wait绝大多数情况下是因为是客户端异常断了，服务端处理逻辑又不够好。服务器没有及时close()的缘故(比如捕捉的异常里面没有调close())</strong><br>解决方法:</p><ol><li><p>检查代码，释放资源的代码；</p></li><li><p>检查配置，处理请求的线程配置；</p></li><li><p>通过检查CLOSE_WAIT数目：<br>netstat  -n | awk ‘/ tcp/{++S[$NF]}END{for(a in S ) print a,S[a]}’</p></li></ol><h1 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态</h1><ol><li><p>确定有足够时间让对方收到ack包。为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。</p></li><li><p>避免新旧连接混淆。就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</p></li></ol><h1 id="TIME-WAIT过多"><a href="#TIME-WAIT过多" class="headerlink" title="TIME_WAIT过多"></a>TIME_WAIT过多</h1><p><strong>出现大量tcp连接关闭</strong></p><p>打开 sysctl.conf 文件，修改以下几个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line">net.ipv4.tcp_timestamps &#x3D; 1</span><br></pre></td></tr></table></figure><br><a href="https://zhuanlan.zhihu.com/p/40013724" target="_blank" rel="noopener">TIME_WAIT修改的原因</a></p><h1 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h1><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><a href="https://zhuanlan.zhihu.com/p/86426969" target="_blank" rel="noopener">三次握手与四次挥手</a></p><h1 id="TCP如何保证传输可靠性"><a href="#TCP如何保证传输可靠性" class="headerlink" title="TCP如何保证传输可靠性"></a>TCP如何保证传输可靠性</h1><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。<strong>并且前面的进位不能丢弃，补在后面，最后取反</strong>，得到校验和。<br>发送方:在发送数据之前计算检验和，并进行校验和的填充。<br>接收方:收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p><p>a数据段 1100 1010 0111 0111<br>b数据段 1001 1000 1010 1110<br>相加   1 0110 0011 0001 1111<br>      将多余的进位1加在后面<br>得到   0110 0011 0010 0000<br>       取反<br>校验和  1001 1100 1101 1111 </p><p>注意:如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是<strong>如果接收方比对校验和与发送方一致，数据不一定传输成功。</strong></p><h2 id="确认应答与序列号"><a href="#确认应答与序列号" class="headerlink" title="确认应答与序列号"></a>确认应答与序列号</h2><p>序列号:     TCP传输时<strong>将每个字节的数据都进行了编号</strong>，这就是序列号。<br>确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。<strong>这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发</strong>。</p><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。<strong>如果发送方发送完数据后，迟迟没有等到接收方的ACK报文</strong>，可能的原因有:</p><ol><li>数据在传输过程中由于网络原因等直接全体丢包，接收方没有接收到。</li><li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。<br>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制</strong>简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。<strong>如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答</strong>。</li></ol><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>三次握手和四次挥手</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传之类。<strong>而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制</strong>。<br>流量控制由<strong>滑动窗口协议</strong>（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。<strong>主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送</strong>。</p><h3 id="流量控制引发的死锁？怎么避免死锁的发生？"><a href="#流量控制引发的死锁？怎么避免死锁的发生？" class="headerlink" title="流量控制引发的死锁？怎么避免死锁的发生？"></a>流量控制引发的死锁？怎么避免死锁的发生？</h3><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。<br>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>TCP传输的过程中，发送端开始发送数据的时候，<strong>如果刚开始就发送大量的数据，那么就可能造成一些问题</strong>。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><p><strong>拥塞控制主要是四个算法：1）慢开始，2）拥塞避免，3）拥塞发生，4）快速恢复</strong></p><h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。<br>比如一开始为1 第二次就为2 第三次4… 达到ssthresh门限.<br>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：</p><ol><li>当cwnd&lt;ssthresh时，使用<strong>慢开始算法</strong>。</li><li>当cwnd&gt;ssthresh时，改用<strong>拥塞避免算法</strong>。</li><li>当cwnd=ssthresh时，<strong>慢开始与拥塞避免算法任意</strong></li></ol><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1.</p><p><strong>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法</strong></p><h3 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h3><p>快重传要求<strong>接收方在收到一个失序的报文段后就立即发出重复确认</strong>，快重传算法规定，发送方<strong>只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</strong>，而不必继续等待设置的重传计时器时间到期</p><h3 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h3><p>当发送方连续收到三个重复确认时，<strong>把ssthresh门限减半，cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大</strong>。不使用慢开始是因为考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。</p><p><a href="https://zhuanlan.zhihu.com/p/37379780" target="_blank" rel="noopener">来源</a><br><a href="https://blog.csdn.net/cbjcry/article/details/84925028" target="_blank" rel="noopener">来源</a></p><h1 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h1><p>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</p><p>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</p><h1 id="tcp和udp区别"><a href="#tcp和udp区别" class="headerlink" title="tcp和udp区别"></a>tcp和udp区别</h1><ol><li>TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>TCP首部开销20字节，UDP的首部开销小，只有8个字节。</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</li></ol><h1 id="一台主机上最多保持多少个连接"><a href="#一台主机上最多保持多少个连接" class="headerlink" title="一台主机上最多保持多少个连接"></a>一台主机上最多保持多少个连接</h1><ul><li><strong>内核通过四元组（源IP，源PORT，目标IP，目标PORT）来识别TCP连接</strong>，在一台主机上，只要这个四元组不重复，限制连接个数的就是系统配置（各种最大xx数）及系统资源（主要是内存）</li><li>客户端每次发起一个TCP连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他TCP连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个TCP连接。根据TCP/IP协议,<strong>端口port使用16位无符号整数unsigned short来存储,因此本地端口一共有2^16=65536</strong>个,即0-65535,其中0~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如root)才可以使用,因此就算使用root权限,一台机器最多能使用的端口也只有65535个<br>-（这个结论有问题占用的应该是服务端的文件描述符）<br><a href="https://www.jianshu.com/p/c77e7026531a" target="_blank" rel="noopener">可以linux中实验一下</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP报文格式&quot;&gt;&lt;a href=&quot;#TCP报文格式&quot; class=&quot;headerlink&quot; title=&quot;TCP报文格式&quot;&gt;&lt;/a&gt;TCP报文格式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20140609125220296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="tcp&amp;udp" scheme="https://sqwyyy.github.io/tags/tcp-udp/"/>
    
  </entry>
  
  <entry>
    <title>http与https</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/http%E4%B8%8Ehttps/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/http%E4%B8%8Ehttps/</id>
    <published>2020-05-25T13:15:16.000Z</published>
    <updated>2020-05-25T13:16:05.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>HTTP 是<strong>超文本传输协议</strong>，也就是HyperText Transfer Protocol。<br><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</strong></p><a id="more"></a><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li>http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接。</li><li>无状态：无状态是指协议对于事务处理没有记忆，不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。。</li></ol><h1 id="http的请求构成与响应构成"><a href="#http的请求构成与响应构成" class="headerlink" title="http的请求构成与响应构成"></a>http的请求构成与响应构成</h1><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>客户端发送一个HTTP请求到服务端的格式：</p><ol><li>请求行</li><li>请求头</li><li>请求体</li></ol><p>下面是一个请求的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET&#x2F;sample.jspHTTP&#x2F;1.1</span><br><span class="line">Accept:image&#x2F;gif.image&#x2F;jpeg,*&#x2F;*</span><br><span class="line">Accept-Language:zh-cn</span><br><span class="line">Connection:Keep-Alive</span><br><span class="line">Host:localhost</span><br><span class="line">User-Agent:Mozila&#x2F;4.0(compatible;MSIE5.01;Window NT5.0)</span><br><span class="line">Accept-Encoding:gzip,deflate</span><br><span class="line"></span><br><span class="line">username&#x3D;jinqiao&amp;password&#x3D;1234</span><br></pre></td></tr></table></figure></p><ol><li>以上请求中“GET”代表请求方法，“/sample.jsp”表示URI，“HTTP/1.1代表协议和协议的版本。</li><li>Accept 可接受的内容类型<br>Accept-Language 语言<br>Connection连接状态<br>Host 请求的域名（这里我设置的是请求本地，当然，关于域名，就是所谓的URL）<br>User-Agent 浏览器端浏览器型号和版本<br>Accept-Encoding 可接受的压缩类型 gzip,deflate</li><li>请求头和请求正文之间是一个空行，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：username=jinqiao&amp;password=1234<br><img src="https://pic1.zhimg.com/v2-054ba2c979cd2792840d99a1d0f4dc1c_b.jpg" alt="http请求"></li></ol><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>服务端发送一个HTTP响应到客户端的格式：</p><ol><li>状态行</li><li>响应头</li><li>响应正文</li></ol><p>状态行由<strong>协议版本、数字形式的状态代码、及相应的状态描述</strong>，各元素之间以<strong>空格分隔</strong><br><img src="https://pic2.zhimg.com/v2-e2447b28c4e1fd60d43bfa3976ff1531_b.jpg" alt="http响应报文"></p><h2 id="响应头-请求头可能包含："><a href="#响应头-请求头可能包含：" class="headerlink" title="响应头/请求头可能包含："></a>响应头/请求头可能包含：</h2><p>Location：响应报头域用于重定向接受者到一个新的位置。</p><p>Server：响应报头域包含了服务器用来处理请求的软件信息。它和User-Agent请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户 端软件(浏览器)和操作系统的信息。</p><p>Content-Encoding：实体报头域被使用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容编码，因而要获得Content- Type报头域中所引用的媒体类型，必须采用相应的解码机制。</p><p>Content-Language：实体报头域描述了资源所用的自然语言。Content-Language允许用户遵照自身的首选语言来识别和区分实体。 </p><p>Content-Length：实体报头域用于指明正文的长度，以字节方式存储的十进制数字来表示，也就是一个数字字符占一个字节，用其对应的ASCII码存储传输。<br>这个长度仅仅是表示实体正文的长度，没有包括实体报头的长度。</p><p>Content-Type：实体报头域用语指明发送给接收者的实体正文的媒体类型。</p><p>Last-Modified：实体报头域用于指示资源最后的修改日期及时间。</p><p>Expires：实体报头域给出响应过期的日期和时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line"></span><br><span class="line">Server:Apache Tomcat&#x2F;5.0.12</span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br></pre></td></tr></table></figure><h1 id="HTTP-常见的状态码"><a href="#HTTP-常见的状态码" class="headerlink" title="HTTP 常见的状态码"></a>HTTP 常见的状态码</h1><p>五大类常见http状态码</p><div class="table-container"><table><thead><tr><th></th><th>具体含义</th><th>常见状态码</th></tr></thead><tbody><tr><td>1xx</td><td>提示信息，表示目前是协议处理的中间状态，还需要后续操作；</td><td></td></tr><tr><td>2xx</td><td>成功，报文已经收到并被正确处理</td><td>200 204</td></tr><tr><td>3xx</td><td>重定向,资源位置发生变动，需要客户端重新发送请求</td><td>301 302 304</td></tr><tr><td>4xx</td><td>客服端错误，请求报文有误，服务器无法处理</td><td>400 403 404</td></tr><tr><td>5xx</td><td>服务器错误，服务器在处理请求时内部发生了错误</td><td>500 501 502 503</td></tr></tbody></table></div><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p><ol><li>200 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</li><li>204 请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li></ol><h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p><ol><li><p>302 该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问</p></li><li><p>303 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</p></li></ol><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p><ol><li><p>「400 Bad Request」表示客户端请求的报文有错误。</p></li><li><p>「403 Forbidden」表示请求被拒绝。</p></li><li><p>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li></ol><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p><p>1.「500 Internal Server Error」服务器正在执行请求时发生错误。</p><p>2.「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p><p>3.「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</p><h2 id="常见问题以及解决方法"><a href="#常见问题以及解决方法" class="headerlink" title="常见问题以及解决方法"></a>常见问题以及解决方法</h2><h3 id="404：（Not-Found）服务器无法找到请求的页面或资源。"><a href="#404：（Not-Found）服务器无法找到请求的页面或资源。" class="headerlink" title="404：（Not Found）服务器无法找到请求的页面或资源。"></a>404：（Not Found）服务器无法找到请求的页面或资源。</h3><ol><li>此类报错首先考虑我们的接口写的时候正确。（可以借用postman来测试）</li><li>其次可以检查资源的路径是否出错。</li></ol><h3 id="405：（Method-Not-Allowed-）方法不允许，方法禁用。"><a href="#405：（Method-Not-Allowed-）方法不允许，方法禁用。" class="headerlink" title="405：（Method Not Allowed ）方法不允许，方法禁用。"></a>405：（Method Not Allowed ）方法不允许，方法禁用。</h3><ol><li>一般出现在servlet中比较常见.就是自己的service函数写错了。</li><li>方法名称写错，方法参数类型与标准不一致。</li></ol><h3 id="500-：（Internal-Server-Error）-服务器内部错误，不能完成客户的请求。"><a href="#500-：（Internal-Server-Error）-服务器内部错误，不能完成客户的请求。" class="headerlink" title="500 ：（Internal Server Error） 服务器内部错误，不能完成客户的请求。"></a>500 ：（Internal Server Error） 服务器内部错误，不能完成客户的请求。</h3><ol><li>500报错一般是后端服务器问题，但也不排除前端出错，例如后台报序列化错误，可能是因为前端没有设置content-Type=application/json。</li><li>重要的是要查看自己写的后端业务逻辑代码有没有问题，根据报错提示查找bug。</li><li>常见的错误位置：NullPointException，据库中提取的数据没有提取到而给另一个对象，传递了空值或注入某个对象，过程中出现空值.，没有正确获取到对象的而出现异常。</li></ol><h3 id="501：（-Not-Implemented）尚未实施，或请求格式错误。"><a href="#501：（-Not-Implemented）尚未实施，或请求格式错误。" class="headerlink" title="501：（ Not Implemented）尚未实施，或请求格式错误。"></a>501：（ Not Implemented）尚未实施，或请求格式错误。</h3><ol><li>一般考虑我们前端写的ajax中的type:”post/get”是否出错或者from表单中的method:”post/get”是否书写错误。<h1 id="HTTP的8中请求方式"><a href="#HTTP的8中请求方式" class="headerlink" title="HTTP的8中请求方式"></a>HTTP的8中请求方式</h1></li><li>GET：向服务器请求指定的资源</li><li>POST：向服务器提交数据请求处理，数据被包含在请求体中。</li><li>HEAD : 返回服务器上对指定资源数据的 HTTP 请求头，在不需要返回全部数据的情况。</li><li>OPTIONS : 返回服务器对指定资源数据支持的 HTTP 请求方法，一般用于测试服务器功能的可用性。</li><li>PUT : 向服务器上传指定的数据。</li><li>DELETE : 向服务器发送请求删除指定数据。</li><li>TRACE : 回显服务器收到的请求，主要进行功能测试诊断。</li><li>CONNECT : HTTP1.1 协议中预留请求方式，可以将连接改为管道方式的代理服务器</li></ol><h1 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h1><ol><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ol><h1 id="HTTP-1-0-HTTP-1-1-HTPP-2-HTTP-3"><a href="#HTTP-1-0-HTTP-1-1-HTPP-2-HTTP-3" class="headerlink" title="HTTP/1.0 HTTP/1.1 HTPP/2 HTTP/3"></a>HTTP/1.0 HTTP/1.1 HTPP/2 HTTP/3</h1><h2 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能" class="headerlink" title="HTTP/1.1 相比 HTTP/1.0 提高了什么性能"></a>HTTP/1.1 相比 HTTP/1.0 提高了什么性能</h2><ol><li>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ol><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>早期 HTTP/1.0 性能上的一个很大的问题，<strong>那就是每发起一个请求，都要新建一次 TCP 连接</strong>（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。</p><p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接的通信方式</strong>，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p><strong>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</strong>。</p><h3 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h3><p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p><strong>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</strong></p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p><p>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。<strong>要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」</strong>。</p><h2 id="HTTP-1-1的缺点"><a href="#HTTP-1-1的缺点" class="headerlink" title="HTTP/1.1的缺点"></a>HTTP/1.1的缺点</h2><ol><li><strong>请求 / 响应头部（Header）未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。<strong>每次互相发送相同的首部造成的浪费较多</strong>；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li><li><strong>没有请求优先级控制</strong>；</li><li><strong>请求只能从客户端开始，服务器只能被动响应</strong>。</li></ol><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p><strong>HTTP/2 协议是基于 HTTPS 的</strong>，所以 HTTP/2 的安全性也是有保障的。<br>特点：</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP/2 会<strong>压缩头</strong>（Header)如果你同时发出多个请求，<strong>他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分</strong>。</p><p>这就是所谓的 HPACK 算法：<strong>在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了</strong>。</p><h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3><p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，<strong>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧</strong>。<br>HTTP1.1中的报文是 报文首部 + 空格 + 报文主题<br>HTTP2中的报文是 头信息帧 + 数据帧</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p><p>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</p><p>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</p><p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p><ol><li>同个域名<strong>只需要占用一个 TCP 连接</strong>，使用一个连接并行发送多个请求和响应，消除了因多个 TCP 连接而带来的延时和内存消耗并行交错地发送多个请求，</li><li>请求之间互不影响并行交错地发送多个响应，</li><li>响应之间互不干扰在 HTTP/2 中，</li><li>每个请求都可以带<strong>一个 31 bit 的优先值</strong>，数值越大优先级越低，0 表示最高优先级。有了这个优先值，客户端和服务器就可以在处理不同流时采取不同的策略，以最优的方式发送流、消息和帧。</li></ol><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</p><p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送</p><p><a href="https://zhuanlan.zhihu.com/p/68012355" target="_blank" rel="noopener">HTTP2/HTTP3</a></p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p><strong>HTTP/2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><h1 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p><h2 id="浏览器在使用HTTPS传输数据的流程"><a href="#浏览器在使用HTTPS传输数据的流程" class="headerlink" title="浏览器在使用HTTPS传输数据的流程"></a>浏览器在使用HTTPS传输数据的流程</h2><ol><li>首先TCP三次握手建立连接</li><li>客户端通过URL访问服务器建立SSL连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>服务器利用自己的私钥解密出会话密钥。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ol><h2 id="SSL连接的详细过程"><a href="#SSL连接的详细过程" class="headerlink" title="SSL连接的详细过程"></a>SSL连接的详细过程</h2><h3 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h3><p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。<br>在这一步，客户端主要向服务器发送以下信息：</p><ol><li>客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</li><li>客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。</li><li>客户端支持的密码套件列表，如 RSA 加密算法。</li></ol><h3 id="SeverHello"><a href="#SeverHello" class="headerlink" title="SeverHello"></a>SeverHello</h3><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p><ol><li>确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。</li><li>确认的密码套件列表，如 RSA 加密算法。</li><li>服务器的数字证书。</li></ol><h3 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h3><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p><strong>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文</strong>，向服务器发送如下信息：</p><ol><li>一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ol><p>上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</p><h3 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h3><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：</p><ol><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li></ol><p>至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><p><a href="https://www.nowcoder.com/discuss/379081?type=5" target="_blank" rel="noopener">牛客网http图解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;HTTP 是&lt;strong&gt;超文本传输协议&lt;/strong&gt;，也就是HyperText Transfer Protocol。&lt;br&gt;&lt;strong&gt;HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http&amp;https" scheme="https://sqwyyy.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>sql语句练习</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</id>
    <published>2020-05-25T13:08:57.000Z</published>
    <updated>2020-05-25T13:13:00.456Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`salaries`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`salary`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`from_date`</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ( </span><br><span class="line">(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> emp_no = <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">to_date</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>) -</span><br><span class="line">(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> emp_no = <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">to_date</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>)</span><br><span class="line">) <span class="keyword">AS</span> growth</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`departments`</span> (</span><br><span class="line"><span class="string">`dept_no`</span> <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`dept_name`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`dept_no`</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`dept_emp`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`dept_no`</span> <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`dept_no`</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`birth_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`last_name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`gender`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`hire_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> departments.dept_name,employees.last_name,employees.first_name</span><br><span class="line"><span class="keyword">from</span> departments <span class="keyword">left</span> <span class="keyword">join</span> dept_emp <span class="keyword">on</span> departments.dept_no = dept_emp.dept_no</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> employees <span class="keyword">on</span> employees.emp_no = dept_emp.emp_no;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">本题思路为运用两次LEFT JOIN连接嵌套</span><br><span class="line">1、第一次LEFT JOIN连接employees表与dept_emp表，</span><br><span class="line">得到所有员工的last_name和first_name以及对应的dept_no，</span><br><span class="line">也包括暂时没有分配部门的员工</span><br><span class="line">2、第二次LEFT JOIN连接上表与departments表，</span><br><span class="line">即连接dept_no与dept_name，得到所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`salaries`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`emp_no`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`salary`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`from_date`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`to_date`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`emp_no`&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;`from_date`&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; ( &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; salary &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; salaries &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; emp_no = &lt;span class=&quot;number&quot;&gt;10001&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to_date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DESC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; salary &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; salaries &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; emp_no = &lt;span class=&quot;number&quot;&gt;10001&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to_date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ASC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;AS&lt;/span&gt; growth&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
      <category term="sql练习" scheme="https://sqwyyy.github.io/tags/sql%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试题</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-05-25T13:07:44.000Z</published>
    <updated>2020-05-25T13:14:01.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主键、外键、超键、候选键"><a href="#主键、外键、超键、候选键" class="headerlink" title="主键、外键、超键、候选键"></a>主键、外键、超键、候选键</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。<br>候选键：是最小超键，即没有冗余元素的超键。<br>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。<br>外键：在一个表中存在的另一个表的主键称此表的外键。</p><a id="more"></a><h2 id="为什么用自增列作为主键"><a href="#为什么用自增列作为主键" class="headerlink" title="为什么用自增列作为主键"></a>为什么用自增列作为主键</h2><p>innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。</p><h2 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h2><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p><h2 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。<br>调用：<br>1）可以用一个命令对象来调用存储过程。<br>2）可以供外部程序调用，比如：java程序。</p><h1 id="什么是临时表，临时表什么时候删除"><a href="#什么是临时表，临时表什么时候删除" class="headerlink" title="什么是临时表，临时表什么时候删除"></a>什么是临时表，临时表什么时候删除</h1><ul><li>什么是临时表: MySQL用于存储一些中间结果集的表，临时表只在当前连接可见。</li><li>临时表什么时候删除: 当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。</li></ul><h2 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h2><p>优点：<br>1）存储过程是预编译过的，执行效率高。<br>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。<br>3）安全性高，执行存储过程需要有一定权限的用户。<br>4）存储过程可以重复使用，可减少数据库开发人员的工作量。<br>缺点：移植性差</p><h2 id="drop、truncate、-delete区别"><a href="#drop、truncate、-delete区别" class="headerlink" title="drop、truncate、 delete区别"></a>drop、truncate、 delete区别</h2><p>最基本：<br>drop直接删掉表。<br>truncate删除表中数据，再插入时自增长id又从1开始。<br>delete删除表中数据，可以加where字句。<br>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。<br>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。<br>（3） 一般而言，drop &gt; truncate &gt; delete<br>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view<br>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。<br>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。<br>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。<br>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。<br>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。<br>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。<br>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p><h2 id="查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序"></a>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序</h2><ul><li>from:需要从哪个数据表检索数据</li><li>where:过滤表中数据的条件</li><li>group by:如何将上面过滤出的数据分组</li><li>having:对上面已经分组的数据进行过滤的条件</li><li>select:查看结果集中的哪个列，或列的计算结果</li><li>order by :按照什么样的顺序来查看返回的数据</li></ul><h2 id="非关系型数据库和关系型数据库区别，优势比较"><a href="#非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="非关系型数据库和关系型数据库区别，优势比较?"></a>非关系型数据库和关系型数据库区别，优势比较?</h2><p>非关系型数据库的优势：</p><ol><li>性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li>可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ol><p>关系型数据库的优势：</p><ol><li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持：使得对于安全性能很高的数据访问要求得以实现。</li></ol><h2 id="SQL语言分类"><a href="#SQL语言分类" class="headerlink" title="SQL语言分类"></a>SQL语言分类</h2><ol><li>数据查询语言DQL(SELECT FROM WHERE子句构成的查询块)</li><li>数据操纵语言DML(INSERT UPDATE DELETE)</li><li>数据定义语言DDL(CREATE TABLE/VIEW/INDEX)</li><li>数据控制语言DCL(GRANT：授权 ROLLBACK回滚 COMMIT提交)</li></ol><h2 id="like-和-的区别"><a href="#like-和-的区别" class="headerlink" title="like %和-的区别"></a>like %和-的区别</h2><p>%百分号通配符:表示任何字符出现任意次数(可以是0次).<br><strong>_下划线通配符:</strong>表示只能匹配单个字符,不能多也不能少,就是一个字符.<br>like操作符: LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><h2 id="MYSQL的存储引擎"><a href="#MYSQL的存储引擎" class="headerlink" title="MYSQL的存储引擎"></a>MYSQL的存储引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别以及如何选择"><a href="#MySQL存储引擎MyISAM与InnoDB区别以及如何选择" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别以及如何选择"></a>MySQL存储引擎MyISAM与InnoDB区别以及如何选择</h3><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </li><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；</li><li>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</li><li>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</li><li>MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。<br>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。<br>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。<br>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。<br>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。</li></ol><h3 id="MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a>MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</h3><p>事务处理上方面<br>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。<br>锁级别<br>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。<br><a href="https://blog.csdn.net/qq_35642036/article/details/82820178" target="_blank" rel="noopener">来源</a></p><h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p><strong>1NF的定义为：符合1NF的关系中的每个属性都不可再分,具有原子性</strong></p><h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p><strong>满足1NF的基础上，要求：表中的所有列，都必需依赖于主键，而不能有任何一列与主键没有关系</strong></p><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p><strong>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</strong></p><p><a href="https://zhuanlan.zhihu.com/p/20028672" target="_blank" rel="noopener">数据库范式</a></p><h1 id="主从复制，分库分表？"><a href="#主从复制，分库分表？" class="headerlink" title="主从复制，分库分表？"></a>主从复制，分库分表？</h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主键、外键、超键、候选键&quot;&gt;&lt;a href=&quot;#主键、外键、超键、候选键&quot; class=&quot;headerlink&quot; title=&quot;主键、外键、超键、候选键&quot;&gt;&lt;/a&gt;主键、外键、超键、候选键&lt;/h2&gt;&lt;p&gt;超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。&lt;br&gt;候选键：是最小超键，即没有冗余元素的超键。&lt;br&gt;主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。&lt;br&gt;外键：在一个表中存在的另一个表的主键称此表的外键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql优化</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E4%BC%98%E5%8C%96/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2020-05-25T13:06:50.000Z</published>
    <updated>2020-05-25T13:12:09.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h1><a id="more"></a><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，<strong>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</strong></p><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，<strong>应该尽量把字段设置为NOTNULL</strong>，这样在将来执行查询的时候，数据库不用去比较NULL值。 对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h1 id="使用连接查询来代替子查询"><a href="#使用连接查询来代替子查询" class="headerlink" title="使用连接查询来代替子查询"></a>使用连接查询来代替子查询</h1><p>例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CustomerID <span class="keyword">FROM</span> salesinfo)</span><br></pre></td></tr></table></figure><br>子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> salesinfo <span class="keyword">ON</span> customerinfo.CustomerID=salesinfo.CustomerID</span><br><span class="line"><span class="keyword">WHERE</span> salesinfo.CustomerID <span class="keyword">ISNULL</span></span><br></pre></td></tr></table></figure><p>连接查询</p><p>内连接：只显示两表id匹配的<br>左外连接：显示join左边的表的所有数据（不管两表是否匹配），对于不匹配的部分都用NULL显示<br>右外连接：与左外连接相反，显示join右边的表的所有数据<br><a href="https://blog.csdn.net/doubleguy/article/details/89708227" target="_blank" rel="noopener">来源</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--内连接（只显示两表id匹配的）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">inner</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--左外连接（显示join左边的表的所有数据，exam只有两条记录，所以stu.id,grade都用NULL显示）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">left</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--右外连接（与左外连接相反，显示join右边的表的所有数据）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">right</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br></pre></td></tr></table></figure></p><h2 id="子查询比连接查询慢的原因是"><a href="#子查询比连接查询慢的原因是" class="headerlink" title="子查询比连接查询慢的原因是"></a>子查询比连接查询慢的原因是</h2><p><strong>执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，<strong>就是可以保持数据库中数据的一致性和完整性</strong>。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><ol><li><p>原子性。事务是数据库的逻辑工作单位，<strong>事务中包含的各操作要么都做，要么都不做</strong></p></li><li><p>一致性。<strong>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</strong>。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p></li><li><p>隔离性。<strong>在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰</strong>。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p>持续性。也称永久性，<strong>指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的</strong>。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><h2 id="事务并发可能出现的问题"><a href="#事务并发可能出现的问题" class="headerlink" title="事务并发可能出现的问题"></a>事务并发可能出现的问题</h2></li><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：在一个事务的两次查询之中数据不一致，事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li><li>幻读：例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ol><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommitted（读取未提交内容）-RU"><a href="#Read-Uncommitted（读取未提交内容）-RU" class="headerlink" title="Read Uncommitted（读取未提交内容） RU"></a>Read Uncommitted（读取未提交内容） RU</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><h3 id="Read-Committed（读取提交内容）RC"><a href="#Read-Committed（读取提交内容）RC" class="headerlink" title="Read Committed（读取提交内容）RC"></a>Read Committed（读取提交内容）RC</h3><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><h3 id="Repeatable-Read（可重读）RR"><a href="#Repeatable-Read（可重读）RR" class="headerlink" title="Repeatable Read（可重读）RR"></a>Repeatable Read（可重读）RR</h3><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p><h2 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h2><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><div class="table-container"><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>x</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>x</td><td>x</td><td>√</td></tr><tr><td>Serializable</td><td>x</td><td>x</td><td>x</td></tr></tbody></table></div><h1 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mvcc是多版本并发控制 ，它是数据库管理系统一种常见的并发控制。</p><ul><li>事务版本号:每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</li><li><p>表格的隐藏列</p><ul><li>DB_TRX_ID: 记录操作该数据事务的事务ID；</li><li>DB_ROLL_PTR：指向上一个版本数据在undo log 里的位置指针；</li><li>DB_ROW_ID: 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</li><li>undoLog: 事务的回滚日志</li><li><p>Read view: 在innodb 中每个SQL语句执行前都会得到一个read_view</p><ul><li><p>trx_ids: trx_ids为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）</p></li><li><p>low_limit_id: 当前最大的事务号 + 1，事务号 &gt;= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。</p></li><li>up_limit_id: 当前已经提交的事务号 + 1，事务号 &lt; up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。</li></ul></li></ul></li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li><p>获取当前事务版本号</p></li><li><p>获得一个readview</p></li><li>查到数据，与readview的事务版本号进行匹配</li><li>不符合readview的规则，就从undo lo获取历史版本数据</li><li>返回符合规则的数据</li></ol><p>RC(read commit) 级别下<strong>同一个事务里面的每一次查询都会获得一个新的read view副本</strong>。这样就可能造成同一个事务里前后读取数据可能不一致的问题（幻读）</p><p>RR(重复读)级别下的<strong>一个事务里只会获取一次read view副本</strong>，从而保证每次查询的数据都是一样的。</p><h2 id="mvcc并未解决幻读问题"><a href="#mvcc并未解决幻读问题" class="headerlink" title="mvcc并未解决幻读问题"></a>mvcc并未解决幻读问题</h2><p>例如:<br>一开始表中有一条数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|id|name|</span><br><span class="line">|1|开发部|</span><br></pre></td></tr></table></figure><br>| 事务一                        | 事务二                                  |<br>| ——————————————- | ———————————————————- |<br>| begin                         | begin                                   |<br>| select * from dept            | -                                       |<br>| -                             | insert into dept(name) values(“研发部”) |<br>| -                             | commit                                  |<br>| update dept set name=”财务部” | -                                       |<br>| commit                        | -                                       |</p><p>上面的结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id name</span><br><span class="line">1 开发部</span><br><span class="line">9 开发部</span><br></pre></td></tr></table></figure><br>产生了幻读</p><p><strong>解决幻读的方法是添加next-key lock</strong></p><p><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68" target="_blank" rel="noopener">mvcc</a><br><a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">mvcc</a></p><h2 id="数据中的锁"><a href="#数据中的锁" class="headerlink" title="数据中的锁"></a>数据中的锁</h2><h3 id="读的分类"><a href="#读的分类" class="headerlink" title="读的分类"></a>读的分类</h3><ul><li>快照读是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</li><li>当前读是基于 临键锁（行锁 + 间歇锁）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。<br><a href="https://www.cnblogs.com/AlmostWasteTime/p/11466520.html" target="_blank" rel="noopener">快照读与当前读</a><h3 id="按锁的粒度分类"><a href="#按锁的粒度分类" class="headerlink" title="按锁的粒度分类:"></a>按锁的粒度分类:</h3></li></ul><ol><li>行锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。行级锁<strong>分为共享锁和排他锁。</strong></li><li>页锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li><li>表锁:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。<br>表级锁定分为表<strong>共享读锁（共享锁）与表独占写锁（排他锁）</strong></li></ol><p>InnoDB行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！(innodb和myISAM都不支持页锁)</p><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。<br>排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。<br>我们<strong>通过update、delete等语句加上的锁都是行级别的锁</strong>。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。<br>意向共享锁(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br>意向排他锁(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p><h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><ol><li>行锁:该锁是对索引记录进行加锁,innodb中一定存在聚簇索引，所以行锁最终在聚簇索引上.</li><li>间隙锁:是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<strong>Read Committed隔离级别下，隔离级别比Read Committed低的情况下，都不会使用间隙锁</strong></li><li>Next-Key Locks：这个理解为行锁+索引前面的间隙锁。<br>比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10](负无穷)</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><strong>表锁是通过Next-Key Locks来实现的锁表操作。</strong><h2 id="锁的用法"><a href="#锁的用法" class="headerlink" title="锁的用法"></a>锁的用法</h2>SELECT … LOCK IN SHARE MODE 共享行锁<br>SELECT … FOR UPDATE 排他行锁<br>LOCK TABLE … READ 共享读锁<br>LOCK TABLE … WRITE 排他写锁</li></ol><p><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">锁的详解</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><h1 id="优化sql语句"><a href="#优化sql语句" class="headerlink" title="优化sql语句"></a>优化sql语句</h1><ol><li>能用到索引尽量用到索引.对索引的优化实际上就是sql语句的调优</li><li>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段</li><li>尽量使用where,而不要使用having</li><li>尽量使用多表查询,不要使用子查询</li><li>where后的and.or左右执行顺序是从右至左,运算符为and时–尽量把为假的放在右边,运算符为or时–尽量把为真的放在右边</li></ol><h1 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h1><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Phone <span class="keyword">FROM</span> <span class="keyword">client</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,BirthDate <span class="keyword">FROM</span> author <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Supplier <span class="keyword">FROM</span> product</span><br></pre></td></tr></table></figure><br><a href="https://zhuanlan.zhihu.com/p/86871140" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;选取最适用的字段属性&quot;&gt;&lt;a href=&quot;#选取最适用的字段属性&quot; class=&quot;headerlink&quot; title=&quot;选取最适用的字段属性&quot;&gt;&lt;/a&gt;选取最适用的字段属性&lt;/h1&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2020-05-25T13:05:57.000Z</published>
    <updated>2020-05-25T13:11:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h1><a id="more"></a><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，<strong>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</strong></p><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，<strong>应该尽量把字段设置为NOTNULL</strong>，这样在将来执行查询的时候，数据库不用去比较NULL值。 对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h1 id="使用连接查询来代替子查询"><a href="#使用连接查询来代替子查询" class="headerlink" title="使用连接查询来代替子查询"></a>使用连接查询来代替子查询</h1><p>例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CustomerID <span class="keyword">FROM</span> salesinfo)</span><br></pre></td></tr></table></figure><br>子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> salesinfo <span class="keyword">ON</span> customerinfo.CustomerID=salesinfo.CustomerID</span><br><span class="line"><span class="keyword">WHERE</span> salesinfo.CustomerID <span class="keyword">ISNULL</span></span><br></pre></td></tr></table></figure><p>连接查询</p><p>内连接：只显示两表id匹配的<br>左外连接：显示join左边的表的所有数据（不管两表是否匹配），对于不匹配的部分都用NULL显示<br>右外连接：与左外连接相反，显示join右边的表的所有数据<br><a href="https://blog.csdn.net/doubleguy/article/details/89708227" target="_blank" rel="noopener">来源</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--内连接（只显示两表id匹配的）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">inner</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--左外连接（显示join左边的表的所有数据，exam只有两条记录，所以stu.id,grade都用NULL显示）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">left</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--右外连接（与左外连接相反，显示join右边的表的所有数据）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">right</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br></pre></td></tr></table></figure></p><h2 id="子查询比连接查询慢的原因是"><a href="#子查询比连接查询慢的原因是" class="headerlink" title="子查询比连接查询慢的原因是"></a>子查询比连接查询慢的原因是</h2><p><strong>执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，<strong>就是可以保持数据库中数据的一致性和完整性</strong>。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><ol><li><p>原子性。事务是数据库的逻辑工作单位，<strong>事务中包含的各操作要么都做，要么都不做</strong></p></li><li><p>一致性。<strong>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</strong>。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p></li><li><p>隔离性。<strong>在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰</strong>。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p>持续性。也称永久性，<strong>指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的</strong>。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><h2 id="事务并发可能出现的问题"><a href="#事务并发可能出现的问题" class="headerlink" title="事务并发可能出现的问题"></a>事务并发可能出现的问题</h2></li><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：在一个事务的两次查询之中数据不一致，事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li><li>幻读：例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ol><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommitted（读取未提交内容）-RU"><a href="#Read-Uncommitted（读取未提交内容）-RU" class="headerlink" title="Read Uncommitted（读取未提交内容） RU"></a>Read Uncommitted（读取未提交内容） RU</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><h3 id="Read-Committed（读取提交内容）RC"><a href="#Read-Committed（读取提交内容）RC" class="headerlink" title="Read Committed（读取提交内容）RC"></a>Read Committed（读取提交内容）RC</h3><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><h3 id="Repeatable-Read（可重读）RR"><a href="#Repeatable-Read（可重读）RR" class="headerlink" title="Repeatable Read（可重读）RR"></a>Repeatable Read（可重读）RR</h3><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p><h2 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h2><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><div class="table-container"><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>x</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>x</td><td>x</td><td>√</td></tr><tr><td>Serializable</td><td>x</td><td>x</td><td>x</td></tr></tbody></table></div><h1 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mvcc是多版本并发控制 ，它是数据库管理系统一种常见的并发控制。</p><ul><li>事务版本号:每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</li><li><p>表格的隐藏列</p><ul><li>DB_TRX_ID: 记录操作该数据事务的事务ID；</li><li>DB_ROLL_PTR：指向上一个版本数据在undo log 里的位置指针；</li><li>DB_ROW_ID: 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</li><li>undoLog: 事务的回滚日志</li><li><p>Read view: 在innodb 中每个SQL语句执行前都会得到一个read_view</p><ul><li><p>trx_ids: trx_ids为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）</p></li><li><p>low_limit_id: 当前最大的事务号 + 1，事务号 &gt;= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。</p></li><li>up_limit_id: 当前已经提交的事务号 + 1，事务号 &lt; up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。</li></ul></li></ul></li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li><p>获取当前事务版本号</p></li><li><p>获得一个readview</p></li><li>查到数据，与readview的事务版本号进行匹配</li><li>不符合readview的规则，就从undo lo获取历史版本数据</li><li>返回符合规则的数据</li></ol><p>RC(read commit) 级别下<strong>同一个事务里面的每一次查询都会获得一个新的read view副本</strong>。这样就可能造成同一个事务里前后读取数据可能不一致的问题（幻读）</p><p>RR(重复读)级别下的<strong>一个事务里只会获取一次read view副本</strong>，从而保证每次查询的数据都是一样的。</p><h2 id="mvcc并未解决幻读问题"><a href="#mvcc并未解决幻读问题" class="headerlink" title="mvcc并未解决幻读问题"></a>mvcc并未解决幻读问题</h2><p>例如:<br>一开始表中有一条数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|id|name|</span><br><span class="line">|1|开发部|</span><br></pre></td></tr></table></figure><br>| 事务一                        | 事务二                                  |<br>| ——————————————- | ———————————————————- |<br>| begin                         | begin                                   |<br>| select * from dept            | -                                       |<br>| -                             | insert into dept(name) values(“研发部”) |<br>| -                             | commit                                  |<br>| update dept set name=”财务部” | -                                       |<br>| commit                        | -                                       |</p><p>上面的结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id name</span><br><span class="line">1 开发部</span><br><span class="line">9 开发部</span><br></pre></td></tr></table></figure><br>产生了幻读</p><p><strong>解决幻读的方法是添加next-key lock</strong></p><p><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68" target="_blank" rel="noopener">mvcc</a><br><a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">mvcc</a></p><h2 id="数据中的锁"><a href="#数据中的锁" class="headerlink" title="数据中的锁"></a>数据中的锁</h2><h3 id="读的分类"><a href="#读的分类" class="headerlink" title="读的分类"></a>读的分类</h3><ul><li>快照读是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</li><li>当前读是基于 临键锁（行锁 + 间歇锁）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。<br><a href="https://www.cnblogs.com/AlmostWasteTime/p/11466520.html" target="_blank" rel="noopener">快照读与当前读</a><h3 id="按锁的粒度分类"><a href="#按锁的粒度分类" class="headerlink" title="按锁的粒度分类:"></a>按锁的粒度分类:</h3></li></ul><ol><li>行锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。行级锁<strong>分为共享锁和排他锁。</strong></li><li>页锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li><li>表锁:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。<br>表级锁定分为表<strong>共享读锁（共享锁）与表独占写锁（排他锁）</strong></li></ol><p>InnoDB行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！(innodb和myISAM都不支持页锁)</p><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。<br>排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。<br>我们<strong>通过update、delete等语句加上的锁都是行级别的锁</strong>。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。<br>意向共享锁(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br>意向排他锁(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p><h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><ol><li>行锁:该锁是对索引记录进行加锁,innodb中一定存在聚簇索引，所以行锁最终在聚簇索引上.</li><li>间隙锁:是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<strong>Read Committed隔离级别下，隔离级别比Read Committed低的情况下，都不会使用间隙锁</strong></li><li>Next-Key Locks：这个理解为行锁+索引前面的间隙锁。<br>比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10](负无穷)</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><strong>表锁是通过Next-Key Locks来实现的锁表操作。</strong><h2 id="锁的用法"><a href="#锁的用法" class="headerlink" title="锁的用法"></a>锁的用法</h2>SELECT … LOCK IN SHARE MODE 共享行锁<br>SELECT … FOR UPDATE 排他行锁<br>LOCK TABLE … READ 共享读锁<br>LOCK TABLE … WRITE 排他写锁</li></ol><p><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">锁的详解</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><h1 id="优化sql语句"><a href="#优化sql语句" class="headerlink" title="优化sql语句"></a>优化sql语句</h1><ol><li>能用到索引尽量用到索引.对索引的优化实际上就是sql语句的调优</li><li>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段</li><li>尽量使用where,而不要使用having</li><li>尽量使用多表查询,不要使用子查询</li><li>where后的and.or左右执行顺序是从右至左,运算符为and时–尽量把为假的放在右边,运算符为or时–尽量把为真的放在右边</li></ol><h1 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h1><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Phone <span class="keyword">FROM</span> <span class="keyword">client</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,BirthDate <span class="keyword">FROM</span> author <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Supplier <span class="keyword">FROM</span> product</span><br></pre></td></tr></table></figure><br><a href="https://zhuanlan.zhihu.com/p/86871140" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;选取最适用的字段属性&quot;&gt;&lt;a href=&quot;#选取最适用的字段属性&quot; class=&quot;headerlink&quot; title=&quot;选取最适用的字段属性&quot;&gt;&lt;/a&gt;选取最适用的字段属性&lt;/h1&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
      <category term="索引" scheme="https://sqwyyy.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/ThreadLocal/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/ThreadLocal/</id>
    <published>2020-05-25T13:02:05.000Z</published>
    <updated>2020-05-25T13:10:19.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaBase.LineDistance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉;</span></span><br><span class="line"><span class="comment"> * 〈功能详细描述〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> [相关类/方法]（可选）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> [产品/模块版本] （可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> MyThreadLocal();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程1："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程2："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程3："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">2</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">2</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">2</span>：<span class="number">3</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">3</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><h1 id="Threadlocal原理"><a href="#Threadlocal原理" class="headerlink" title="Threadlocal原理"></a>Threadlocal原理</h1><ol><li>void set(Object value)设置当前线程的线程局部变量的值。</li><li>public Object get()该方法返回当前线程所对应的线程局部变量。</li><li>public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li><li>protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</li></ol><h2 id="set方法的实现"><a href="#set方法的实现" class="headerlink" title="set方法的实现"></a>set方法的实现</h2><p>set方法是设置一个线程的局部变量的值，相当于当前线程通过set设置的局部变量的值，只对当前线程可见。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();<span class="comment">//获取当前执行的线程</span></span><br><span class="line">        ThreadLocalMap map = getMap(t); <span class="comment">//获得当前线程的ThreadLocalMap实例</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)<span class="comment">//如果map不为空，说明当前线程已经有了一个ThreadLocalMap实例</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);<span class="comment">//直接将当前value设置到ThreadLocalMap中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value); <span class="comment">//说明当前线程是第一次使用线程本地变量，构造map</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>map.set(this,value)中key是this，value是我们指定的值，this代表的是那个ThreadLocal类型的变量。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap是一个静态内部类，内部定义了一个Entry对象用来真正存储数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            <span class="comment">//构造一个Entry数组，并设置初始大小</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">//计算Entry数据下标</span></span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将`firstValue`存入到指定的table下标中</span></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;<span class="comment">//设置节点长度为1</span></span><br><span class="line">            setThreshold(INITIAL_CAPACITY); <span class="comment">//设置扩容的阈值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>每个线程自身都维护着一个ThreadLocalMap，用来存储线程本地的数据，可以简单理解成ThreadLocalMap的key是ThreadLocal变量，value是线程本地的数据。就这样很简单的实现了线程本地数据存储和交互访问。</p><h2 id="get方法的实现"><a href="#get方法的实现" class="headerlink" title="get方法的实现"></a>get方法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             T result = (T)e.value;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap中存放的就是Entry，Entry的KEY就是ThreadLocal，VALUE就是值。</p><h2 id="remo"><a href="#remo" class="headerlink" title="remo"></a>remo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();<span class="comment">//调用Entry的clear方法</span></span><br><span class="line">                    expungeStaleEntry(i);<span class="comment">//清除陈旧数据</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000017272578" target="_blank" rel="noopener">来源</a><br><a href="https://www.jianshu.com/p/69ae8c213b30" target="_blank" rel="noopener">来源</a><br><a href="https://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://sqwyyy.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/AQS/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/AQS/</id>
    <published>2020-05-25T12:59:22.000Z</published>
    <updated>2020-05-25T13:10:19.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AQS是一个抽象类，主要是通过继承的方式来使用，这个类在java.util.concurrent.locks包。<strong>一个用来实现同步锁以及其他涉及到同步功能的核心组件</strong>，列入有ReentrantLock、CountDownLatch等</p><a id="more"></a><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>从使用层面来说，AQS的功能分为两种：独占和共享</p><ol><li>独占锁，每次只能有一个线程持有锁，比如前面给大家演示的ReentrantLock就是以独占方式实现的互斥锁</li><li>共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><img src="1" alt="图片.png"></li></ol><h1 id="AQS源码（以ReentrantLock为例"><a href="#AQS源码（以ReentrantLock为例" class="headerlink" title="AQS源码（以ReentrantLock为例)"></a>AQS源码（以ReentrantLock为例)</h1><p>ReentrantLock.lock()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicvoid <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">   sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sync是一个静态内部类,它继承了AQS这个抽象类.Sync这个类有两个具体的实现分别是<strong>NofairSync(非公平锁)</strong>，<strong>FailSync(公平锁)</strong>.</p><ol><li>公平锁 表示所有线程严格按照FIFO来获取锁</li><li>非公平锁 表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁</li></ol><h2 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync.lock"></a>NonfairSync.lock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入acquire方法</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>acquire是AQS中的方法，如果CAS操作未能成功，说明state已经不为0，此时继续acquire(1)操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ol><li>通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false</li><li>如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部</li><li>acquireQueued，将Node作为参数，<strong>通过自旋去尝试获取锁</strong>。</li></ol><h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p>这个方法的作用是尝试获取锁，如果成功返回true，不成功返回false.它是重写AQS类中的tryAcquire方法,AQS中tryAcquire方法的定义，并没有实现，而是抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="nonfairTryAcquire方法"><a href="#nonfairTryAcquire方法" class="headerlink" title="nonfairTryAcquire方法"></a>nonfairTryAcquire方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">//获得state的值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//state=0说明当前是无锁状态</span></span><br><span class="line">        <span class="comment">//通过cas操作来替换state的值改为1，大家想想为什么要用cas呢？</span></span><br><span class="line">        <span class="comment">//理由是，在多线程环境中，直接修改state=1会存在线程安全问题，你猜到了吗？</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//保存当前获得锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这段逻辑就很简单了。如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">//增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="compareAndSetState方法"><a href="#compareAndSetState方法" class="headerlink" title="compareAndSetState方法"></a>compareAndSetState方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> STATE.compareAndSet(<span class="keyword">this</span>, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是通过cas乐观锁的方式来做比较并替换</p><ol><li>当state=0时，表示无锁状态</li><li>当state&gt;0时，表示已经有线程获得了锁，也就是state=1，但是因为ReentrantLock允许重入，所以同一个线程多次获得同步锁的时候，state会递增，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁</li></ol><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>当tryAcquire方法获取锁失败以后，则会先调用addWaiter将当前线程封装成Node，然后添加到AQS队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">//mode=Node.EXCLUSIVE</span></span><br><span class="line">        <span class="comment">//将当前线程封装成Node，并且mode为独占锁</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); </span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(node)方法</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//tail不为空的情况，说明队列中存在节点数据</span></span><br><span class="line">            node.prev = pred;  <span class="comment">//讲当前线程的Node的prev节点指向tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//通过cas讲node添加到AQS队列</span></span><br><span class="line">                pred.next = node;<span class="comment">//cas成功，把旧的tail的next指针指向新的tail</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">//tail=null，将node添加到同步队列中</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h3><p>enq就是通过自旋操作把当前节点加入队列中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail; <span class="comment">//如果是第一次添加到队列，那么tail=null</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//CAS的方式创建一个空的Node作为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   <span class="comment">//此时队列中只一个头结点，所以tail也指向它</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//进行第二次循环时，tail不为null，进入else区域。将当前线程的Node结点的prev指向tail，然后使用CAS将tail指向Node</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"><span class="comment">//t此时指向tail,所以可以CAS成功，将tail重新指向Node。此时t为更新前的tail的值，即指向空的头结点，t.next=node，就将头结点的后续结点指向Node，返回头结点</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>假如有两个线程t1,t2同时进入enq方法，t==null表示队列是首次使用，需要先初始化<br>另外一个线程cas失败，则进入下次循环，通过cas操作将node添加到队尾</p><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p>将添加到队列中的Node作为参数传入acquireQueued方法，这里面会做抢占锁的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 获取prev节点,若为null即刻抛出NullPointException</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 如果前驱为head才有资格进行锁的抢夺</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点</span></span><br><span class="line"><span class="comment">//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">//获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">// 若前面为true,则执行挂起,待下次唤醒的时候检测中断的标志</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果抛出异常则取消锁的获取,进行出队(sync queue)操作</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>获取当前节点的prev节点</li><li>如果prev节点为head节点，那么它就有资格去争抢锁，调用tryAcquire抢占锁</li><li>抢占锁成功以后，把获得锁的节点设置为head，并且移除原来的初始化head节点</li><li>如果获得锁失败，则根据waitStatus决定是否需要挂起线程</li><li>最后，通过cancelAcquire取消获得锁的操作</li></ol><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p>从上面的分析可以看出，只有队列的第二个节点可以有机会争用锁，如果成功获取锁，则此节点晋升为头节点。对于第三个及以后的节点，if (p == head)条件不成立，首先进行shouldParkAfterFailedAcquire(p, node)操作<br>shouldParkAfterFailedAcquire方法是判断一个争用锁的线程是否应该被阻塞。它首先判断一个节点的前置节点的状态是否为Node.SIGNAL，如果是，是说明此节点已经将状态设置-如果锁释放，则应当通知它，所以它可以安全的阻塞了，返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">//前继节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//如果是SIGNAL状态，意味着当前线程需要被unpark唤醒</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">如果前节点的状态大于<span class="number">0</span>，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回<span class="keyword">false</span>。在下次循环执行shouldParkAfterFailedAcquire时，返回<span class="keyword">true</span>。这个操作实际是把队列中CANCELLED的节点剔除掉。</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点'的前继节点”。</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release方法里面做两件事，1，释放锁 ；2，唤醒park的线程</p><h2 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个动作可以认为就是一个设置锁状态的操作，而且是将状态减掉传入的参数值（参数是1），如果结果状态为0，就将排它锁的Owner设置为null，以使得其它的线程有机会进行执行。<br>在排它锁中，加锁的时候状态会增加1（当然可以自己修改这个值），在解锁的时候减掉1，同一个锁，在可以重入后，可能会被叠加为2、3、4这些值，只有unlock()的次数与lock()的次数对应才会将Owner线程设置为空，而且也只有这种情况下才会返回true。</p><h2 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//判断后继节点是否为空或者是否是取消状态,</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点, 至于为什么从尾部开始向前遍历，因为在doAcquireInterruptibly.cancelAcquire方法的处理过程中只设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法unparkSuccessor(Node)中，就意味着真正要释放锁了，它传入的是head节点（head节点是占用锁的节点），当前线程被释放之后，需要唤醒下一个节点的线程</p><p><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;AQS是一个抽象类，主要是通过继承的方式来使用，这个类在java.util.concurrent.locks包。&lt;strong&gt;一个用来实现同步锁以及其他涉及到同步功能的核心组件&lt;/strong&gt;，列入有ReentrantLock、CountDownLatch等&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-05-25T12:57:16.000Z</published>
    <updated>2020-05-25T13:10:20.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用线程池的原因"><a href="#使用线程池的原因" class="headerlink" title="使用线程池的原因"></a>使用线程池的原因</h2><ol><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li><li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换<br><a href="https://www.jianshu.com/p/7726c70cdc40" target="_blank" rel="noopener">来源</a></li></ol><a id="more"></a><h2 id="线程池的主要参数"><a href="#线程池的主要参数" class="headerlink" title="线程池的主要参数"></a>线程池的主要参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> maximumPoolSize, // 线程数的上限</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">long</span> keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，</span></span></span><br><span class="line"><span class="function"><span class="params">                                     // 超过这个时间，多余的线程会被回收。</span></span></span><br><span class="line"><span class="function"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列</span></span></span><br><span class="line"><span class="function"><span class="params">  ThreadFactory threadFactory, // 新线程的产生方式</span></span></span><br><span class="line"><span class="function"><span class="params">  RejectedExecutionHandler handler)</span> <span class="comment">//拒绝策略</span></span></span><br></pre></td></tr></table></figure><ol><li>corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</li><li>maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</li><li>keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li><li>unit：存活时间单位（小时，分，秒等等）</li><li>workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</li><li>threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</li><li>handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。<h2 id="线程池流程"><a href="#线程池流程" class="headerlink" title="线程池流程"></a>线程池流程</h2></li><li>当提交一个新任务到线程池时首先线程池判断基本线程池(corePoolSize)是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程；</li><li>其次线程池判断工作队列(workQueue)是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程；</li><li>最后线程池判断整个线程池(maximumPoolSize)是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务；</li><li>如果线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；</li><li>如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过 keepAliveTime，线程也会被终止。</li></ol><h2 id="线程池为什么使用阻塞队列而不适用非阻塞队列"><a href="#线程池为什么使用阻塞队列而不适用非阻塞队列" class="headerlink" title="线程池为什么使用阻塞队列而不适用非阻塞队列"></a>线程池为什么使用阻塞队列而不适用非阻塞队列</h2><ol><li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。</li><li><p>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。使得在线程不至于一直占用cpu资源。</p><h2 id="java中提供的线程池"><a href="#java中提供的线程池" class="headerlink" title="java中提供的线程池"></a>java中提供的线程池</h2><p>Executors类提供了4种不同的线程池：newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool, newSingleThreadExecutor</p></li><li><p>newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>newScheduledThreadPool：适用于执行延时或者周期性任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2></li><li>RUNNING：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</li><li>SHUTDOWN： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>STOP ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>TIDYING ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；</li><li>TERMINATED： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2>RejectedExecutionHandler是一个接口：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当要创建的线程数量大于线程池的最大线程数的时候，新的任务就会被拒绝，就会调用这个接口里的这个方法。<br>可以自己实现这个接口，实现对这些超出数量的任务的处理。<br>ThreadPoolExecutor自己已经提供了四个拒绝策略，分别是<strong>CallerRunsPolicy,AbortPolicy,DiscardPolicy,DiscardOldestPolicy</strong><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3>ThreadPoolExecutor中默认的拒绝策略就是AbortPolicy。直接抛出异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mythread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程:"</span>+Thread.currentThread().getName() +<span class="string">" 执行:"</span>+name +<span class="string">"  run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">handerdom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,</span><br><span class="line">                TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"添加第"</span>+i+<span class="string">"个任务"</span>);</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Mythread(<span class="string">"线程"</span>+i));</span><br><span class="line">            Iterator iterator = executor.getQueue().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                Mythread thread = (Mythread) iterator.next();</span><br><span class="line">                System.out.println(<span class="string">"列表："</span>+thread.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task threadpoolexecutor.Mythread@7106e68e rejected from java.util.concurrent.ThreadPoolExecutor@7eda2dbb[Running, pool size &#x3D; 2, active threads &#x3D; 2, queued tasks &#x3D; 2, completed tasks &#x3D; 0]</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)</span><br><span class="line">at threadpoolexecutor.handerdom.main(handerdom.java:34)</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br></pre></td></tr></table></figure></li><li>添加第一个任务时，直接执行，任务列表为空。</li><li>添加第二个任务时，因为采用的LinkedBlockingDeque，，并且核心线程正在执行任务，所以会将第二个任务放在队列中，队列中有 线程1.</li><li>添加第三个任务时，也一样会放在队列中，队列中有 线程1，线程2.</li><li>添加第四个任务时，因为核心任务还在运行，而且任务队列已经满了，所以胡直接创建新线程执行第四个任务，。这时线程池中一共就有两个线程在运行了，达到了最大线程数。任务队列中还是有线程1， 线程2.</li><li>添加第五个任务时，再也没有地方能存放和执行这个任务了，就会被线程池拒绝添加，执行拒绝策略的rejectedExecution方法，这里就是执行AbortPolicy的rejectedExecution方法直接抛出异常。<br>最终，只有四个线程能完成运行。后面的都被拒绝了。<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3>CallerRunsPolicy在任务被拒绝添加后，<strong>会调用当前线程池的所在的线程去执行被拒绝的任务。</strong><br>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">线程:main 执行:线程4  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程2</span><br><span class="line">列表：线程5</span><br><span class="line">线程:pool-1-thread-1 执行:线程1  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程2  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程5  run</span><br></pre></td></tr></table></figure>这个策略的缺点就是可能会阻塞主线程。<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3>采用这个拒绝策略，会让被线程池拒绝的任务直接抛弃，不会抛异常也不会执行。<br>运行结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程2  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程1  run</span><br></pre></td></tr></table></figure><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3>当任务被拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的弹出，再把这个新任务添加进去。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">列表：线程2</span><br><span class="line">列表：线程4</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程4</span><br><span class="line">列表：线程5</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程5  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程4  run</span><br></pre></td></tr></table></figure></li><li>在添加第五个任务时，会被线程池拒绝。这时任务队列中有 任务2，任务3</li><li>这时，拒绝策略会让任务队列中最先加入的任务弹出，也就是任务2.</li><li>然后把被拒绝的任务5添加人任务队列，这时任务队列中就成了 任务3，任务5.</li><li>添加第六个任务时会因为同样的过程，将队列中的任务3抛弃，把任务6加进去，任务队列中就成了 任务5，任务6</li><li>因此，最终能被执行的任务只有1，4，5，6. 任务2和任务3倍抛弃了，不会执行。</li></ol><h3 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h3><p>实现一个让被拒绝的任务在一个新的线程中执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"新线程"</span>+<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">new</span> MyRejectedExecutionHandler());</span><br></pre></td></tr></table></figure><br><a href="https://blog.csdn.net/qq_25806863/article/details/71172823" target="_blank" rel="noopener">来源</a></p><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p><a href="https://www.cnblogs.com/pejsidney/p/9001875.html" target="_blank" rel="noopener">来源</a></p><h2 id="如何实现一个简单的线程池"><a href="#如何实现一个简单的线程池" class="headerlink" title="如何实现一个简单的线程池"></a>如何实现一个简单的线程池</h2><p><a href="https://www.jianshu.com/p/9b7dfb407f72" target="_blank" rel="noopener">来源</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义简单线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">/**存放线程的集合*/</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;MyThead&gt; threads;</span><br><span class="line">    <span class="comment">/**任务队列*/</span></span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">/**线程池初始限定大小*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line">    <span class="comment">/**已经工作的线程数目*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workThreadNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span><span class="params">(<span class="keyword">int</span> initPoolNum)</span> </span>&#123;</span><br><span class="line">        threadNum = initPoolNum;</span><br><span class="line">        threads = <span class="keyword">new</span> ArrayList&lt;&gt;(initPoolNum);</span><br><span class="line">        <span class="comment">//任务队列初始化为线程池线程数的四倍</span></span><br><span class="line">        taskQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(initPoolNum*<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        threadNum = initPoolNum;</span><br><span class="line">        workThreadNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="comment">//线程池未满，每加入一个任务则开启一个线程</span></span><br><span class="line">            <span class="keyword">if</span>(workThreadNum &lt; threadNum) &#123;</span><br><span class="line">                MyThead myThead = <span class="keyword">new</span> MyThead(runnable);</span><br><span class="line">                myThead.start();</span><br><span class="line">                threads.add(myThead);</span><br><span class="line">                workThreadNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程池已满，放入任务队列，等待有空闲线程时执行</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//队列已满，无法添加时，拒绝任务</span></span><br><span class="line">                <span class="keyword">if</span>(!taskQueue.offer(runnable)) &#123;</span><br><span class="line">                    rejectTask();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rejectTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"任务队列已满，无法继续添加，请扩大您的初始化线程池！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadPool myThreadPool = <span class="keyword">new</span> MyThreadPool(<span class="number">5</span>);</span><br><span class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"执行中"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            myThreadPool.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThead</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThead</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = runnable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//该线程一直启动着，不断从任务队列取出任务执行</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//如果初始化任务不为空，则执行初始化任务</span></span><br><span class="line">                <span class="keyword">if</span>(task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则去任务队列取任务并执行</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Runnable queueTask = taskQueue.poll();</span><br><span class="line">                    <span class="keyword">if</span>(queueTask != <span class="keyword">null</span>)</span><br><span class="line">                        queueTask.run();    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>过程:</p><ol><li>初始化线程池，指定线程池的大小。</li><li>向线程池中放入任务执行。</li><li>如果线程池中创建的线程数目未到指定大小，则创建我们自定义的线程类放入线程池集合，并执行任务。执行完了后该线程会一直监听队列</li><li>如果线程池中创建的线程数目已满，则将任务放入缓冲任务队列</li><li>线程池中所有创建的线程，都会一直从缓存任务队列中取任务，取到任务马上执行<h3 id="ThreadPoolExecutor源码分析"><a href="#ThreadPoolExecutor源码分析" class="headerlink" title="ThreadPoolExecutor源码分析"></a>ThreadPoolExecutor源码分析</h3><a href="https://www.jianshu.com/p/9b7dfb407f72" target="_blank" rel="noopener">来源</a></li></ol><h3 id="线程池与异步任务"><a href="#线程池与异步任务" class="headerlink" title="线程池与异步任务"></a>线程池与异步任务</h3><p><a href="https://www.cnblogs.com/wyq1995/p/10076949.html" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用线程池的原因&quot;&gt;&lt;a href=&quot;#使用线程池的原因&quot; class=&quot;headerlink&quot; title=&quot;使用线程池的原因&quot;&gt;&lt;/a&gt;使用线程池的原因&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗&lt;/li&gt;
&lt;li&gt;提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；&lt;/li&gt;
&lt;li&gt;方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/7726c70cdc40&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA线程池" scheme="https://sqwyyy.github.io/tags/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>CAS机制</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/CAS%E6%9C%BA%E5%88%B6/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/CAS%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-25T12:55:01.000Z</published>
    <updated>2020-05-25T13:10:19.956Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">来源</a><br><a href="https://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="noopener">来源</a><br>什么是CAS呢？Compare-and-Swap，即比较并替换，也有叫做Compare-and-Set的，比较并设置。</p><p>1、比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。</p><p>2、设置：如果是，将A更新为B，结束。[1]如果不是，则什么都不做。</p><a id="more"></a><p>上面的两步操作是原子性的，可以简单地理解为瞬间完成，在CPU看来就是一步操作。</p><p>下面以AtomicInteger的实现为例，分析一下CAS是如何实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>Unsafe，是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。</li><li>变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</li><li>变量value用volatile修饰，保证了多线程之间的内存可见性。</li></ol><p>AtomicInteger在并发下如何进行累加:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A和线程B同时执行getAndAdd操作（分别跑在不同CPU上）：</p><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为3。</li><li>线程A通过getIntVolatile(var1, var2)拿到value值3，这时线程A被挂起。</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值3，运气好，线程B没有被挂起，并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为2。</li><li>这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值(3)和内存的值(2)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li><li>重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。<br>整个过程中，利用CAS保证了对于value的修改的并发安全，</li></ol><p>getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。<br><strong>compareAndSwapInt，是一个本地方法</strong></p><p><strong>getAndIncrement 方法是返回旧值（即加1前的原始值）</strong><br><strong>incrementAndGet 返回的是新值（即加1后的值）</strong></p><hr><p>AtomicIntegerArray<br><strong>可以保证数组中的元素具有可见性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取int[]在内存中的初始地址。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     <span class="comment">//用来存储移位个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化变量。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">        <span class="comment">//得出scale为2的几次方，即需要移位个数</span></span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查第i个元素的地址值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前索引i*shift(偏移位置) + base(基础位置)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//获取第i个元素的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过地址值来获取偏移量的元素值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用cas方式，在元素i的位置设置新值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><strong>AtomicIntegerArray中的数组申明为final类型，set和get方法都是调用unsafe类里面具有volatile语义的方法来保证可见性</strong><br><a href="https://www.cnblogs.com/zyy1688/p/10654943.html" target="_blank" rel="noopener">AtomicIntegerArray</a></p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><ol><li>CAS存在ABA问题：比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。<br>AtomicStampedReference来解决ABA问题:<strong>这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</strong>（相当于给其加上一个版本号，每次进行操作版本号+1，进行比较时，比较版本号和值是否相等)</li><li>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71156910&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/fb6e91b013cc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;br&gt;什么是CAS呢？Compare-and-Swap，即比较并替换，也有叫做Compare-and-Set的，比较并设置。&lt;/p&gt;
&lt;p&gt;1、比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。&lt;/p&gt;
&lt;p&gt;2、设置：如果是，将A更新为B，结束。[1]如果不是，则什么都不做。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/synchronized/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/synchronized/</id>
    <published>2020-05-25T12:52:17.000Z</published>
    <updated>2020-05-25T13:10:20.022Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">来源</a></p><h2 id="Synchronized的基本使用"><a href="#Synchronized的基本使用" class="headerlink" title="Synchronized的基本使用"></a>Synchronized的基本使用</h2><p>synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。从语法上讲，synchronized总共有三种用法：</p><a id="more"></a><ol><li>修饰普通方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectMethod3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是对象锁的方法修饰方式，我叫 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// while空循环的作用是，让t1,t2线程执行结束后再执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是对象锁的代码块形式，我叫 ： Thread-0</span><br><span class="line">Thread-0运行结束</span><br><span class="line">我是对象锁的代码块形式，我叫 ： Thread-1</span><br><span class="line">Thread-1运行结束</span><br><span class="line">finished</span><br></pre></td></tr></table></figure></li></ol><p>再声明一个实例instance2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectMethod3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance2 = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是对象锁的方法修饰方式，我叫 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// while空循环的作用是，让t1,t2线程执行结束后再执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是对象锁的方法修饰方式，我叫 Thread-0</span><br><span class="line">我是对象锁的方法修饰方式，我叫 Thread-1</span><br><span class="line">Thread-1  运行结束</span><br><span class="line">Thread-0  运行结束</span><br><span class="line">finished</span><br></pre></td></tr></table></figure><br><strong>sychronized没有启动到互斥作用</strong></p><ol><li><p>修饰静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectMethod3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance2 = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是对象锁的方法修饰方式，我叫 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// while空循环的作用是，让t1,t2线程执行结束后再执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是对象锁的方法修饰方式，我叫 Thread-0</span><br><span class="line">Thread-0  运行结束</span><br><span class="line">我是对象锁的方法修饰方式，我叫 Thread-1</span><br><span class="line">Thread-1  运行结束</span><br><span class="line">finished</span><br></pre></td></tr></table></figure><p>sychronized启动了互斥的作用</p></li><li><p>修饰代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassClass5</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedClassClass5 instance1 = <span class="keyword">new</span> SynchronizedClassClass5();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedClassClass5 instance2 = <span class="keyword">new</span> SynchronizedClassClass5();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedClassClass5<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是类锁的第二种形式：synchronized(*.class)代码块形式，我叫 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while空循环的作用是，让t1,t2线程执行结束后再执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上<br>sychronized也启动了互斥的作用</p></li></ol><p>总结:</p><ul><li>对于普通方法:锁的是当前的实例对象</li><li>对于静态同步方法:锁的是当前类的class对象</li><li>对于同步代码块:锁的是synchronized指定的对象</li></ul><h2 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h2><p>对象头中主要包括两部分数据：类型指针和标记字段</p><ul><li>通过类型指针可以知道该对象是哪个类的实例</li><li><strong>标记字段用来存储对象运行时的数据，其中就有锁对象的指针</strong>.<strong>锁对象指针指向了一个monitor对象,每个对象都有一个对应的monitor对象</strong> (标记字段又叫Mark Word)</li></ul><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p><strong>Monitor是线程私有的数据结构</strong>，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p><strong>Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步.</strong></p><p><strong>线程在执行加了Synchronized的代码段的时候要先去获取对象的monitor,执行完毕释放monitor。此过程是互斥的，一次只能有一个线程获取monitor,只有该线程释放monitor以后其它线程才能再获取它</strong>(原理概括）。</p><p><a href="https://www.zhihu.com/question/57794716/answer/807823977" target="_blank" rel="noopener">sychronized</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Method 1 start"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译结果：<br><img src="https://pic4.zhimg.com/v2-da522fd0c4ed856125b7f6d0c154461f_b.jpg" alt="与上面代码可能不对应"><br>monitorenter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</span><br><span class="line">• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</span><br><span class="line">• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</span><br><span class="line">• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor&#39;s entry count is zero, then tries again to gain ownership.</span><br></pre></td></tr></table></figure><br>这段话的大概意思为：<br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：<br>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。<br>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.<br>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p><p>monitorexit：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</span><br><span class="line">The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</span><br></pre></td></tr></table></figure><br>执行monitorexit的线程必须是objectref所对应的monitor的所有者。<br>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p><hr><p><strong>由于Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一条线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间</strong><br>锁一共有4种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级</strong>。<br><img src="https://pic2.zhimg.com/80/v2-4b9d8ababbb870b76d6e0284caca45f1_720w.jpg" alt=""></p><h2 id="锁状态："><a href="#锁状态：" class="headerlink" title="锁状态："></a>锁状态：</h2><p>对象头中的Mark Word根据锁标志位的不同而被复用 </p><ol><li><p>无锁:无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，修改数据时采用CAS操作来进行，最终只有一个线程能修改成功。</p></li><li><p>偏向锁：<strong>在只有一个线程执行同步块时提高性能。Mark Word存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单比较ThreadID</strong>。特点：<strong>只有等到线程竞争出现才释放偏向锁，持有偏向锁的线程不会主动释放偏向锁</strong>。之后的线程竞争偏向锁，会先检查持有偏向锁的线程是否存活，如果不存活，则对象变为无锁状态，重新偏向；如果仍存活，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁</p></li><li><p>轻量级锁：</p><ul><li><p><strong>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能</strong>。</p></li><li><p>在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象目前的Mark Word到栈帧的Lock Record</p></li><li>若拷贝成功：虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向对象的Mark Word。</li><li>若拷贝失败：若当前只有一个等待线程，则可通过自旋稍微等待一下，可能持有轻量级锁的线程很快就会释放锁。</li><li>但是<strong>当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁</strong></li></ul></li><li>重量级锁：<ul><li><strong>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态</strong></li><li>指向互斥量（mutex），底层通过操作系统的mutex lock实现。等待锁的线程会被阻塞，由于Linux下Java线程与操作系统内核态线程一一映射，所以涉及到用户态和内核态的切换、操作系统内核态中的线程的阻塞和恢复。</li></ul></li></ol><p><a href="https://zhuanlan.zhihu.com/p/50098743" target="_blank" rel="noopener">美团技术博文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/paddix/p/5367116.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Synchronized的基本使用&quot;&gt;&lt;a href=&quot;#Synchronized的基本使用&quot; class=&quot;headerlink&quot; title=&quot;Synchronized的基本使用&quot;&gt;&lt;/a&gt;Synchronized的基本使用&lt;/h2&gt;&lt;p&gt;synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。从语法上讲，synchronized总共有三种用法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>HashMap与ConcurrentHashMap</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/HashMap%E4%B8%8EConcurrentHashMap/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/HashMap%E4%B8%8EConcurrentHashMap/</id>
    <published>2020-05-25T12:49:04.000Z</published>
    <updated>2020-05-25T13:10:19.964Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/search?type=content&amp;q=hashmap" target="_blank" rel="noopener">来源</a><br><a href="https://zhuanlan.zhihu.com/p/114508758" target="_blank" rel="noopener">来源</a><br><img src="https://pic2.zhimg.com/26341ef9fe5caf66ba0b7c40bba264a5_b.png" alt="1"></p><a id="more"></a><p><strong>HashMap:</strong></p><ol><li>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的</li><li>HashMap是线程不安全的，在多线程环境下会容易产生死循环，但是单线程环境下运行效率高；Hashtable线程安全的，很多方法都有synchronized修饰，但同时因为加锁导致单线程环境下效率较低。</li><li>HashMap允许有一个key为null，允许多个value为null；而Hashtable不允许key或者value为null。</li></ol><p><strong>ConcurrentHashMap</strong></p><ol><li>ConcurrentHashMap是线程安全的，ConcurrentHashMap引入了分段锁，并发性高于HashTable。</li><li>Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li></ol><p><strong>LinkedHashMap</strong></p><ol><li>nkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li></ol><p><strong>TreeMap</strong></p><ol><li>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ol><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>从结构实现来讲，HashMap是<strong>数组+链表+红黑树（JDK1.8增加了红黑树部分</strong>实现的</p><ol><li>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组 初始size为16</li><li>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)</li><li>HashMap就是使用哈希表来存储的,采用链地址法来处理冲突</li><li>哈希桶数组table的长度length大小必须为2的n次方(主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。)</li></ol><hr><p>功能实现:<br>1.确定哈希桶数组索引位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>当m为2^n^时，k%m=k&amp;(m-1)</strong><br>hash值为h^(h&gt;&gt;&gt;16)</p><h2 id="为什么要设计成h-h-gt-gt-16"><a href="#为什么要设计成h-h-gt-gt-16" class="headerlink" title="为什么要设计成h^(h&gt;&gt;16)"></a>为什么要设计成h^(h&gt;&gt;16)</h2><p>因为在确认数组索引位置时时hash&amp;(n-1)，索引的位置为后几位，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。</p><p><strong>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</strong></p><p><img src="https://pic2.zhimg.com/80/8e8203c1b51be6446cda4026eaaccf19_720w.png" alt=""></p><p><strong>2. put方法:</strong><br><img src="https://pic3.zhimg.com/80/58e67eae921e4b431782c07444af824e_720w.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">             <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">         <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3.扩容机制</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                       <span class="comment">//HashMap在JDK1.8的时候改善了扩容机制，原数组索引i上的链表不需要再反转。</span></span><br><span class="line">                   <span class="comment">// 扩容之后的索引位置只能是i或者i+oldCap（原数组的长度）</span></span><br><span class="line">                   <span class="comment">// 所以我们只需要看hashcode新增的bit为0或者1。</span></span><br><span class="line">                  <span class="comment">// 假如是0扩容之后就在新数组索引i位置，新增为1，就在索引i+oldCap位置</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>扩容之后将数组的长度扩大为2倍，那么n（数组的长度），转换为2进制数后相较于未扩容之前的n多增加了一个1的有效bit位</strong></p><p><strong>当链表长度大于等于8并且数组的长度大于等于64时才会转变为红黑树</strong></p><h2 id="树化过程"><a href="#树化过程" class="headerlink" title="树化过程"></a>树化过程</h2><p>红黑树的定义:</p><ol><li><p>节点是红色或黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>每个叶子节点都是黑色的空节点（NIL节点）。</p></li><li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p></li><li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p></li></ol><p>为了保持红黑树的规则，可以用变色，左旋转和右旋转实现</p><p><a href="https://www.cnblogs.com/finite/p/8251587.html" target="_blank" rel="noopener">树化的具体过程</a></p><h3 id="为什么链表是8次以后就转换为红黑树"><a href="#为什么链表是8次以后就转换为红黑树" class="headerlink" title="为什么链表是8次以后就转换为红黑树"></a>为什么链表是8次以后就转换为红黑树</h3><p>根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个hash槽内元素个数为8的概率小于百万分之一，将7作为一个分水岭，等于7时不做转换，大于等于8才转红黑树，小于等于6才转链表。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><strong>在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有数据覆盖的问题</strong></p><p>当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；还有++size这个地方也会造成多线程同时扩容等问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//putVal方法中</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  <span class="comment">//多线程执行到这里</span></span><br><span class="line">   tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><h1 id="Concurrenthashmap"><a href="#Concurrenthashmap" class="headerlink" title="Concurrenthashmap"></a>Concurrenthashmap</h1><p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：<br><img src="https://images2017.cnblogs.com/blog/926638/201708/926638-20170809132445011-2033999443.png" alt=""></p><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样</p><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒</p><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p>ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null</p><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>计算ConcurrentHashMap的元素大小是一个有趣的问题，因为他是并发操作的，就是在你计算size的时候，他还在并发的插入数据，可能会导致你计算出来的size和你实际的size有相差，有两种方法来实现size的计算<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0L</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        overflow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123; sum += seg.modCount; <span class="keyword">int</span> c = seg.count; <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">               overflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == last) <span class="keyword">break</span>;</span><br><span class="line">        last = sum; &#125; &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的</p></li><li><p>第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回</p></li></ol><h1 id="Concurrenthashmap-1"><a href="#Concurrenthashmap-1" class="headerlink" title="Concurrenthashmap"></a>Concurrenthashmap</h1><p>在jdk1.8版本中：</p><ol><li><p><strong>取消segments字段，直接采用transient volatile HashEntry<K,V>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率</strong>。</p></li><li><p><strong>将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构</strong>。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p></li></ol><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">//两次hash，减少hash冲突，可以均匀分布</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">//对这个table进行迭代</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;<span class="comment">//如果i位置没有数据，就直接无锁插入</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//如果在进行扩容，则先进行扩容操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果以上条件都不满足，那就要进行加锁操作，也就是存在hash冲突，锁住链表或者红黑树的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">//表示该节点是链表结构</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//这里涉及到相同的key进行put就会覆盖原先的value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;  <span class="comment">//插入链表尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">//红黑树结构</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//红黑树结构旋转插入</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">//如果链表的长度大于8时就会进行红黑树的转换</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);<span class="comment">//统计size，并且检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下:</p><ol><li><p>如果没有初始化就先调用initTable（）方法来进行初始化过程</p></li><li><p>如果没有hash冲突就直接CAS插入</p></li><li>如果还在进行扩容操作就先进行扩容</li><li>如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，</li><li>最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环</li><li>如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容</li></ol><p><strong>他在并发处理中使用的是乐观锁，当有冲突的时候才进行并发处理</strong></p><h2 id="get操作-1"><a href="#get操作-1" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode()); <span class="comment">//计算两次hash</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;<span class="comment">//读取首节点的Node元素</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123; <span class="comment">//如果该节点就是首节点就返回</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来</span></span><br><span class="line">        <span class="comment">//查找，查找到就返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;<span class="comment">//既不是首节点也不是ForwardingNode，那就往下遍历</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get流程如下:</p><ol><li><p>计算hash值，定位到该table索引位置，如果是首节点符合就返回</p></li><li><p>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</p></li><li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li></ol><p><a href="https://blog.csdn.net/xingxiupaioxue/article/details/88062163" target="_blank" rel="noopener">concurrenthashmap1.7和1.8的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/search?type=content&amp;amp;q=hashmap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/114508758&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/26341ef9fe5caf66ba0b7c40bba264a5_b.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/categories/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="HashMap" scheme="https://sqwyyy.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #642 (Div. 3)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-642-Div-3/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-642-Div-3/</id>
    <published>2020-05-18T15:32:35.000Z</published>
    <updated>2020-05-19T06:35:52.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="E-K-periodic-Garland"><a href="#E-K-periodic-Garland" class="headerlink" title="E. K-periodic Garland"></a><a href="https://codeforces.com/contest/1353/problem/E" target="_blank" rel="noopener">E. K-periodic Garland</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>给一个01串,一次操作可以把一个0变成1，或者把1变成0.求最小的操作次数使得01串中相邻得两个1之间间隔为k。</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>假设<strong>dp(i)为第i栈灯亮并且[1,i]的灯都是合法的且操作数最少</strong></p><p>则递推式为</p><script type="math/tex; mode=display">当i为第一个1的位置时\quad dp_i = 区间(1,i-1)中1的个数+(s_i=='0')</script><script type="math/tex; mode=display">当i不为第一个1的位置时\\ dp_i= min(dp_i,dp_{i-k}+区间(i-k+1,i-1)中1的个数+(s_i=='0'))</script><p>由于dp(i)只是(1,i)合法的需要将(i+1,n)全部置0，这样区间(1,n)则合法但不一定是最小，在枚举每个dp(i)+sum(n)-sum(i)取最小值就是答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1e6</span>;</span><br><span class="line">            sum[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+(s[i]==<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum[n]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=(s[i]==<span class="string">'0'</span>)+sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k)&#123;</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i],(s[i]==<span class="string">'0'</span>)+dp[i-k]+(sum[i<span class="number">-1</span>]-sum[i-k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,sum[n]-sum[i]+dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Decreasing-Heights"><a href="#F-Decreasing-Heights" class="headerlink" title="F. Decreasing Heights"></a><a href="https://codeforces.com/problemset/problem/1353/F" target="_blank" rel="noopener">F. Decreasing Heights</a></h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p> 给定一个n∗m的矩阵,起点位(1,1)终点为(n,m),每次可以向右或向下走1格，并且<strong>只能走比当前位置的权值大1的位置</strong>。在开始走之前你可以进行任意次操作，每次操作可以把任意位置的权值减少1，求走到终点需要的最小操作次数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>在本题中需要确定一条性质从<strong>(1,1)的(n,m)的路径中一定存在至少一个点的权值不变</strong></p><script type="math/tex; mode=display">如果确定了起点的权值为b_{1,1}\\那么从起点(1,1)走到(i,j)时,(i,j)的权值一定为b_{1,1}+i+j。\\则整个路径的总和则为b_{1,1}+b_{1,1}+1+\cdots+b_{1,1}+n+m</script><p>需要操作数最小，则从<strong>(1,1)的(n,m)的路径中一定存在至少一个点的权值不变</strong></p><p>则本题可以枚举不变点(x,y)，以(x,y)将矩阵分为上下两个矩阵，分别进行dp即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码:"></a>代码:</h2><script type="math/tex; mode=display">dp(i,j)代表以(x,y)为权值不变的点，所确定(i,j)的最小值\\答案则为ans=min(ans,dp(1,1)+dp(n,m))</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">ll dp[maxn][maxn],mpt[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mpt[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=m;y++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                        dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[x][y]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==x&amp;&amp;j==y) <span class="keyword">continue</span>;</span><br><span class="line">                        ll val = mpt[x][y]-(x-i+y-j);</span><br><span class="line">                        ll cost = mpt[i][j] - val;</span><br><span class="line">                        <span class="keyword">if</span>(cost&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> pos1 = i+<span class="number">1</span>&gt;n?n:i+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">int</span> pos2 = j+<span class="number">1</span>&gt;m?m:j+<span class="number">1</span>;</span><br><span class="line">                        dp[i][j]=<span class="built_in">min</span>(dp[pos1][j],dp[i][pos2])+cost;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;=m;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==x&amp;&amp;j==y) <span class="keyword">continue</span>;</span><br><span class="line">                        ll val = mpt[x][y]+(i-x+j-y);</span><br><span class="line">                        ll cost = mpt[i][j] - val;</span><br><span class="line">                        <span class="keyword">if</span>(cost&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> pos1 = i<span class="number">-1</span>&lt;=<span class="number">0</span>?<span class="number">1</span>:i<span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">int</span> pos2 = j<span class="number">-1</span>&lt;=<span class="number">0</span>?<span class="number">1</span>:j<span class="number">-1</span>;</span><br><span class="line">                        dp[i][j]=<span class="built_in">min</span>(dp[pos1][j],dp[i][pos2])+cost;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,dp[<span class="number">1</span>][<span class="number">1</span>]+dp[n][m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;E-K-periodic-Garland&quot;&gt;&lt;a href=&quot;#E-K-periodic-Garland&quot; class=&quot;headerlink&quot; title=&quot;E. K-periodic Garland&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1353/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;E. K-periodic Garland&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;给一个01串,一次操作可以把一个0变成1，或者把1变成0.求最小的操作次数使得01串中相邻得两个1之间间隔为k。&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #641(Div.2)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-641-Div-2/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-641-Div-2/</id>
    <published>2020-05-18T14:22:57.000Z</published>
    <updated>2020-05-18T14:27:51.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Orac-and-LCM"><a href="#C-Orac-and-LCM" class="headerlink" title="C Orac and LCM"></a><a href="https://codeforces.com/contest/1350/problem/C" target="_blank" rel="noopener">C Orac and LCM</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>给了n个数，让求gcd{ lcm{a[i],a[j]} } (i&lt;j)<br>就是n个数，两两配对求出他们的lcm，对于所有lcm在求出gcd</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>根据唯一分解定理</p><script type="math/tex; mode=display">x=p_1^{a_1}*p_2^{a_2}*..*p_k^{a_k} \quad y=p_1^{b_1}*p_2^{b_2}*..*p_k^{b_k}</script><p>则gcd和lcm在算术基本定理下的含义:</p><script type="math/tex; mode=display">lcm(x,y)=p_1^{max(a_1,b_1)}*p_2^{max(a_2,b_2)}*...*p_k^{max(a_k,b_k)}</script><script type="math/tex; mode=display">gcd(x,y)=p_1^{min(a_1,b_1)}*p_2^{min(a_2,b_2)}*...*p_k^{min(a_k,b_k)}</script><p>对于n个数而言:</p><ol><li>如果n-1个数都有质因子x，那么所求答案的gcd一定含有x，不含质因子的那个数一定会与含有质因子的数求lcm，则求出来的数一定含有质因子x，则答案应该乘以这个质因子的<strong>最小</strong></li><li>如果n个数都有质因子x，那么所求答案的gcd一定含有x，则答案应该乘以这个质因子的<strong>第二小</strong></li><li>如果少于n-1个数含有质因子x，则一定存在没有质因子的两个数求lcm，则对答案没有贡献</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>vis代表第j个数为质因子i的幂次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">     ll x;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*j&lt;=x;j++)&#123;</span><br><span class="line">         ll cnt=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(x%j==<span class="number">0</span>)&#123;</span><br><span class="line">           x/=j;</span><br><span class="line">           cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">         vis[j].push_back(cnt);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(x!=<span class="number">1</span>) vis[x].push_back(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(vis[i].<span class="built_in">size</span>()&gt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">       sort(vis[i].<span class="built_in">begin</span>(),vis[i].<span class="built_in">end</span>());</span><br><span class="line">       <span class="keyword">if</span>(vis[i].<span class="built_in">size</span>()==n) ans*=_pow(i,vis[i][<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">else</span> ans*=_pow(i,vis[i][<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Orac-and-Medians"><a href="#D-Orac-and-Medians" class="headerlink" title="D. Orac and Medians"></a><a href="https://codeforces.com/contest/1350/problem/D" target="_blank" rel="noopener">D. Orac and Medians</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h2><p>给出一个长度为 n 的数列，以及一个数字 k ，每次操作可以将一段连续区间 [ l , r ] 内的数字全部替换成该区间的中位数(如果该区间长度为偶数则中位数为a[n/2])，问能否通过适当的操作使得整个数列的 n 个数字全部等于 k </p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h2><p>首先不难看出，如果区间内不存在数字 k 的话一定是 no ，然后我设:</p><ol><li>小于 k 的数为 -1</li><li>大于 k 的数为 1</li><li>等于 k 的数为 0</li></ol><p>对[1,n]区间进行讨论，sum为区间[1,n]的和，有以下三种情况:</p><ol><li>如果 sum == 0 的话，说明等于 k 的数已经位于中位数的位置了，显然为 yes</li><li>如果 sum &gt; 0 的话，说明大于 k 的数比较多，需要减少大于 k 的数量，因为此时经过筛选后，区间内一定存在等于 k 的数，即一定存在着非正数（ -1 和 0 ），<strong>与这些非正数相邻的正数可以组成长度为 2 的区间，此时正数都可以根据规则被同化为非正数</strong>，所以通过适当的操作可以使 sum 不断减小，直到 sum == 0 ，所以这种情况也显然为 yes</li><li>如果 sum &lt; 0 的话，根据上面的思想，我们的目标是令 sum 不断增大，直到 sum == 0 为止，如果负数想要被同化为非负数的话，需要在长度至少为 3 的区间内，满足：<strong>有一个负数以及两个非负数</strong>才行</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> pi =<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">      <span class="keyword">if</span>(a[i]==k) num++,a[i]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;k) a[i]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> a[i]=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!num)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;a[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">1</span>&amp;&amp;a[i<span class="number">-2</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Orac-and-Game-of-Life"><a href="#E-Orac-and-Game-of-Life" class="headerlink" title="E. Orac and Game of Life"></a><a href="https://codeforces.com/contest/1350/problem/E" target="_blank" rel="noopener">E. Orac and Game of Life</a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意:"></a>题意:</h2><p>给个n*m的网格，里面一些格子一开始是白色(0)，另一些是黑色(1)，接下来网格可进行迭代，对于每次迭代，格子里颜色的变化遵循以下规则：</p><ol><li><p>若该格子有相邻格子的颜色与之相同，则颜色翻转</p></li><li><p>若该格子没有相邻格子的颜色与之相同，则颜色不变</p></li></ol><p>有t次询问，每次询问都有i, j, p，表示问第i行第j列格子在第p次迭代后是什么颜色</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h2><p>网格中一共有两种点:</p><ol><li>它的周围没有任何相同的点，不会变换</li><li>它的周围有相同的点，会与周围的点一直变换</li></ol><p><strong>对于第二种点，它周围和它同色的点会每个状态交替变换，且永远不会变成第一种点</strong></p><p><strong>对于第一种点，它周围第一次迭代可能没有相同的点，第k次则可能出现与其相同的点，则会变成第二种点</strong></p><p><strong>对于每个点只要求出第一次发生变化的迭代时刻，则根据t-p计算奇偶性就能知道这个点的颜色</strong></p><p>则问题就变成了</p><p>在一个新的01棋盘，0和1分别代表第一种和第二种点，<strong>求出所有第一种点离最近的第二种点的距离</strong></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li><p>设dp(i,j)表示第(i, j)个格子在dp(i,j)次迭代后会开始变色</p></li><li><p>初始dist数组的值为inf</p></li><li><p>对一开始就能变色的格子进行深搜，设其dp(x,y)=0，并把该格子加入宽搜队列</p></li><li><p>进行宽搜，把宽搜队列中的元素取出来进行四联通的搜索，如果有dp(x,y)+ 1 &lt; dp(xx,yy)，那么dp(xx,yy)更新并将第(xx, yy)格子加入宽搜队列</p></li><li><p>对于dist(i,j)为inf的格子，说明不管怎么迭代永远都不会变色，p &lt; dp(x,y)时，说明直到该次迭代都没有变色，p &gt;= dp(x,y)时，若p - dp(x,y)是奇数就说明这次迭代与初始色相反，偶数就是与初始色相同</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="built_in">string</span> mpt[maxn];</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkboundary</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=n||j&lt;<span class="number">0</span>||j&gt;=m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> by[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;mpt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pr&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(checkboundary(i+bx[k],j+by[k]))&#123;</span><br><span class="line">                    <span class="keyword">int</span> l=i+bx[k],r=j+by[k];</span><br><span class="line">                    <span class="keyword">if</span>(mpt[l][r]==mpt[i][j])&#123;</span><br><span class="line">                      <span class="keyword">if</span>(!vis[l][r]) q.push(make_pair(l,r));</span><br><span class="line">                      dp[l][r]=<span class="number">0</span>;</span><br><span class="line">                      vis[l][r]=<span class="number">1</span>;</span><br><span class="line">                      num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>&amp;&amp;!vis[i][j])&#123;</span><br><span class="line">                q.push(make_pair(i,j));</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                vis[i][j]=<span class="number">1</span>;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;m;j++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;vis[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;q.size()&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        pr now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=now.first+bx[i];</span><br><span class="line">            <span class="keyword">int</span> y=now.second+by[i];</span><br><span class="line">            <span class="keyword">if</span>(checkboundary(x,y))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y]&amp;&amp;dp[x][y]&gt;dp[now.first][now.second]+<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">                    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">                    dp[x][y]=dp[now.first][now.second]+<span class="number">1</span>;</span><br><span class="line">                    q.push(make_pair(x,y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">      ll i,j,p;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j&gt;&gt;p;</span><br><span class="line">      <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&gt;p)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        ll num = p - dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;((mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]-<span class="string">'0'</span>)^<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-Orac-and-LCM&quot;&gt;&lt;a href=&quot;#C-Orac-and-LCM&quot; class=&quot;headerlink&quot; title=&quot;C Orac and LCM&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1350/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C Orac and LCM&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;给了n个数，让求gcd{ lcm{a[i],a[j]} } (i&amp;lt;j)&lt;br&gt;就是n个数，两两配对求出他们的lcm，对于所有lcm在求出gcd&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
      <category term="数论" scheme="https://sqwyyy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>codeforces round #643(Div.2)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/17/codeforces-round-643-Div-2/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/17/codeforces-round-643-Div-2/</id>
    <published>2020-05-17T07:36:17.000Z</published>
    <updated>2020-05-17T07:49:30.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Count-Triangles"><a href="#C-Count-Triangles" class="headerlink" title="C. Count Triangles"></a><a href="https://codeforces.com/contest/1355/problem/C" target="_blank" rel="noopener">C. Count Triangles</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>给你 A , B , C , D</p><p>问有多少种方法构造出三角形(X , Y , Z)使得 A ≤ X ≤ B ≤ Y ≤ C ≤ Z ≤ D</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol><li><p>构成三角形的条件是：x+y&gt;z</p></li><li><p>那么可以进行<strong>枚举x+y来优化,令m=x+y，算出当x+y和为m的时候，有几种可行的构造数量s2，然后去乘s1=max(m-1,d)-c+1就可以了</strong>，前提是s1和s2均非0</p></li><li><p>∵x+y=m, ∴y=m-x, 又∵B≤y=m-x≤C,∴m-C≤x≤m-B，又因为A≤x≤B，所以取交集，该组数目等于右界-左界+1</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll a,b,c,d;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=a+b;i&lt;=b+c;i++)&#123;</span><br><span class="line">        ll s1=<span class="built_in">min</span>(d,i<span class="number">-1</span>)-c+<span class="number">1</span>;</span><br><span class="line">        ll s2=<span class="built_in">min</span>(i-b,b)-<span class="built_in">max</span>(i-c,a)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1&lt;<span class="number">0</span>||s2&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sum+=s1*s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Game-With-Array"><a href="#D-Game-With-Array" class="headerlink" title="D. Game With Array"></a><a href="https://codeforces.com/contest/1355/problem/D" target="_blank" rel="noopener">D. Game With Array</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h2><p>问你能否构造一个长度为 N 且和为 S 的序列</p><p>使得对于该序列你无法找到一个子序列使得子序列的和等于 K 或 S - K (0 &lt;= K &lt;= S)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>猜结论</p><p>我们构造一个前 N - 1项为 1，第 N 项为 S - N + 1 的序列</p><p>对于前 N - 1项构成的序列的和我们设为 K，那么第 N 项构成的序列和就为 S - K</p><p>这样就很好的使用上了题目给的信息，所以盲猜该构造方法是可行的</p><p>那么对于该序列，[ 1 , N - 1 ] 和 [ S - (N - 1) , S ] 的值我们都是可以通过选取子序列得到</p><p>而 [ N , S - N ] 的值无法得到，所以只要判断 N 是否小于等于 S - N 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n , s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s ;</span><br><span class="line">    <span class="keyword">int</span> ans = s - n;</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - <span class="number">1</span> ; i ++) <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-Count-Triangles&quot;&gt;&lt;a href=&quot;#C-Count-Triangles&quot; class=&quot;headerlink&quot; title=&quot;C. Count Triangles&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1355/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C. Count Triangles&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;给你 A , B , C , D&lt;/p&gt;
&lt;p&gt;问有多少种方法构造出三角形(X , Y , Z)使得 A ≤ X ≤ B ≤ Y ≤ C ≤ Z ≤ D&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
      <category term="思维 三分" scheme="https://sqwyyy.github.io/tags/%E6%80%9D%E7%BB%B4-%E4%B8%89%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/Java%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2020-05-10T15:52:45.000Z</published>
    <updated>2020-05-10T15:55:13.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h1><pre><code>1. 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化（因为外部类的非静态方法是需要创建外部类对象才能调用的，而你的静态内部类是不需要外部类对象就可以得到的）。</code></pre><h1 id="成员内部类："><a href="#成员内部类：" class="headerlink" title="成员内部类："></a>成员内部类：</h1><pre><code>1. 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。</code></pre><h1 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h1><pre><code>1. 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。2. 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。</code></pre><h1 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h1><pre><code>1. 没有类名的内部类，不能使用class，extends和implements，没有构造方法。2. 多用于GUI中的事件处理。3. 不能定义静态资源4. 只能创建一个匿名内部类实例。5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效</code></pre><hr><a id="more"></a><h1 id="非静态内部类为什么不能有静态成员变量和静态方法："><a href="#非静态内部类为什么不能有静态成员变量和静态方法：" class="headerlink" title="非静态内部类为什么不能有静态成员变量和静态方法："></a>非静态内部类为什么不能有静态成员变量和静态方法：</h1><p>JVM的类加载规则 ：</p><ol><li>static类型的属性和方法，在类加载的时候就会存在于内存中。</li><li>要想使用某个类的static属性和方法，那么这个类必须要加载到JAVA虚拟机中。</li><li>非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。<br>现在考虑这个情况：在外部类并没有实例化，内部类还没有加载，这时候如果<br>调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内<br>部类的静态成员，这明显是矛盾的。所以非静态内部类不能有静态成员变量或<br>静态方法。</li></ol><hr><h1 id="为什么静态内部类不允许访问外部非静态成员："><a href="#为什么静态内部类不允许访问外部非静态成员：" class="headerlink" title="为什么静态内部类不允许访问外部非静态成员："></a>为什么静态内部类不允许访问外部非静态成员：</h1><p>成员变量也叫实例变量，随着对象的创建而存在<br>静态成员随着类的加载而加载， 生命周期比对象长<br>静态成员在的时候还没成员变量，那还怎么调用</p><hr><h1 id="为什么局部内部类和匿名内部类只能访问final的局部变量"><a href="#为什么局部内部类和匿名内部类只能访问final的局部变量" class="headerlink" title="为什么局部内部类和匿名内部类只能访问final的局部变量?"></a>为什么局部内部类和匿名内部类只能访问final的局部变量?</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> InTest().f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test t=<span class="keyword">new</span> Test();</span><br><span class="line">t.play();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要原因还是生命周期：当我的t.play（）出栈后，play中的局部变量<br>就会随之销毁，但是我的内部类对象可能仍然还存在的（当不在被使用才会被垃圾回收器回收）这时在内部类中访问了局部变量x，但此时的x已经被销毁，内部类访问了一个并不会存在的变量，这就形成了一个矛盾。根本原因就是：内部类的生命周期比局部变量的长</strong><br>其实如果我们编译Test.java文件发现会出现两个class文件，Test.class和Test$InTest.class文件，java会将Test中的局部变量x复制一份到TestInTest.class中当做是内部类的成员常量。这样我们访问的其实就是复制的那个成员常量。</p><p><strong>如何保证数据的一致性：当我们修改局部变量的时候如何保证被复制出来的变量也会同步一致：用final修饰。这样只要这个局部变量进栈初始化的时候就是一个常量。在生命周期内不能被改变，这里注意生命周期。这样就保证了内部类的成员变量和方法的局部变量的一致性。</strong></p><hr><h1 id="内部类为什么能访问外部类的成员变量"><a href="#内部类为什么能访问外部类的成员变量" class="headerlink" title="内部类为什么能访问外部类的成员变量"></a>内部类为什么能访问外部类的成员变量</h1><p>1 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用；<br>2 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值；<br>3 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。<br><a href="https://blog.csdn.net/zhangjg_blog/article/details/20000769" target="_blank" rel="noopener">来源</a><br><a href="https://www.nowcoder.com/questionTerminal/e886e58981c346098a043c3c2ad2d736" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;静态内部类：&quot;&gt;&lt;a href=&quot;#静态内部类：&quot; class=&quot;headerlink&quot; title=&quot;静态内部类：&quot;&gt;&lt;/a&gt;静态内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化（因为外部类的非静态方法是需要创建外部类对象才能调用的，而你的静态内部类是不需要外部类对象就可以得到的）。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;成员内部类：&quot;&gt;&lt;a href=&quot;#成员内部类：&quot; class=&quot;headerlink&quot; title=&quot;成员内部类：&quot;&gt;&lt;/a&gt;成员内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;局部内部类：&quot;&gt;&lt;a href=&quot;#局部内部类：&quot; class=&quot;headerlink&quot; title=&quot;局部内部类：&quot;&gt;&lt;/a&gt;局部内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。
2. 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;匿名内部类：&quot;&gt;&lt;a href=&quot;#匿名内部类：&quot; class=&quot;headerlink&quot; title=&quot;匿名内部类：&quot;&gt;&lt;/a&gt;匿名内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 没有类名的内部类，不能使用class，extends和implements，没有构造方法。
2. 多用于GUI中的事件处理。
3. 不能定义静态资源
4. 只能创建一个匿名内部类实例。
5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。
6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="内部类" scheme="https://sqwyyy.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Session和Cookie</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/Session%E5%92%8CCookie/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/Session%E5%92%8CCookie/</id>
    <published>2020-05-10T15:50:05.000Z</published>
    <updated>2020-05-10T15:55:13.857Z</updated>
    
    <content type="html"><![CDATA[<p><strong>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session,Cookie是实现Session的一种方式（并不是唯一的）</strong><br><a id="more"></a></p><hr><p>1，session 在服务器端，cookie 在客户端（浏览器）<br>2，session 默认被存在在服务器的一个文件里（不是内存）<br>3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）<br>4，session 可以放在 文件、数据库、或内存中都可以。<br>5，用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id</p><hr><p>==如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。==</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session,Cookie是实现Session的一种方式（并不是唯一的）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Session" scheme="https://sqwyyy.github.io/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList和LinkedList</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/ArrayList%E5%92%8CLinkedList/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/ArrayList%E5%92%8CLinkedList/</id>
    <published>2020-05-10T15:45:16.000Z</published>
    <updated>2020-05-10T15:49:31.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的区别"><a href="#简单的区别" class="headerlink" title="简单的区别"></a>简单的区别</h1><ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous） </li><li><p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p></li><li><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p><a id="more"></a></li></ol><h1 id="深度的区别"><a href="#深度的区别" class="headerlink" title="深度的区别"></a>深度的区别</h1><ol><li>对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。</li><li>在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。</li><li><p>LinkedList不支持高效的随机元素访问。</p></li><li><p>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间</p></li></ol><h1 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h1><p>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，并且ArrayList不是线程安全的。</p><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">      * The array buffer into which the elements of the ArrayList are stored. </span></span><br><span class="line"><span class="comment">      * The capacity of the ArrayList is the length of this array buffer. </span></span><br><span class="line"><span class="comment">      */</span>  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;  </span><br><span class="line">   </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">      * The size of the ArrayList (the number of elements it contains). </span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@serial</span> </span></span><br><span class="line"><span class="comment">      */</span>  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><br>被标记为transient的属性在对象被序列化的时候不会被保存。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法:"></a>构造方法:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList带容量大小的构造函数。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">super</span>();    </span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+    </span><br><span class="line">                                               initialCapacity);    </span><br><span class="line">        <span class="comment">// 新建一个数组    </span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ArrayList无参构造函数。默认容量是10。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个包含collection的ArrayList    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    </span><br><span class="line">        elementData = c.toArray();    </span><br><span class="line">        size = elementData.length;    </span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)    </span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="元素存储"><a href="#元素存储" class="headerlink" title="元素存储:"></a>元素存储:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </span><br><span class="line">   RangeCheck(index);  </span><br><span class="line"> </span><br><span class="line">   E oldValue = (E) elementData[index];  </span><br><span class="line">   elementData[index] = element;  </span><br><span class="line">   <span class="keyword">return</span> oldValue;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 将指定的元素添加到此列表的尾部。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">   ensureCapacity(size + <span class="number">1</span>);   </span><br><span class="line">   elementData[size++] = e;  </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 将指定的元素插入此列表中的指定位置。  </span></span><br><span class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);  </span><br><span class="line">   <span class="comment">// 如果数组长度不足，将进行扩容。  </span></span><br><span class="line">   ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></span><br><span class="line">   <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，  </span></span><br><span class="line">   <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。  </span></span><br><span class="line">   <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></span><br><span class="line">   System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);  </span><br><span class="line">   elementData[index] = element;  </span><br><span class="line">   size++;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">   Object[] a = c.toArray();  </span><br><span class="line">   <span class="keyword">int</span> numNew = a.length;  </span><br><span class="line">   ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></span><br><span class="line">   System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);  </span><br><span class="line">   size += numNew;  </span><br><span class="line">   <span class="keyword">return</span> numNew != <span class="number">0</span>;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(  </span><br><span class="line">           <span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);  </span><br><span class="line"> </span><br><span class="line">   Object[] a = c.toArray();  </span><br><span class="line">   <span class="keyword">int</span> numNew = a.length;  </span><br><span class="line">   ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> numMoved = size - index;  </span><br><span class="line">   <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </span><br><span class="line"> </span><br><span class="line">   System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </span><br><span class="line">   size += numNew;  </span><br><span class="line">   <span class="keyword">return</span> numNew != <span class="number">0</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="元素读取"><a href="#元素读取" class="headerlink" title="元素读取:"></a>元素读取:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容:"></a>扩容:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">            &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">                 &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                    minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                    oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">            <span class="keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elementData = <span class="keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除:"></a>元素删除:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除此列表中指定位置上的元素。  </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    modCount++;  </span><br><span class="line">    E oldValue = (E) elementData[index];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);  </span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> oldValue;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的区别&quot;&gt;&lt;a href=&quot;#简单的区别&quot; class=&quot;headerlink&quot; title=&quot;简单的区别&quot;&gt;&lt;/a&gt;简单的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous） &lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="集合类" scheme="https://sqwyyy.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
</feed>
