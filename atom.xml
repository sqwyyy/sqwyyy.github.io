<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-09-14T12:29:51.708Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类加载过程</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/07/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/07/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-09-07T13:11:36.000Z</published>
    <updated>2020-09-14T12:29:51.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>一个类完整的生命周期</p><p><img src="https://camo.githubusercontent.com/68465e752e28fd5e7c6a6d442c19f05305c8f043/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422d2545352541452538432545352539362538342e706e67" alt=""></p><a id="more"></a><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p><p>系统加载 Class 类型的文件主要三步:<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><a href="https://camo.githubusercontent.com/9cb5a35384ed4da10079e3180e608828c7afe3a8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9cb5a35384ed4da10079e3180e608828c7afe3a8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422e706e67" alt="img"></a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ol><p>虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><a href="https://camo.githubusercontent.com/6175c9d001e4fb2bc0c1c49c0bd4a8d280e90846/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392541412538432545382541462538312545392539382542362545362541452542352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6175c9d001e4fb2bc0c1c49c0bd4a8d280e90846/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392541412538432545382541462538312545392539382542362545362541452542352e706e67" alt="验证阶段示意图"></a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ol><p><strong>基本数据类型的零值：</strong></p><p><a href="https://camo.githubusercontent.com/689e28f80449f103b217a87affc6c14a10974722/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352539462542412545362539432541432545362539352542302545362538442541452545372542312542422545352539452538422545372539412538342545392539422542362545352538302542432e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/689e28f80449f103b217a87affc6c14a10974722/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352539462542412545362539432541432545362539352542302545362538442541452545372542312542422545352539452538422545372539412538342545392539422542362545352538302542432e706e67" alt="基本数据类型的零值"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code>()</code>方法的过程。</p><p>对于<code>（）</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>（）</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>卸载类即该类的Class对象被GC。</p><p>卸载类需要满足3个要求:</p><ol><li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC</li></ol><p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>​       <strong>通过一个类的全限定名来获取描述此类的二进制字节流这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类</strong>。实现这个动作的代码模块称为<strong>“类加载器”</strong>。</p><p>类加载器:</p><p><img src="https://picb.zhimg.com/80/v2-9e3254602608f3d224ac1dd3ab816075_720w.jpg" alt=""></p><ul><li><strong>BootstrapClassLoader</strong>：启动类类加载器，它用来加载<JAVA_HOME>/jre/lib路径,<strong>-</strong>Xbootclasspath参数指定的路径以<JAVA_HOME>/jre/classes中的类。BootStrapClassLoader是由c++实现的。</li><li><strong>ExtClassLoader</strong>：拓展类类加载器，它用来加载<JAVA_HOME>/jre/lib/ext路径以及java.ext.dirs系统变量指定的类路径下的类。</li><li><strong>AppClassLoader</strong>：应用程序类类加载器，它主要加载应用程序ClassPath下的类（包含jar包中的类）。它是java应用程序默认的类加载器。</li><li><strong>用户自定义类加载器</strong>：用户根据自定义需求，自由的定制加载的逻辑，继承AppClassLoader，仅仅覆盖findClass（）即将继续遵守双亲委派模型。</li><li><strong>*ThreadContextClassLoader</strong>：线程上下文加载器，它不是一个新的类型，更像一个类加载器的角色，ThreadContextClassLoader可以是上述类加载器的任意一种，但往往是AppClassLoader。</li></ul><h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><h3 id="ClassLoader-传递性"><a href="#ClassLoader-传递性" class="headerlink" title="ClassLoader 传递性"></a>ClassLoader 传递性</h3><p>​        程序在运行过程中，遇到了一个未知的类，它会选择哪个 ClassLoader 来加载它呢？虚拟机的策略是使用调用者 Class 对象的 ClassLoader 来加载当前未知的类。何为调用者 Class 对象？就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者 Class 对象。前面我们提到每个 Class 对象里面都有一个 classLoader 属性记录了当前的类是由谁来加载的。</p><p>因为 ClassLoader 的传递性，所有延迟加载的类都会由初始调用 main 方法的这个 ClassLoader 全全负责，它就是 AppClassLoader。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>前面提到 AppClassLoader 只负责加载 Classpath 下面的类库，如果遇到没有加载的系统类库怎么办，AppClassLoader 必须将系统类库的加载工作交给 BootstrapClassLoader 和 ExtensionClassLoader 来做，这就是我们常说的「双亲委派」。</p><p><img src="https://pic4.zhimg.com/80/v2-6d038f875790e1cdbf17a9aac11961e3_720w.jpg" alt=""></p><p>AppClassLoader 在加载一个未知的类名时，它并不是立即去搜寻 Classpath，它会首先将这个类名称交给 ExtensionClassLoader 来加载，如果 ExtensionClassLoader 可以加载，那么 AppClassLoader 就不用麻烦了。否则它就会搜索 Classpath 。</p><h2 id="双亲委派模式的好处"><a href="#双亲委派模式的好处" class="headerlink" title="双亲委派模式的好处"></a>双亲委派模式的好处</h2><p><strong>双亲委派模型能保证基础类仅加载一次，不会让jvm中存在重名的类。比如String.class，每次加载都委托给父加载器，最终都是BootstrapClassLoader，都保证java核心类都是BootstrapClassLoader加载的，保证了java的安全与稳定性</strong>。</p><h2 id="破坏双亲委托模式"><a href="#破坏双亲委托模式" class="headerlink" title="破坏双亲委托模式"></a>破坏双亲委托模式</h2><p><a href="https://zhuanlan.zhihu.com/p/54693308" target="_blank" rel="noopener">来源</a></p><p><a href="https://zhuanlan.zhihu.com/p/51374915" target="_blank" rel="noopener">来源</a></p><p><a href="https://zhuanlan.zhihu.com/p/101031254" target="_blank" rel="noopener">new一个对象发生的事</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类的生命周期&quot;&gt;&lt;a href=&quot;#类的生命周期&quot; class=&quot;headerlink&quot; title=&quot;类的生命周期&quot;&gt;&lt;/a&gt;类的生命周期&lt;/h1&gt;&lt;p&gt;一个类完整的生命周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/68465e752e28fd5e7c6a6d442c19f05305c8f043/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422d2545352541452538432545352539362538342e706e67&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA虚拟机" scheme="https://sqwyyy.github.io/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>select poll epoll</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/06/select-poll-epoll/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/06/select-poll-epoll/</id>
    <published>2020-09-06T12:57:39.000Z</published>
    <updated>2020-09-08T09:52:26.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>​      select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><a id="more"></a><h1 id="多路IO复用"><a href="#多路IO复用" class="headerlink" title="多路IO复用"></a>多路IO复用</h1><p><strong>I/O多路复用就通过一种机制，让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。</strong>。</p><p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ol><li>第一种选择：<strong>按顺序逐个检查</strong>，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。<br>这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</li><li>第二种选择：你<strong>创建30个分身</strong>，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</li><li>第三种选择，你<strong>站在讲台上等，谁解答完谁举手</strong>。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 </li><li>这种就是IO复用模型，</li></ol><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>linux提供的select相关函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> max_fd, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout)</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>   <span class="comment">//清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">//将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>  <span class="comment">//将给定的描述符从文件中删除  </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fds)</span>    <span class="comment">//判断指定描述符是否在集合中</span></span></span><br></pre></td></tr></table></figure><h3 id="select的流程"><a href="#select的流程" class="headerlink" title="select的流程"></a>select的流程</h3><p>select的实现思路很直接。假如程序同时监视如下图的sock1、sock2和sock3三个socket，那么在调用select之后，操作系统把进程A分别加入这三个socket的等待队列中。</p><p><img src="https://pic2.zhimg.com/80/v2-0cccb4976f8f2c2f8107f2b3a5bc46b3_720w.jpg" alt=""></p><p>当任何一个socket收到数据后，中断程序将唤起进程。下图展示了sock2接收到了数据的处理流程。</p><p><img src="https://pic2.zhimg.com/80/v2-85dba5430f3c439e4647ea4d97ba54fc_720w.jpg" alt=""></p><p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面。如下图所示。</p><p><img src="https://pic3.zhimg.com/80/v2-a86b203b8d955466fff34211d965d9eb_720w.jpg" alt=""></p><p>经由这些步骤，当进程A被唤醒后，它知道至少有一个socket接收了数据。程序只需遍历一遍socket列表，就可以得到就绪的socket。</p><p>这种简单方式<strong>行之有效</strong>，在几乎所有操作系统都有对应的实现。</p><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行<strong>轮询</strong>，根据描述符的状态进行处理，但是<strong>poll没有最大文件描述符数量的限制</strong>。</p><p>linux提供的select相关函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fds[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> fd;                         <span class="comment">// 需要被检测或选择的文件描述符</span></span><br><span class="line">        short events;                   <span class="comment">// 对文件描述符fd上感兴趣的事件</span></span><br><span class="line">        short revents;                  <span class="comment">// 文件描述符fd上当前实际发生的事件*/</span></span><br><span class="line">&#125; <span class="keyword">pollfd_t</span>;</span><br></pre></td></tr></table></figure><h1 id="select和poll的缺点"><a href="#select和poll的缺点" class="headerlink" title="select和poll的缺点"></a>select和poll的缺点</h1><h2 id="select的缺点："><a href="#select的缺点：" class="headerlink" title="select的缺点："></a>select的缺点：</h2><ol><li><strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></li><li><strong>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</strong></li><li><strong>单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE 1024)</strong></li><li><strong>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</strong></li></ol><h2 id="poll的缺点与改进"><a href="#poll的缺点与改进" class="headerlink" title="poll的缺点与改进"></a>poll的缺点与改进</h2><p>改进：</p><ol><li><strong>poll使用链表保存文件描述符，因此没有了监视文件描述符数量的限制</strong></li></ol><p>缺点：</p><ol><li><strong>每次调用poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></li><li><strong>poll返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</strong></li><li><strong>poll的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次poll调用还是会将这些文件描述符通知进程。</strong></li></ol><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>​       epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用B+树数据结构实现)。把原先的select/poll调用分成了3个部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</span><br><span class="line"><span class="number">2.</span> 调用epoll_ctl向epoll对象中添加这<span class="number">100</span>万个连接的套接字</span><br><span class="line"><span class="number">3.</span> 调用epoll_wait收集发生的事件的连接</span><br></pre></td></tr></table></figure><h2 id="creat"><a href="#creat" class="headerlink" title="creat"></a>creat</h2><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>&#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p><h1 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h1><p>创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket。以添加socket为例，如下图，如果通过epoll_ctl添加sock1、sock2和sock3的监视，内核会将eventpoll添加到这三个socket的等待队列中。</p><p><img src="https://picb.zhimg.com/80/v2-b49bb08a6a1b7159073b71c4d6591185_720w.jpg" alt="添加所要监听的socket"></p><p>当socket收到数据后，中断程序会操作eventpoll对象，而不是直接操作进程。</p><p>而所有<strong>添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法</strong>。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p><p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20150304162309832" alt=""></p><p>上图应该是链表</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>​     当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p><h2 id="epoll解决select的缺点"><a href="#epoll解决select的缺点" class="headerlink" title="epoll解决select的缺点"></a>epoll解决select的缺点</h2><ol><li>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</li><li>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把当前进程轮流加入fd对应的socket等待队列中，而只在epoll_ctl时把当前线程挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的socket时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd。</li><li>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</li></ol><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>简单来讲，LT是epoll的默认操作模式，当epoll_wait函数检测到有事件发生并将通知应用程序，而应用程序不一定必须立即进行处理，这样epoll_wait函数再次检测到此事件的时候还会通知应用程序，直到事件被处理。</p><p>而ET模式，只要epoll_wait函数检测到事件发生，通知应用程序立即进行处理，后续的epoll_wait函数将不再检测此事件。因此ET模式在很大程度上降低了同一个事件被epoll触发的次数，因此效率比LT模式高。</p><h3 id="解释为什么epoll默认是LT的原因"><a href="#解释为什么epoll默认是LT的原因" class="headerlink" title="解释为什么epoll默认是LT的原因"></a>解释为什么epoll默认是LT的原因</h3><p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p><p><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">epoll详解</a></p><p><a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;​      select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。&lt;strong&gt;但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的&lt;/strong&gt;，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode494 目标和</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/05/leetcode494-%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/05/leetcode494-%E7%9B%AE%E6%A0%87%E5%92%8C/</id>
    <published>2020-09-05T14:45:58.000Z</published>
    <updated>2020-09-05T14:52:48.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>把所有符号为正的数总和设为一个背包的容量，容量为x；</li><li>把所有符号为负的数总和设为一个背包的容量，容量为y。</li><li>在给定的数组中，有多少种选择方法让背包装满。令sum为数组的总和，则x+y = sum。而两个背包的差为S,则x-y=S。从而求得x=(S+sum)/2。</li><li>基于上述分析，题目转换为背包问题：给定一个数组和一个容量为x的背包，求有多少种方式让背包装满。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 背包容量为整数，sum+S为奇数的话不满足要求</span></span><br><span class="line">        <span class="keyword">if</span> ((sum+S)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标和不可能大于总和</span></span><br><span class="line">        <span class="keyword">if</span> (S&gt;sum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = (sum+S)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=len;i&gt;=num;--i)&#123;</span><br><span class="line">                dp[i] += dp[i-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。&lt;/p&gt;
&lt;p&gt;返回可以使最终数组和为目标数 S 的所有添加符号的方法数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums: [1, 1, 1, 1, 1], S: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-1+1+1+1+1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+1-1+1+1+1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+1+1-1+1+1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+1+1+1-1+1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+1+1+1+1-1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一共有5种方法让最终目标和为3。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode31 下一个排列</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/05/leetcode31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/05/leetcode31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2020-09-05T14:35:29.000Z</published>
    <updated>2020-09-05T14:52:48.259Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">来源</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p><p>1,2,3 —-&gt; 1,3,2</p><p>3,2,1——&gt;1,2,3</p><p>1,1,5——&gt;1,5,1</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。</li><li>我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：<ul><li>在尽可能靠右的低位进行交换，需要从后向前查找</li><li>将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</li><li>将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</li></ul></li></ol><ol><li>从后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] &lt; A[j]。</li><li>此时 [j,end) 必然是降序在 [j,end) 从后向前查找第一个满足 A[i] &lt; A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」</li><li>将 A[i] 与 A[k] 交换</li><li>可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序</li><li>如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4</li></ol><p><a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/" target="_blank" rel="noopener">思路来源</a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>,num = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                num = nums[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=n-<span class="number">1</span>;k&gt;=pos;k--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; num)&#123;</span><br><span class="line">                nums[pos-<span class="number">1</span>] = nums[k];</span><br><span class="line">                nums[k] = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = pos,r = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &gt; nums[r])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[l];</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                nums[r] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[r];</span><br><span class="line">                nums[r] = nums[l];</span><br><span class="line">                nums[l] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;p&gt;如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。&lt;/p&gt;
&lt;p&gt;必须原地修改，只允许使用额外常数空间。&lt;/p&gt;
&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;/p&gt;
&lt;p&gt;1,2,3 —-&amp;gt; 1,3,2&lt;/p&gt;
&lt;p&gt;3,2,1——&amp;gt;1,2,3&lt;/p&gt;
&lt;p&gt;1,1,5——&amp;gt;1,5,1&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode 160 相交链表</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/05/leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/05/leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2020-09-05T14:30:44.000Z</published>
    <updated>2020-09-05T14:52:48.237Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">来源</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>编写一个程序，找到两个单链表相交的起始节点。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果两个链表相交，那么相交点之后的长度是相同的</p><p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p><ul><li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li><li>如果 pA 到了末尾，则 pA = headB 继续遍历</li><li>如果 pB 到了末尾，则 pB = headA 继续遍历</li><li>比较长的链表指针指向较短链表head时，长度差就消除了</li><li>如此，只需要将最短链表遍历两次即可找到位置</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode hA = headA;</span><br><span class="line">        ListNode hB = headB;</span><br><span class="line">        <span class="keyword">while</span>(hA!=<span class="keyword">null</span> &amp;&amp; hB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hA == hB)&#123;</span><br><span class="line">                ans.next = hA;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hA = hA.next;</span><br><span class="line">            hB = hB.next;</span><br><span class="line">            <span class="keyword">if</span>(hA == <span class="keyword">null</span> &amp;&amp; hB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                hA = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(hB == <span class="keyword">null</span> &amp;&amp; hA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                hB = headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>面经整理</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/03/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/03/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</id>
    <published>2020-09-03T07:26:54.000Z</published>
    <updated>2020-09-08T10:38:29.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HASHMAP"><a href="#HASHMAP" class="headerlink" title="HASHMAP"></a>HASHMAP</h1><ol><li><p>HashMap 底层数据结构？为什么不直接用红黑树，还要用链表？</p></li><li><p>HashMap 什么时候扩容？装载因子和临界值默认是多少？扩容成多大？为什么容量是2的幂次方？</p><p>（定位到哈希桶数组的位置）</p></li><li><p>线程安全的Map？分段锁是如何实现的？JDK 1.8之后有哪些优化？</p></li><li><p>HashMap 的线程安全性</p></li><li><p>hashmap的实现，怎么扩容的</p></li><li><p>Hashmap扩容机制，为什么hashmap定义时一般初始化一个大小？</p></li></ol><a id="more"></a><h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><ol><li>finally 中 return 会发生什么？</li><li>Java参数传递是值传递还是引用传递并举例说明。</li><li>有哪些常见的Exception，怎么避免空指针异常</li><li>ArrayList、LinkedList</li><li>ArrayList源码相关，怎么扩容的，扩容是不是一定1.5倍？</li><li>说一下你知道的Java 8新特性</li><li>Java8中JVM运行时数据区</li><li>说一下Java方法执行的过程，说详细一点。（说到栈帧由局部变量表，操作数栈，动态链接，方法出口组成，他还让我说再详细一点，最好说到字节码的级别，就只随便扯了扯。实在是不会啊……）</li></ol><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ol><li>线程池实现原理？实现方式？拒绝策略？阻塞队列？</li><li>并发？Lock和Synchronized区别？AQS实现？锁优化？</li><li>synchronized原理</li><li>volatile</li><li>多线程的优缺点</li><li>多线程会产生的问题？死锁？（怎么解决死锁）内存泄露？（如何解决内存泄露，举个例子，我：Threadlocal，不会解决）</li><li>有哪些锁？讲一下乐观锁和悲观锁的区别</li><li>公平锁与非公平锁是怎么实现的，使用非公平锁，当前获取不到锁，加入等待队列，之后会怎么处理？</li></ol><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol><li>堆内部空间的划分？</li><li>垃圾回收算法？垃圾回收器？CMS？</li><li>类加载？双亲委派？为什么？破坏双亲委派？</li><li>一个父类加载器能不能加载一个子类加载器，为什么</li><li>java 对象的创建过程</li><li>一个16G的内存堆分配多少，采用什么垃圾收集器，为什么用cms不用g1</li><li>垃圾回收为什么分区？分为几个区？各区的占比？为什么要survior区？survior为什么分为from和to区？ </li><li>如何减少Full GC的次数，比较消耗内存？（不会，面试官说增大老年区内存大小，可以设置）</li><li>垃圾回收 在 堆里怎么做的</li><li>jvm实时的加载一个jar包，发生了什么，类加载器做了，jvm发生了什么变化，他会做什么事。</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ol><li>对数据库三范式的理解，并举例实际的例子说明为什么不满足</li><li>MySQL中有一张表，id和name，name有很多重复行，怎么去除重复的数据？</li><li>怎么防止SQL注入，举一个SQL注入的实例</li><li>索引怎么优化</li><li>B+树为什么适合做索引？和红黑树，B树相比，优点是什么（我自己总结了四点，从速度、稳定性、区间查询、全表扫描来分析）</li><li>Mysql的存储引擎？</li><li>数据库的隔离级别？每一级别出现的问题？</li><li>解释下聚簇索引和非聚簇索引</li><li>如果有abc联合索引，只查c会怎样，只查ac会怎样，为什么</li><li>联合索引底层结构</li><li>非聚簇索引会查几次</li><li>数据库是如何做范围读取的？mysql中记录是如何存储的</li><li>如何保证数据库断电不丢失？redo日志，先写日志，掉电了，如何确定数据有没有写到盘上。redo日志重做的细节（如何确定数据有没有写到盘上:  查看页结构File Header 头部的Fil_Page_LSN字段是否在checkpoint_lsn之后）</li><li>回表机制</li><li>explain</li><li>讲一下char和varchar的区别？优缺点？索引用char还是varchar好</li></ol><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ol><li>关闭浏览器之后重新输入url后，还会保存登录信息吗</li><li>http get/post区别</li><li>HTTP原理</li><li>tcp三次握手之后如果客户端断网了怎么办</li><li>tcp三次握手</li><li>http长短连接</li><li>TCP CLOSE_WAIT什么时候出现，什么时候不出现。TIME_WAIT什么时候出现？</li><li>域名怎么映射到服务器上</li><li><a href="https://www.cnblogs.com/jokerbj/p/11278067.html" target="_blank" rel="noopener">SYN泛洪攻击原理及防御</a></li><li>socket是干嘛的</li></ol><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ol><li>进程间的通信方式</li><li>共享内存</li><li>协程</li><li>解释虚拟内存</li><li>缺页中断</li><li>线程之间的调度策略</li><li>用户态和内核态，为什么要划分？内存上怎么划分的？</li><li>进程中被共享的内存资源，线程自己的内存资源</li><li>怎么由用户态转到内核态？</li><li>用户程序使用系统调用是怎么做的，能否直接进行系统调用？</li><li>操作系统32位和64位有什么区别</li></ol><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><ol><li>redis基本数据类型</li><li>怎么实现分布式锁</li><li>redis分布式锁有什么缺点，怎么解决</li><li>Redis 集群 主从</li><li>布隆过滤器</li><li>Redis缓存怎么更新,以及怎么保证和数据库的一致性</li><li>zset和list使用上的区别</li><li>zset底层结构，如何实现范围查找</li><li>Redis 发布订阅模式如何实现</li><li>redis 的zset，跳表的底层数据结构，实现原理，为什么用这个，怎么查找插入</li><li>redis写一个kv是原子的吗？什么是原子性。</li><li>redis持久化是怎么做的</li></ol><h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><ol><li>spring一个事务中调用另外一个事务，另一个事务发生异常会怎么样</li><li>Bean的生命周期是什么</li><li>Spring运用了哪些设计模式（ioc单例、aop动态代理）</li><li>Spring AOP默认的动态代理是什么？想使用CGlib怎么设置（配置文件）？</li><li>什么时候用JDK动态代理，什么时候用CGlib动态代理？</li><li>Spring IOC底层实现？工厂+反射。</li><li>BeanFactory和ApplicationContext的区别是什么？</li><li>SpringBoot 启动流程，与 Spring 的区别</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>海量数据求频率最多的100个</li><li>select和epoll的区别</li><li>红黑树是如何旋转调整的？红黑树的性质？各种操作的时间复杂度？</li><li>快排具体实现，最差情况下时间复杂度，什么情况是最差情况</li><li>加密算法说几个</li><li>token怎么保证安全</li><li><a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll之间的区别总结</a></li><li><a href="https://www.nowcoder.com/jump/super-jump/word?word=海量数据" target="_blank" rel="noopener">海量数据</a>，查找重复单词（比如有很多文件，找出在这些文件中出现次数最多的单词，怎么做？）</li><li>微信抢红包</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HASHMAP&quot;&gt;&lt;a href=&quot;#HASHMAP&quot; class=&quot;headerlink&quot; title=&quot;HASHMAP&quot;&gt;&lt;/a&gt;HASHMAP&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;HashMap 底层数据结构？为什么不直接用红黑树，还要用链表？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HashMap 什么时候扩容？装载因子和临界值默认是多少？扩容成多大？为什么容量是2的幂次方？&lt;/p&gt;
&lt;p&gt;（定位到哈希桶数组的位置）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程安全的Map？分段锁是如何实现的？JDK 1.8之后有哪些优化？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HashMap 的线程安全性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hashmap的实现，怎么扩容的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hashmap扩容机制，为什么hashmap定义时一般初始化一个大小？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://sqwyyy.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>redis的bitmap</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/02/redis%E7%9A%84bitmap/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/02/redis%E7%9A%84bitmap/</id>
    <published>2020-09-02T11:36:21.000Z</published>
    <updated>2020-09-03T08:01:41.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BitMap是什么"><a href="#BitMap是什么" class="headerlink" title="BitMap是什么"></a>BitMap是什么</h1><p>​      就是通过一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道<strong>8个bit可以组成一个Byte</strong>，所以bitmap本身会极大的节省储存空间。</p><a id="more"></a><h1 id="Redos的BitMap"><a href="#Redos的BitMap" class="headerlink" title="Redos的BitMap"></a>Redos的BitMap</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br><span class="line"></span><br><span class="line">get key offset</span><br><span class="line"></span><br><span class="line">bitcount key start end&#x2F;&#x2F;获取key中start到end字节 值为1的个数</span><br><span class="line"></span><br><span class="line">BITOP AND destkey key [key ...]  ，对一个或多个key求逻辑并，并将结果保存到destkey</span><br><span class="line"></span><br><span class="line">BITOP OR destkey key [key ...] ，对一个或多个key求逻辑或，并将结果保存到destkey</span><br><span class="line"></span><br><span class="line">BITOP XOR destkey key [key ...] ，对一个或多个key求逻辑异或，并将结果保存到destkey</span><br><span class="line"></span><br><span class="line">BITOP NOT destkey key ，对给定key求逻辑非，并将结果保存到destkey</span><br></pre></td></tr></table></figure><ul><li><p>value的值只能是0或者1</p></li><li><p>bitcount的start和end指的是byte为单位</p><ul><li>比如 K1 【01000001 01000000 00000000 00100001】，对应【0，1，2，3】</li><li>bitcount K1 1 2 ： 统计下标1、2字节组中bit=1的个数，即01000000 00000000</li></ul></li><li><p>bitop操作</p><ul><li><p>```txt<br>redis&gt; SETBIT bits-1 0 1        # bits-1 = 1001<br>(integer) 0</p><p>redis&gt; SETBIT bits-1 3 1<br>(integer) 0</p><p>redis&gt; SETBIT bits-2 0 1        # bits-2 = 1011<br>(integer) 0</p><p>redis&gt; SETBIT bits-2 1 1<br>(integer) 0</p><p>redis&gt; SETBIT bits-2 3 1<br>(integer) 0</p><p>redis&gt; BITOP AND and-result bits-1 bits-2<br>(integer) 1</p><p>redis&gt; GETBIT and-result 0      # and-result = 1001<br>(integer) 1</p><p>redis&gt; GETBIT and-result 1<br>(integer) 0</p><p>redis&gt; GETBIT and-result 2<br>(integer) 0</p><p>redis&gt; GETBIT and-result 3<br>(integer) 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[bitcount注意事项](https:&#x2F;&#x2F;blog.csdn.net&#x2F;u011957758&#x2F;article&#x2F;details&#x2F;74783347)</span><br><span class="line"></span><br><span class="line">## 用户签到</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;txt</span><br><span class="line">127.0.0.1:6379&gt; setbit 2020902 123 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit 2020901 121 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit 20200901 121</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>key设置为年月日</p><p>offset设置为用户id</p><h2 id="用户在线"><a href="#用户在线" class="headerlink" title="用户在线"></a>用户在线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit online 123 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit online 121 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit online 121</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li><p>使用bitmap是一个节约空间效率又高的一种方法，只需要一个key，然后用户ID为offset，如果在线就设置为1</p></li><li><p>如果两亿的数字做排序排重，我们大概要占用好几G的空间，如果用bitmap方式，最少只需要200000000/8/1024= 24M的空间就够了</p></li></ul><h2 id="统计七天内登陆果的活跃用户"><a href="#统计七天内登陆果的活跃用户" class="headerlink" title="统计七天内登陆果的活跃用户"></a>统计七天内登陆果的活跃用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit Monday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Monday 8298191 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Tuesday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Tuesday 8892198 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Wednesday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Wednesday 8892198 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Thursday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Thursday 8892198 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Friday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Friday 8892198 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Saturday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Saturday 8892198 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Sunday 8987129 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit Sunday 8892198 0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>最后计算7天内登录过的活跃用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitop OR result Monday Tuesday Wednesday Thursday Friday Saturday Sunday</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BitMap是什么&quot;&gt;&lt;a href=&quot;#BitMap是什么&quot; class=&quot;headerlink&quot; title=&quot;BitMap是什么&quot;&gt;&lt;/a&gt;BitMap是什么&lt;/h1&gt;&lt;p&gt;​      就是通过一个bit位来表示某个元素对应的值或者状态,其中的key就是对应元素本身。我们知道&lt;strong&gt;8个bit可以组成一个Byte&lt;/strong&gt;，所以bitmap本身会极大的节省储存空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/02/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/02/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2020-09-02T07:08:56.000Z</published>
    <updated>2020-09-03T08:01:41.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找vim的进程id"><a href="#查找vim的进程id" class="headerlink" title="查找vim的进程id"></a>查找vim的进程id</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep vim</span><br></pre></td></tr></table></figure><h2 id="强制杀死某个进程"><a href="#强制杀死某个进程" class="headerlink" title="强制杀死某个进程"></a>强制杀死某个进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 id</span><br></pre></td></tr></table></figure><p><strong>ps查看的结果不是动态连续的，想要动态的显示进程信息，就可以用top命令</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查找vim的进程id&quot;&gt;&lt;a href=&quot;#查找vim的进程id&quot; class=&quot;headerlink&quot; title=&quot;查找vim的进程id&quot;&gt;&lt;/a&gt;查找vim的进程id&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://sqwyyy.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>sql语句练习</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/01/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0-1/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/01/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0-1/</id>
    <published>2020-09-01T15:04:25.000Z</published>
    <updated>2020-09-03T08:01:41.958Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>静态变量和实例变量的区别</title>
    <link href="https://sqwyyy.github.io/archives/2020/09/01/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sqwyyy.github.io/archives/2020/09/01/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-09-01T13:11:49.000Z</published>
    <updated>2020-09-01T13:17:11.149Z</updated>
    
    <content type="html"><![CDATA[<p>​       在Java中，静态变量和实例变量可以<strong>统称为成员变量</strong>。首先，明白什么是静态变量，什么是实例变量，他们定义的形式。<strong>静态变量也叫做类变量，独立于方法之外的变量，有static修饰</strong>。<strong>实例变量同样独立也是独立于方法之外 的变量，但没有static修饰</strong>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticInt = <span class="number">2</span>;<span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> random = <span class="number">2</span>;<span class="comment">//实例变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        staticInt++;</span><br><span class="line">        random++;</span><br><span class="line">        System.out.println(<span class="string">"staticInt = "</span>+staticInt+<span class="string">"  random = "</span>+random);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticTest test = <span class="keyword">new</span> StaticTest();</span><br><span class="line">        StaticTest test2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">staticInt &#x3D; 3  random &#x3D; 3</span><br><span class="line">staticInt &#x3D; 4  random &#x3D; 3</span><br></pre></td></tr></table></figure><ul><li><p>实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。结合上述给出的例子。每创建一个实例对象，就会分配一个random，实例对象之间的random是互不影响的，所以就可以解释为什么输出的两个random值是相同的了。</p></li><li><p>静态变量不属于某个实例对象，而是属于整个类。只要程序加载了类的字节码，不用创建任何实例对象，静态变量就回被分配空间，静态变量就可以被使用了。结合上述给出的例子，无论创建多少个实例对象，永远都只分配一个staticInt 变量，并且每创建一个实例对象,staticInt就会加一。</p></li><li><p>总之，实例变量必须创建对象后，才可以通过这个对象来使用；静态变量则可以直接使用类名来引用（如果实例对象存在，也可以通过实例对象来引用）。</p></li></ul><p><a href="https://blog.csdn.net/yong_zi/article/details/81285049" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​       在Java中，静态变量和实例变量可以&lt;strong&gt;统称为成员变量&lt;/strong&gt;。首先，明白什么是静态变量，什么是实例变量，他们定义的形式。&lt;strong&gt;静态变量也叫做类变量，独立于方法之外的变量，有static修饰&lt;/strong&gt;。&lt;strong&gt;实例变量同样独立也是独立于方法之外 的变量，但没有static修饰&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>BigDecimal</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/31/BigDecimal/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/31/BigDecimal/</id>
    <published>2020-08-31T11:44:14.000Z</published>
    <updated>2020-08-31T11:55:28.563Z</updated>
    
    <content type="html"><![CDATA[<p>float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上<strong>提供较为精确的快速近似计算而精心设计的</strong>。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> num1 = <span class="number">0.02</span>;</span><br><span class="line">        <span class="keyword">double</span> num2 = <span class="number">0.03</span>;</span><br><span class="line">        <span class="keyword">double</span> num3 = num2 - num1;</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:0.009999999999999998</p><h1 id="浮点型运算造成精度丢失的原因"><a href="#浮点型运算造成精度丢失的原因" class="headerlink" title="浮点型运算造成精度丢失的原因"></a>浮点型运算造成精度丢失的原因</h1><p>数据最后都是以<strong>二进制的形式存储在计算机中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(1) 十进制整数如何转化为二进制数</span><br><span class="line"> </span><br><span class="line">           算法很简单。举个例子，11表示成二进制数：</span><br><span class="line"> </span><br><span class="line">                     11&#x2F;2&#x3D;5 余   1</span><br><span class="line"> </span><br><span class="line">                       5&#x2F;2&#x3D;2   余   1</span><br><span class="line"> </span><br><span class="line">                       2&#x2F;2&#x3D;1   余   0</span><br><span class="line"> </span><br><span class="line">                       1&#x2F;2&#x3D;0   余   1</span><br><span class="line"> </span><br><span class="line">                          0结束         11二进制表示为(从下往上):1011</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">      (2) 十进制小数如何转化为二进制数</span><br><span class="line"> </span><br><span class="line">           算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数</span><br><span class="line"> </span><br><span class="line">                     0.9*2&#x3D;1.8   取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.8(1.8的小数部分)*2&#x3D;1.6    取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.6*2&#x3D;1.2   取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.2*2&#x3D;0.4   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                     0.4*2&#x3D;0.8   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                     0.8*2&#x3D;1.6 取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.6*2&#x3D;1.2   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                              .........      </span><br><span class="line">                     0.9二进制表示为(从上往下): 1100100100100......</span><br><span class="line"> </span><br><span class="line">           注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分</span><br><span class="line">           这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>当需要某些类型准确表示货币的时候，<strong>BigDecimal</strong>是最为合适的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.02"</span>);</span><br><span class="line">        BigDecimal num2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.03"</span>);</span><br><span class="line">        System.out.println(num1.add(num2));</span><br><span class="line">        System.out.println(num1.subtract(num2));</span><br><span class="line">        System.out.println(num1.multiply(num2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.05</span><br><span class="line">-0.01</span><br><span class="line">0.0006</span><br></pre></td></tr></table></figure><p>数据库中也可以采用decimal类型来定义货币（需要比较精确的数据)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上&lt;strong&gt;提供较为精确的快速近似计算而精心设计的&lt;/strong&gt;。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>double精度不准备问题</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/31/double%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%87%86%E5%A4%87%E9%97%AE%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/31/double%E7%B2%BE%E5%BA%A6%E4%B8%8D%E5%87%86%E5%A4%87%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-31T11:27:13.000Z</published>
    <updated>2020-08-31T11:55:28.570Z</updated>
    
    <content type="html"><![CDATA[<p>​       float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上<strong>提供较为精确的快速近似计算而精心设计的</strong>。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> num1 = <span class="number">0.02</span>;</span><br><span class="line">        <span class="keyword">double</span> num2 = <span class="number">0.03</span>;</span><br><span class="line">        <span class="keyword">double</span> num3 = num2 - num1;</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:0.009999999999999998</p><h1 id="浮点型运算造成精度丢失的原因"><a href="#浮点型运算造成精度丢失的原因" class="headerlink" title="浮点型运算造成精度丢失的原因"></a>浮点型运算造成精度丢失的原因</h1><p>数据最后都是以<strong>二进制的形式存储在计算机中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(1) 十进制整数如何转化为二进制数</span><br><span class="line"> </span><br><span class="line">           算法很简单。举个例子，11表示成二进制数：</span><br><span class="line"> </span><br><span class="line">                     11&#x2F;2&#x3D;5 余   1</span><br><span class="line"> </span><br><span class="line">                       5&#x2F;2&#x3D;2   余   1</span><br><span class="line"> </span><br><span class="line">                       2&#x2F;2&#x3D;1   余   0</span><br><span class="line"> </span><br><span class="line">                       1&#x2F;2&#x3D;0   余   1</span><br><span class="line"> </span><br><span class="line">                          0结束         11二进制表示为(从下往上):1011</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">      (2) 十进制小数如何转化为二进制数</span><br><span class="line"> </span><br><span class="line">           算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数</span><br><span class="line"> </span><br><span class="line">                     0.9*2&#x3D;1.8   取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.8(1.8的小数部分)*2&#x3D;1.6    取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.6*2&#x3D;1.2   取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.2*2&#x3D;0.4   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                     0.4*2&#x3D;0.8   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                     0.8*2&#x3D;1.6 取整数部分 1</span><br><span class="line"> </span><br><span class="line">                     0.6*2&#x3D;1.2   取整数部分 0</span><br><span class="line"> </span><br><span class="line">                              .........      </span><br><span class="line">                     0.9二进制表示为(从上往下): 1100100100100......</span><br><span class="line"> </span><br><span class="line">           注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分</span><br><span class="line">           这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>当需要某些类型准确表示货币的时候，<strong>BigDecimal</strong>是最为合适的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.02"</span>);</span><br><span class="line">        BigDecimal num2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.03"</span>);</span><br><span class="line">        System.out.println(num1.add(num2));</span><br><span class="line">        System.out.println(num1.subtract(num2));</span><br><span class="line">        System.out.println(num1.multiply(num2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.05</span><br><span class="line">-0.01</span><br><span class="line">0.0006</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​       float和double类型主要是为了科学计算和工程计算而设计的。他们执行二进制浮点运算，这是为了在广泛的数字范围上&lt;strong&gt;提供较为精确的快速近似计算而精心设计的&lt;/strong&gt;。然而，它们并没有提供完全精确的结果，所以我们不应该用于精确计算的场合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>三个线程依次输出ABC</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/30/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BE%9D%E6%AC%A1%E8%BE%93%E5%87%BAABC/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/30/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BE%9D%E6%AC%A1%E8%BE%93%E5%87%BAABC/</id>
    <published>2020-08-30T06:54:46.000Z</published>
    <updated>2020-08-31T07:59:49.352Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="采用synchronized"><a href="#采用synchronized" class="headerlink" title="采用synchronized"></a>采用synchronized</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"ABC"</span>;</span><br><span class="line">        Main Main = <span class="keyword">new</span> Main();</span><br><span class="line">        ThreadA threadA = Main.<span class="keyword">new</span> ThreadA();</span><br><span class="line">        ThreadB threadB = Main.<span class="keyword">new</span> ThreadB();</span><br><span class="line">        ThreadC threadC = Main.<span class="keyword">new</span> ThreadC();</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">28</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">29</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印C</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"++++++"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"------"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要采用synchronzied锁住代码块，然后通过volatile变量来控制输出ABC</li></ul><h2 id="采用Lock和Condition"><a href="#采用Lock和Condition" class="headerlink" title="采用Lock和Condition"></a>采用Lock和Condition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionA = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionB = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionC = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main printABC = <span class="keyword">new</span> Main();</span><br><span class="line">        ThreadA threadA = printABC.<span class="keyword">new</span> ThreadA();</span><br><span class="line">        ThreadB threadB = printABC.<span class="keyword">new</span> ThreadB();</span><br><span class="line">        ThreadC threadC = printABC.<span class="keyword">new</span> ThreadC();</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (count%<span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        conditionA.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"A"</span>);</span><br><span class="line">                    count ++;</span><br><span class="line">                    conditionB.signalAll();    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"ThreadA 中执行了 unlock"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (count%<span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">                        conditionB.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"B"</span>);</span><br><span class="line">                    count ++;</span><br><span class="line">                    conditionC.signalAll();                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"ThreadB 中执行了 unlock"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印C</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (count%<span class="number">3</span> != <span class="number">2</span>) &#123;</span><br><span class="line">                        conditionC.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"C"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"+++++++"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">                    count ++;</span><br><span class="line">                    <span class="keyword">if</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                        conditionA.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"ThreadC 中执行了 unlock"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>采用lock和condition结合使用即可</li><li>condition的await相当于Object的wait</li><li>condition的signal对于Object的notify</li><li>Condition中的signalAll()对应Object的notifyAll()</li><li>condition必须要在lock与unlock之间使用</li></ul><p><a href="https://www.jianshu.com/p/e3c6d4a5dd4b" target="_blank" rel="noopener">condition原理讲解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;采用synchronized&quot;&gt;&lt;a href=&quot;#采用synchronized&quot; class=&quot;headerlink&quot; title=&quot;采用synchronized&quot;&gt;&lt;/a&gt;采用synchronized&lt;/h1&gt;&lt;figure
      
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 最大子矩阵</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/30/leetcode-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/30/leetcode-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</id>
    <published>2020-08-30T01:52:59.000Z</published>
    <updated>2020-08-30T02:04:36.228Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/" target="_blank" rel="noopener">题目来源</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个正整数和负整数组成的 N × M 矩阵，编写代码<strong>找出元素总和最大的子矩阵</strong>。</p><p>返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">   [-1,0],</span><br><span class="line">   [0,-1]</span><br><span class="line">]</span><br><span class="line">输出: [0,1,0,1]</span><br><span class="line">解释: 输入中标粗的元素即为输出所表示的矩阵</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>枚举k1与k2确定这个矩阵的高</p><p>然后将k1-k2之间每一列(求出每一列的累计的和)看出一维数组的一项，在其中求最大子数组</p><p>即这个最大子数组的值就是子矩阵的和</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum[n+<span class="number">10</span>][m+<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) sum[i][j] = matrix[i][j];</span><br><span class="line">                <span class="keyword">else</span> sum[i][j] += sum[i<span class="number">-1</span>][j] + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r1,c1,r2,c2,maxx = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k1=<span class="number">0</span>;k1&lt;n;k1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k2=k1;k2&lt;n;k2++)&#123;</span><br><span class="line">                <span class="keyword">int</span> dp[n+<span class="number">10</span>],<span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">compressSum</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k1 == <span class="number">0</span>) compressSum[i] = sum[k2][i];</span><br><span class="line">                    <span class="keyword">else</span> compressSum[i] = sum[k2][i] - sum[k1 - <span class="number">1</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) dp[i] = compressSum[i];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> nums = compressSum[i];</span><br><span class="line">                        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>] + nums, nums);</span><br><span class="line">                        <span class="keyword">if</span> (dp[i] == nums) <span class="built_in">begin</span> = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i] &gt; maxx)&#123;</span><br><span class="line">                        maxx = dp[i];</span><br><span class="line">                        r1 = k1;</span><br><span class="line">                        c1 = <span class="built_in">begin</span>;</span><br><span class="line">                        r2 = k2;</span><br><span class="line">                        c2 = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">        ans.push_back(r1);</span><br><span class="line">        ans.push_back(c1);</span><br><span class="line">        ans.push_back(r2);</span><br><span class="line">        ans.push_back(c2);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/max-submatrix-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目来源&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个正整数和负整数组成的 N × M 矩阵，编写代码&lt;strong&gt;找出元素总和最大的子矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [-1,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [0,-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [0,1,0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 输入中标粗的元素即为输出所表示的矩阵&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="动态规划" scheme="https://sqwyyy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>美团笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/23/%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/23/%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-23T13:47:30.000Z</published>
    <updated>2020-08-23T13:56:15.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并金币"><a href="#合并金币" class="headerlink" title="合并金币"></a>合并金币</h1><p><a href="https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0?f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。  </p><p>其中，1 &lt;= N &lt;= 30，1 &lt;= C[i] &lt;= 100</p><a id="more"></a><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 2 4 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>区间dp</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合并金币&quot;&gt;&lt;a href=&quot;#合并金币&quot; class=&quot;headerlink&quot; title=&quot;合并金币&quot;&gt;&lt;/a&gt;合并金币&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0?f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。  &lt;/p&gt;
&lt;p&gt;其中，1 &amp;lt;= N &amp;lt;= 30，1 &amp;lt;= C[i] &amp;lt;= 100&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节2020春招笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/18/%E5%AD%97%E8%8A%822020%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/18/%E5%AD%97%E8%8A%822020%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-18T14:10:30.000Z</published>
    <updated>2020-08-23T15:12:59.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="万万没想到之抓捕孔连顺"><a href="#万万没想到之抓捕孔连顺" class="headerlink" title="万万没想到之抓捕孔连顺"></a>万万没想到之抓捕孔连顺</h1><p><a href="https://www.nowcoder.com/questionTerminal/c0803540c94848baac03096745b55b9b?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议</p><ol><li><p>我们在字节跳动大街的N个建筑中选定3个埋伏地点。</p></li><li><p>为了相互照应，我们决定相距最远的两名特工间的距离不超过D。</p></li></ol><p>我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！</p><p>……</p><p>万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！</p><p>请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。</p><p>注意：</p><ol><li><p>两个特工不能埋伏在同一地点</p></li><li><p>三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用</p></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每读取一个数字，就判断窗口是否满足最大值减去最小值不大于距离D；<br>由于每次进行计算组合之后，窗口的begin都会往前移动一位，所以计算组合应该采用固定首位的方法，即固定首位有一人，接下来的位置的可能性，这样就可以保证窗口移动过程不会出现重复，因为下一次判断已经不包含上一个的首位置了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n<span class="number">-1</span>) * n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, D; <span class="built_in">cin</span>&gt;&gt; N &gt;&gt; D;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>, <span class="built_in">begin</span> = <span class="number">0</span>; <span class="built_in">end</span> &lt; N; <span class="built_in">end</span>++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; res[<span class="built_in">end</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">end</span> &gt;= <span class="number">2</span> &amp;&amp; (res[<span class="built_in">end</span>] - res[<span class="built_in">begin</span>]) &gt; D) &#123;</span><br><span class="line">            <span class="built_in">begin</span>++;<span class="comment">//不满足则begin往前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        count += C(<span class="built_in">end</span> - <span class="built_in">begin</span>);<span class="comment">//由于判断一次往前移动（for循环中的end++），即可以采用每次固定首位的组合。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count % <span class="number">99997867</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="雀魂启动！"><a href="#雀魂启动！" class="headerlink" title="雀魂启动！"></a>雀魂启动！</h1><p><a href="https://www.nowcoder.com/questionTerminal/448127caa21e462f9c9755589a8f2416?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。</p><p>于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下：</p><ol><li>总共有36张牌，每张牌是1~9。每个数字4张牌。</li><li>你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌</li></ol><ul><li>14张牌中有2张相同数字的牌，称为雀头。</li><li>除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777）</li></ul><p>例如：</p><p>1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌</p><p>1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌</p><p>1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。</p><p>现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>依次尝试加入0~9的其中一个数字然后对其14个数字进行dfs判定是否可以和牌，符合和牌规则的加入答案</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>], helpArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">            state[num - <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state[i] &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = i + <span class="number">1</span>;</span><br><span class="line">                System.arraycopy(state, <span class="number">0</span>, helpArr, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">                helpArr[i]++;</span><br><span class="line">                <span class="keyword">if</span> (canHu(helpArr, <span class="number">14</span>, <span class="keyword">false</span>)) res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.isEmpty()) System.out.println(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuffer sbf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            sbf.append(res.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">                sbf.append(<span class="string">" "</span>);</span><br><span class="line">                sbf.append(res.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sbf.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canHu</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> total, <span class="keyword">boolean</span> hasHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (total == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasHead) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    arr[i] -= <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (canHu(arr, total - <span class="number">2</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    arr[i] += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[i] &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        arr[i] -= <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">if</span> (canHu(arr, total - <span class="number">3</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        arr[i] += <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> &lt; <span class="number">9</span> &amp;&amp; arr[i + <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; arr[i + <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        arr[i]--;</span><br><span class="line">                        arr[i + <span class="number">1</span>]--;</span><br><span class="line">                        arr[i + <span class="number">2</span>]--;</span><br><span class="line">                        <span class="keyword">if</span> (canHu(arr, total - <span class="number">3</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        arr[i]++;</span><br><span class="line">                        arr[i + <span class="number">1</span>]++;</span><br><span class="line">                        arr[i + <span class="number">2</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().sln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="毕业旅行问题"><a href="#毕业旅行问题" class="headerlink" title="毕业旅行问题"></a>毕业旅行问题</h1><p><a href="https://www.nowcoder.com/questionTerminal/3d1adf0f16474c90b27a9954b71d125d?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><p>超时只过50%</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">99997867</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pr&gt;g[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn],mpt[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1e5</span>,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep,<span class="keyword">int</span> s,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(total&gt;ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;<span class="number">1</span> &amp;&amp; s==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;=n)&#123;</span><br><span class="line">        total += mpt[s][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;total&lt;&lt;endl;</span></span><br><span class="line">        ans = <span class="built_in">min</span>(total,ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[s])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v.first])&#123;</span><br><span class="line">            vis[v.first] = <span class="number">1</span>;</span><br><span class="line">            dfs(dep+<span class="number">1</span>,v.first,total+v.second);</span><br><span class="line">            vis[v.first] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> price;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;price;</span><br><span class="line">            mpt[i][j] = price;</span><br><span class="line">            <span class="keyword">if</span>(j == i) <span class="keyword">continue</span>;</span><br><span class="line">            g[i].push_back(make_pair(j,price));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="机器人跳跃问题"><a href="#机器人跳跃问题" class="headerlink" title="机器人跳跃问题"></a>机器人跳跃问题</h1><p><a href="https://www.nowcoder.com/questionTerminal/7037a3d57bbd4336856b8e16a9cafd71?f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 </p><p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) &gt; E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。</p><p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>假设跳跃前能力为E,要跳的高度为H，那么跳跃后的能量就是2E-H，那么跳跃后的能量加上高度就是跳跃前的两倍，然后从后往前逆推。假设跳到最后一步的能力值设为0</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">99997867</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        ans = (ans+a[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2020-8-23第一题"><a href="#2020-8-23第一题" class="headerlink" title="2020.8.23第一题"></a>2020.8.23第一题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个n，l，r。构造一个长度为n的数组</p><ol><li>数组的元素的值a[i]需要在区间(l,r)之内</li><li>数组元素之和能与3相余为0</li></ol><p>则构造此数组的方法有多少种，答案模1e9+7</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><strong>dp(i,j)表示以a[i]为结尾且（数组和）%3=j的数组个数</strong>。</p><p>由于a[i]的可选值属于[l,r]，因此先算出[l,r]内%3=0，%3=1，%3=2的数的数量，分别记为x0,x1,x2。那么转移方程为</p><p>dp(i,0)= (dp(i-1,0)<em>x0%mod + dp(i-1,1)</em>x2%mod + dp(i-1,2)*x1%mod)%mod</p><p>dp(i,1)和dp(i,2)的类似</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>],b[<span class="number">3</span>],dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,l,r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">int</span> len = (r-l+<span class="number">1</span>);</span><br><span class="line">    a[<span class="number">0</span>] = l/<span class="number">3</span>;</span><br><span class="line">    a[<span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">    a[<span class="number">2</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(l%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">        a[<span class="number">1</span>]++;</span><br><span class="line">        a[<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        a[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">0</span>] = r/<span class="number">3</span>;</span><br><span class="line">    b[<span class="number">1</span>] = b[<span class="number">0</span>];</span><br><span class="line">    b[<span class="number">2</span>] = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(r%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">        b[<span class="number">1</span>]++;</span><br><span class="line">        b[<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        b[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x0 = b[<span class="number">0</span>] - a[<span class="number">0</span>], x1 = b[<span class="number">1</span>] - a[<span class="number">1</span>] , x2 = b[<span class="number">2</span>] - a[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = x0;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = x1;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = x2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] += dp[i<span class="number">-1</span>][<span class="number">0</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">1</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">1</span>] += dp[i<span class="number">-1</span>][<span class="number">1</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">0</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">2</span>] += dp[i<span class="number">-1</span>][<span class="number">2</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">0</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">1</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">0</span>] %= mod;</span><br><span class="line">        dp[i][<span class="number">1</span>] %= mod;</span><br><span class="line">        dp[i][<span class="number">2</span>] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;万万没想到之抓捕孔连顺&quot;&gt;&lt;a href=&quot;#万万没想到之抓捕孔连顺&quot; class=&quot;headerlink&quot; title=&quot;万万没想到之抓捕孔连顺&quot;&gt;&lt;/a&gt;万万没想到之抓捕孔连顺&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/c0803540c94848baac03096745b55b9b?answerType=1&amp;amp;f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>final</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/17/final/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/17/final/</id>
    <published>2020-08-17T09:58:39.000Z</published>
    <updated>2020-08-17T10:21:28.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h1><p>final关键字是用来修饰Java中的变量，方法，类的。修饰变量表示这个变量引用的地址不能变化，修饰方法表示这个方法不可覆盖，修饰类表示这个类无法继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;final关键字的作用&quot;&gt;&lt;a href=&quot;#final关键字的作用&quot; class=&quot;headerlink&quot; title=&quot;final关键字的作用&quot;&gt;&lt;/a&gt;final关键字的作用&lt;/h1&gt;&lt;p&gt;final关键字是用来修饰Java中的变量，方法，类的。修饰变量表示
      
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="final" scheme="https://sqwyyy.github.io/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBffuer、StringBuilder</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/17/String%E3%80%81StringBffuer%E3%80%81StringBuilder/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/17/String%E3%80%81StringBffuer%E3%80%81StringBuilder/</id>
    <published>2020-08-17T08:31:16.000Z</published>
    <updated>2020-08-17T13:00:21.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p> 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ <strong>可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的</strong>。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><a id="more"></a><p><strong>区分对象和对象引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);  </span><br><span class="line"></span><br><span class="line">s = <span class="string">"123456"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>首先创建一个String对象s，然后让s的值为“ABCabc”， 然后又让s的值为“123456”。 从打印结果可以看出，s的值确实改变了。那么怎么还说String对象是不可变的呢？ 其实这里存在一个误区： ==s只是一个String对象的引用，并不是对象本身。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。==</p><p>也就是说，s只是一个引用，它指向了一个具体的对象，当s=“123456”; 这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个新的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。</p><h1 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h1><p>​      StringBuffer 和 StringBuilder 都继承<strong>抽象类AbstractStringBuilder</strong>。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><hr><p>​     StringBuilder 类在 Java 5 中被提出，它和 <strong>StringBuffer</strong> 之间的最大不同在于 StringBuilder 的方法<strong>不是线程安全</strong>的（不能同步访问）。</p><hr><h2 id="StringBuiler为什么线程安全以及StringBuffer为什么线程不安全"><a href="#StringBuiler为什么线程安全以及StringBuffer为什么线程不安全" class="headerlink" title="StringBuiler为什么线程安全以及StringBuffer为什么线程不安全"></a>StringBuiler为什么线程安全以及StringBuffer为什么线程不安全</h2><p>以StringBuilder的append()方法为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>.    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">3</span>.        <span class="keyword">return</span> appendNull();</span><br><span class="line"><span class="number">4</span>.    <span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="number">5</span>.    ensureCapacityInternal(count + len);</span><br><span class="line"><span class="number">6</span>.    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line"><span class="number">7</span>.    count += len;</span><br><span class="line"><span class="number">8</span>.    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">9</span>.&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p><strong>count += len不是一个原子操作.</strong><br>假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12</p></li><li><p>ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容</p></li><li><p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面.</p></li></ol><p><strong>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count=5。</strong><br><strong>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</strong></p><hr><p><strong>StringBuffer则根据synchronized关键字实现线程安全</strong></p><p><a href="https://zhuanlan.zhihu.com/p/85867299" target="_blank" rel="noopener">来源1</a><br><a href="https://blog.csdn.net/u011702479/article/details/82262823" target="_blank" rel="noopener">来源2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;p&gt; 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ &lt;strong&gt;可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的&lt;/strong&gt;。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/categories/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Sting" scheme="https://sqwyyy.github.io/tags/Sting/"/>
    
  </entry>
  
  <entry>
    <title>腾讯2020校招笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/16/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/16/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-16T05:58:44.000Z</published>
    <updated>2020-08-23T13:58:10.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逛街"><a href="#逛街" class="headerlink" title="逛街"></a>逛街</h1><p><a href="https://www.nowcoder.com/questionTerminal/35fac8d69f314e958a150c141894ef6a?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。</p><p>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用单调栈实现，开辟一个数组rightLook 保留往右看得到的数量，从右往左遍历，利用单调栈将看得到的数量保留在数组 rightLook 中 ，再从左往右遍历，获取往左看的计数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r[maxn],a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">     r[i] = q.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>(!q.empty() &amp;&amp; a[i] &gt;= a[q.top()])&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">     &#125;</span><br><span class="line">     q.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">     <span class="keyword">int</span> num = r[i] + <span class="number">1</span> + q.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>(!q.empty() &amp;&amp; a[i] &gt;= a[q.top()])&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">     q.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="假期"><a href="#假期" class="headerlink" title="假期"></a>假期</h1><p><a href="https://www.nowcoder.com/questionTerminal/7cd9a140387e455a972e8fea0e74be2c?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>dp(i,0) , dp(i,1), dp(i,2) 分别记录第i天 休息/锻炼/工作 累计的最小休息天数</p><p>如果第i天休息，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,1), dp(i,2)中的最小值+1</p><p>如果第i天工作，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,1)中的最小值</p><p>如果第i天健身，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,2)中的最小值</p><p>答案就是dp(n,0) , dp(n,1), dp(n,2)中的最小值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( b[i] == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="comment">// 可以锻炼</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">min</span>( dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( a[i] == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="comment">// 可以工作</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">min</span>( dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], <span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">min</span>(dp[n][<span class="number">0</span>], <span class="built_in">min</span>(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="视野争夺"><a href="#视野争夺" class="headerlink" title="视野争夺"></a>视野争夺</h1><p><a href="https://www.nowcoder.com/questionTerminal/61e1e66e39f348cdb6495de91ac36a41?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。</p><p>这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。 </p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>根据贪心算法，将数组按照左节点排序</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;逛街&quot;&gt;&lt;a href=&quot;#逛街&quot; class=&quot;headerlink&quot; title=&quot;逛街&quot;&gt;&lt;/a&gt;逛街&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/35fac8d69f314e958a150c141894ef6a?answerType=1&amp;amp;f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-03T13:43:27.000Z</published>
    <updated>2020-08-12T15:02:58.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h1><h2 id="内存的含义"><a href="#内存的含义" class="headerlink" title="内存的含义"></a>内存的含义</h2><p><strong>内存就是用于存放数据的硬件。程序执行前需要放到内存中才能被CPU处理。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存的基础知识&quot;&gt;&lt;a href=&quot;#内存的基础知识&quot; class=&quot;headerlink&quot; title=&quot;内存的基础知识&quot;&gt;&lt;/a&gt;内存的基础知识&lt;/h1&gt;&lt;h2 id=&quot;内存的含义&quot;&gt;&lt;a href=&quot;#内存的含义&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存管理" scheme="https://sqwyyy.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
