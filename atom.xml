<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-08-30T13:01:27.133Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三个线程依次输出ABC</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/30/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BE%9D%E6%AC%A1%E8%BE%93%E5%87%BAABC/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/30/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BE%9D%E6%AC%A1%E8%BE%93%E5%87%BAABC/</id>
    <published>2020-08-30T06:54:46.000Z</published>
    <updated>2020-08-30T13:01:27.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="采用synchronized"><a href="#采用synchronized" class="headerlink" title="采用synchronized"></a>采用synchronized</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"ABC"</span>;</span><br><span class="line">        Main Main = <span class="keyword">new</span> Main();</span><br><span class="line">        ThreadA threadA = Main.<span class="keyword">new</span> ThreadA();</span><br><span class="line">        ThreadB threadB = Main.<span class="keyword">new</span> ThreadB();</span><br><span class="line">        ThreadC threadC = Main.<span class="keyword">new</span> ThreadC();</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">28</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">29</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印C</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LKB</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String str;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count &lt; <span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count%<span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"++++++"</span>);</span><br><span class="line">                        System.out.println(<span class="string">"------"</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要采用synchronzied锁住代码块，然后通过volatile变量来控制输出ABC</li></ul><h2 id="采用Lock和Condition"><a href="#采用Lock和Condition" class="headerlink" title="采用Lock和Condition"></a>采用Lock和Condition</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;采用synchronized&quot;&gt;&lt;a href=&quot;#采用synchronized&quot; class=&quot;headerlink&quot; title=&quot;采用synchronized&quot;&gt;&lt;/a&gt;采用synchronized&lt;/h1&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 最大子矩阵</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/30/leetcode-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/30/leetcode-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</id>
    <published>2020-08-30T01:52:59.000Z</published>
    <updated>2020-08-30T02:04:36.228Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/" target="_blank" rel="noopener">题目来源</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个正整数和负整数组成的 N × M 矩阵，编写代码<strong>找出元素总和最大的子矩阵</strong>。</p><p>返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">   [-1,0],</span><br><span class="line">   [0,-1]</span><br><span class="line">]</span><br><span class="line">输出: [0,1,0,1]</span><br><span class="line">解释: 输入中标粗的元素即为输出所表示的矩阵</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>枚举k1与k2确定这个矩阵的高</p><p>然后将k1-k2之间每一列(求出每一列的累计的和)看出一维数组的一项，在其中求最大子数组</p><p>即这个最大子数组的值就是子矩阵的和</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum[n+<span class="number">10</span>][m+<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) sum[i][j] = matrix[i][j];</span><br><span class="line">                <span class="keyword">else</span> sum[i][j] += sum[i<span class="number">-1</span>][j] + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r1,c1,r2,c2,maxx = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k1=<span class="number">0</span>;k1&lt;n;k1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k2=k1;k2&lt;n;k2++)&#123;</span><br><span class="line">                <span class="keyword">int</span> dp[n+<span class="number">10</span>],<span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">compressSum</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k1 == <span class="number">0</span>) compressSum[i] = sum[k2][i];</span><br><span class="line">                    <span class="keyword">else</span> compressSum[i] = sum[k2][i] - sum[k1 - <span class="number">1</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) dp[i] = compressSum[i];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> nums = compressSum[i];</span><br><span class="line">                        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>] + nums, nums);</span><br><span class="line">                        <span class="keyword">if</span> (dp[i] == nums) <span class="built_in">begin</span> = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i] &gt; maxx)&#123;</span><br><span class="line">                        maxx = dp[i];</span><br><span class="line">                        r1 = k1;</span><br><span class="line">                        c1 = <span class="built_in">begin</span>;</span><br><span class="line">                        r2 = k2;</span><br><span class="line">                        c2 = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">        ans.push_back(r1);</span><br><span class="line">        ans.push_back(c1);</span><br><span class="line">        ans.push_back(r2);</span><br><span class="line">        ans.push_back(c2);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/max-submatrix-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目来源&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个正整数和负整数组成的 N × M 矩阵，编写代码&lt;strong&gt;找出元素总和最大的子矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [-1,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [0,-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [0,1,0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 输入中标粗的元素即为输出所表示的矩阵&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="动态规划" scheme="https://sqwyyy.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>美团笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/23/%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/23/%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-23T13:47:30.000Z</published>
    <updated>2020-08-23T13:56:15.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并金币"><a href="#合并金币" class="headerlink" title="合并金币"></a>合并金币</h1><p><a href="https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0?f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。  </p><p>其中，1 &lt;= N &lt;= 30，1 &lt;= C[i] &lt;= 100</p><a id="more"></a><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 2 4 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>区间dp</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合并金币&quot;&gt;&lt;a href=&quot;#合并金币&quot; class=&quot;headerlink&quot; title=&quot;合并金币&quot;&gt;&lt;/a&gt;合并金币&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0?f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。  &lt;/p&gt;
&lt;p&gt;其中，1 &amp;lt;= N &amp;lt;= 30，1 &amp;lt;= C[i] &amp;lt;= 100&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>字节2020春招笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/18/%E5%AD%97%E8%8A%822020%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/18/%E5%AD%97%E8%8A%822020%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-18T14:10:30.000Z</published>
    <updated>2020-08-23T15:12:59.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="万万没想到之抓捕孔连顺"><a href="#万万没想到之抓捕孔连顺" class="headerlink" title="万万没想到之抓捕孔连顺"></a>万万没想到之抓捕孔连顺</h1><p><a href="https://www.nowcoder.com/questionTerminal/c0803540c94848baac03096745b55b9b?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议</p><ol><li><p>我们在字节跳动大街的N个建筑中选定3个埋伏地点。</p></li><li><p>为了相互照应，我们决定相距最远的两名特工间的距离不超过D。</p></li></ol><p>我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！</p><p>……</p><p>万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！</p><p>请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。</p><p>注意：</p><ol><li><p>两个特工不能埋伏在同一地点</p></li><li><p>三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用</p></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每读取一个数字，就判断窗口是否满足最大值减去最小值不大于距离D；<br>由于每次进行计算组合之后，窗口的begin都会往前移动一位，所以计算组合应该采用固定首位的方法，即固定首位有一人，接下来的位置的可能性，这样就可以保证窗口移动过程不会出现重复，因为下一次判断已经不包含上一个的首位置了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n<span class="number">-1</span>) * n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, D; <span class="built_in">cin</span>&gt;&gt; N &gt;&gt; D;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>, <span class="built_in">begin</span> = <span class="number">0</span>; <span class="built_in">end</span> &lt; N; <span class="built_in">end</span>++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; res[<span class="built_in">end</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">end</span> &gt;= <span class="number">2</span> &amp;&amp; (res[<span class="built_in">end</span>] - res[<span class="built_in">begin</span>]) &gt; D) &#123;</span><br><span class="line">            <span class="built_in">begin</span>++;<span class="comment">//不满足则begin往前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        count += C(<span class="built_in">end</span> - <span class="built_in">begin</span>);<span class="comment">//由于判断一次往前移动（for循环中的end++），即可以采用每次固定首位的组合。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count % <span class="number">99997867</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="雀魂启动！"><a href="#雀魂启动！" class="headerlink" title="雀魂启动！"></a>雀魂启动！</h1><p><a href="https://www.nowcoder.com/questionTerminal/448127caa21e462f9c9755589a8f2416?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。</p><p>于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下：</p><ol><li>总共有36张牌，每张牌是1~9。每个数字4张牌。</li><li>你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌</li></ol><ul><li>14张牌中有2张相同数字的牌，称为雀头。</li><li>除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777）</li></ul><p>例如：</p><p>1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌</p><p>1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌</p><p>1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。</p><p>现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>依次尝试加入0~9的其中一个数字然后对其14个数字进行dfs判定是否可以和牌，符合和牌规则的加入答案</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>], helpArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">            state[num - <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state[i] &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = i + <span class="number">1</span>;</span><br><span class="line">                System.arraycopy(state, <span class="number">0</span>, helpArr, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">                helpArr[i]++;</span><br><span class="line">                <span class="keyword">if</span> (canHu(helpArr, <span class="number">14</span>, <span class="keyword">false</span>)) res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.isEmpty()) System.out.println(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuffer sbf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            sbf.append(res.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">                sbf.append(<span class="string">" "</span>);</span><br><span class="line">                sbf.append(res.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sbf.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canHu</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> total, <span class="keyword">boolean</span> hasHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (total == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasHead) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    arr[i] -= <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (canHu(arr, total - <span class="number">2</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    arr[i] += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[i] &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        arr[i] -= <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">if</span> (canHu(arr, total - <span class="number">3</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        arr[i] += <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> &lt; <span class="number">9</span> &amp;&amp; arr[i + <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; arr[i + <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        arr[i]--;</span><br><span class="line">                        arr[i + <span class="number">1</span>]--;</span><br><span class="line">                        arr[i + <span class="number">2</span>]--;</span><br><span class="line">                        <span class="keyword">if</span> (canHu(arr, total - <span class="number">3</span>, <span class="keyword">true</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        arr[i]++;</span><br><span class="line">                        arr[i + <span class="number">1</span>]++;</span><br><span class="line">                        arr[i + <span class="number">2</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main().sln();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="毕业旅行问题"><a href="#毕业旅行问题" class="headerlink" title="毕业旅行问题"></a>毕业旅行问题</h1><p><a href="https://www.nowcoder.com/questionTerminal/3d1adf0f16474c90b27a9954b71d125d?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><p>超时只过50%</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">99997867</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pr&gt;g[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn],mpt[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1e5</span>,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep,<span class="keyword">int</span> s,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(total&gt;ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;<span class="number">1</span> &amp;&amp; s==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep&gt;=n)&#123;</span><br><span class="line">        total += mpt[s][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;total&lt;&lt;endl;</span></span><br><span class="line">        ans = <span class="built_in">min</span>(total,ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[s])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v.first])&#123;</span><br><span class="line">            vis[v.first] = <span class="number">1</span>;</span><br><span class="line">            dfs(dep+<span class="number">1</span>,v.first,total+v.second);</span><br><span class="line">            vis[v.first] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> price;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;price;</span><br><span class="line">            mpt[i][j] = price;</span><br><span class="line">            <span class="keyword">if</span>(j == i) <span class="keyword">continue</span>;</span><br><span class="line">            g[i].push_back(make_pair(j,price));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="机器人跳跃问题"><a href="#机器人跳跃问题" class="headerlink" title="机器人跳跃问题"></a>机器人跳跃问题</h1><p><a href="https://www.nowcoder.com/questionTerminal/7037a3d57bbd4336856b8e16a9cafd71?f=discussion" target="_blank" rel="noopener">题目连接</a></p><p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 </p><p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) &gt; E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。</p><p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>假设跳跃前能力为E,要跳的高度为H，那么跳跃后的能量就是2E-H，那么跳跃后的能量加上高度就是跳跃前的两倍，然后从后往前逆推。假设跳到最后一步的能力值设为0</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">99997867</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        ans = (ans+a[i]+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2020-8-23第一题"><a href="#2020-8-23第一题" class="headerlink" title="2020.8.23第一题"></a>2020.8.23第一题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个n，l，r。构造一个长度为n的数组</p><ol><li>数组的元素的值a[i]需要在区间(l,r)之内</li><li>数组元素之和能与3相余为0</li></ol><p>则构造此数组的方法有多少种，答案模1e9+7</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><strong>dp(i,j)表示以a[i]为结尾且（数组和）%3=j的数组个数</strong>。</p><p>由于a[i]的可选值属于[l,r]，因此先算出[l,r]内%3=0，%3=1，%3=2的数的数量，分别记为x0,x1,x2。那么转移方程为</p><p>dp(i,0)= (dp(i-1,0)<em>x0%mod + dp(i-1,1)</em>x2%mod + dp(i-1,2)*x1%mod)%mod</p><p>dp(i,1)和dp(i,2)的类似</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>],b[<span class="number">3</span>],dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,l,r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">int</span> len = (r-l+<span class="number">1</span>);</span><br><span class="line">    a[<span class="number">0</span>] = l/<span class="number">3</span>;</span><br><span class="line">    a[<span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">    a[<span class="number">2</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(l%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">        a[<span class="number">1</span>]++;</span><br><span class="line">        a[<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        a[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">0</span>] = r/<span class="number">3</span>;</span><br><span class="line">    b[<span class="number">1</span>] = b[<span class="number">0</span>];</span><br><span class="line">    b[<span class="number">2</span>] = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(r%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">        b[<span class="number">1</span>]++;</span><br><span class="line">        b[<span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        b[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x0 = b[<span class="number">0</span>] - a[<span class="number">0</span>], x1 = b[<span class="number">1</span>] - a[<span class="number">1</span>] , x2 = b[<span class="number">2</span>] - a[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = x0;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = x1;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = x2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] += dp[i<span class="number">-1</span>][<span class="number">0</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">1</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">1</span>] += dp[i<span class="number">-1</span>][<span class="number">1</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">2</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">0</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">2</span>] += dp[i<span class="number">-1</span>][<span class="number">2</span>]*x0%mod + dp[i<span class="number">-1</span>][<span class="number">0</span>]*x2%mod + dp[i<span class="number">-1</span>][<span class="number">1</span>]*x1%mod;</span><br><span class="line">        dp[i][<span class="number">0</span>] %= mod;</span><br><span class="line">        dp[i][<span class="number">1</span>] %= mod;</span><br><span class="line">        dp[i][<span class="number">2</span>] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;万万没想到之抓捕孔连顺&quot;&gt;&lt;a href=&quot;#万万没想到之抓捕孔连顺&quot; class=&quot;headerlink&quot; title=&quot;万万没想到之抓捕孔连顺&quot;&gt;&lt;/a&gt;万万没想到之抓捕孔连顺&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/c0803540c94848baac03096745b55b9b?answerType=1&amp;amp;f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>final</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/17/final/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/17/final/</id>
    <published>2020-08-17T09:58:39.000Z</published>
    <updated>2020-08-17T10:21:28.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h1><p>final关键字是用来修饰Java中的变量，方法，类的。修饰变量表示这个变量引用的地址不能变化，修饰方法表示这个方法不可覆盖，修饰类表示这个类无法继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;final关键字的作用&quot;&gt;&lt;a href=&quot;#final关键字的作用&quot; class=&quot;headerlink&quot; title=&quot;final关键字的作用&quot;&gt;&lt;/a&gt;final关键字的作用&lt;/h1&gt;&lt;p&gt;final关键字是用来修饰Java中的变量，方法，类的。修饰变量表示
      
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="final" scheme="https://sqwyyy.github.io/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBffuer、StringBuilder</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/17/String%E3%80%81StringBffuer%E3%80%81StringBuilder/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/17/String%E3%80%81StringBffuer%E3%80%81StringBuilder/</id>
    <published>2020-08-17T08:31:16.000Z</published>
    <updated>2020-08-17T13:00:21.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p> 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ <strong>可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的</strong>。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><a id="more"></a><p><strong>区分对象和对象引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);  </span><br><span class="line"></span><br><span class="line">s = <span class="string">"123456"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>首先创建一个String对象s，然后让s的值为“ABCabc”， 然后又让s的值为“123456”。 从打印结果可以看出，s的值确实改变了。那么怎么还说String对象是不可变的呢？ 其实这里存在一个误区： ==s只是一个String对象的引用，并不是对象本身。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。==</p><p>也就是说，s只是一个引用，它指向了一个具体的对象，当s=“123456”; 这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个新的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。</p><h1 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h1><p>​      StringBuffer 和 StringBuilder 都继承<strong>抽象类AbstractStringBuilder</strong>。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><hr><p>​     StringBuilder 类在 Java 5 中被提出，它和 <strong>StringBuffer</strong> 之间的最大不同在于 StringBuilder 的方法<strong>不是线程安全</strong>的（不能同步访问）。</p><hr><h2 id="StringBuiler为什么线程安全以及StringBuffer为什么线程不安全"><a href="#StringBuiler为什么线程安全以及StringBuffer为什么线程不安全" class="headerlink" title="StringBuiler为什么线程安全以及StringBuffer为什么线程不安全"></a>StringBuiler为什么线程安全以及StringBuffer为什么线程不安全</h2><p>以StringBuilder的append()方法为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>.    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">3</span>.        <span class="keyword">return</span> appendNull();</span><br><span class="line"><span class="number">4</span>.    <span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="number">5</span>.    ensureCapacityInternal(count + len);</span><br><span class="line"><span class="number">6</span>.    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line"><span class="number">7</span>.    count += len;</span><br><span class="line"><span class="number">8</span>.    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="number">9</span>.&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p><strong>count += len不是一个原子操作.</strong><br>假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12</p></li><li><p>ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容</p></li><li><p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面.</p></li></ol><p><strong>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count=5。</strong><br><strong>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</strong></p><hr><p><strong>StringBuffer则根据synchronized关键字实现线程安全</strong></p><p><a href="https://zhuanlan.zhihu.com/p/85867299" target="_blank" rel="noopener">来源1</a><br><a href="https://blog.csdn.net/u011702479/article/details/82262823" target="_blank" rel="noopener">来源2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;p&gt; 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ &lt;strong&gt;可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的&lt;/strong&gt;。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/categories/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Sting" scheme="https://sqwyyy.github.io/tags/Sting/"/>
    
  </entry>
  
  <entry>
    <title>腾讯2020校招笔试</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/16/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/16/%E8%85%BE%E8%AE%AF2020%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-16T05:58:44.000Z</published>
    <updated>2020-08-23T13:58:10.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逛街"><a href="#逛街" class="headerlink" title="逛街"></a>逛街</h1><p><a href="https://www.nowcoder.com/questionTerminal/35fac8d69f314e958a150c141894ef6a?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><p>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。</p><p>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用单调栈实现，开辟一个数组rightLook 保留往右看得到的数量，从右往左遍历，利用单调栈将看得到的数量保留在数组 rightLook 中 ，再从左往右遍历，获取往左看的计数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r[maxn],a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">     r[i] = q.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>(!q.empty() &amp;&amp; a[i] &gt;= a[q.top()])&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">     &#125;</span><br><span class="line">     q.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">     <span class="keyword">int</span> num = r[i] + <span class="number">1</span> + q.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>(!q.empty() &amp;&amp; a[i] &gt;= a[q.top()])&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">     q.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="假期"><a href="#假期" class="headerlink" title="假期"></a>假期</h1><p><a href="https://www.nowcoder.com/questionTerminal/7cd9a140387e455a972e8fea0e74be2c?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>dp(i,0) , dp(i,1), dp(i,2) 分别记录第i天 休息/锻炼/工作 累计的最小休息天数</p><p>如果第i天休息，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,1), dp(i,2)中的最小值+1</p><p>如果第i天工作，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,1)中的最小值</p><p>如果第i天健身，那么前i天休息的最小天数，实际就是dp(i,0) , dp(i,2)中的最小值</p><p>答案就是dp(n,0) , dp(n,1), dp(n,2)中的最小值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( b[i] == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="comment">// 可以锻炼</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">min</span>( dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( a[i] == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="comment">// 可以工作</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">min</span>( dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], <span class="built_in">min</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">min</span>(dp[n][<span class="number">0</span>], <span class="built_in">min</span>(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="视野争夺"><a href="#视野争夺" class="headerlink" title="视野争夺"></a>视野争夺</h1><p><a href="https://www.nowcoder.com/questionTerminal/61e1e66e39f348cdb6495de91ac36a41?answerType=1&amp;f=discussion" target="_blank" rel="noopener">题目链接</a></p><p>小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。</p><p>这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。 </p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>根据贪心算法，将数组按照左节点排序</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;逛街&quot;&gt;&lt;a href=&quot;#逛街&quot; class=&quot;headerlink&quot; title=&quot;逛街&quot;&gt;&lt;/a&gt;逛街&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/35fac8d69f314e958a150c141894ef6a?answerType=1&amp;amp;f=discussion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔试" scheme="https://sqwyyy.github.io/categories/%E7%AC%94%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://sqwyyy.github.io/archives/2020/08/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sqwyyy.github.io/archives/2020/08/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-03T13:43:27.000Z</published>
    <updated>2020-08-12T15:02:58.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h1><h2 id="内存的含义"><a href="#内存的含义" class="headerlink" title="内存的含义"></a>内存的含义</h2><p><strong>内存就是用于存放数据的硬件。程序执行前需要放到内存中才能被CPU处理。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存的基础知识&quot;&gt;&lt;a href=&quot;#内存的基础知识&quot; class=&quot;headerlink&quot; title=&quot;内存的基础知识&quot;&gt;&lt;/a&gt;内存的基础知识&lt;/h1&gt;&lt;h2 id=&quot;内存的含义&quot;&gt;&lt;a href=&quot;#内存的含义&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存管理" scheme="https://sqwyyy.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JWT实现</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/28/JWT%E5%AE%9E%E7%8E%B0/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/28/JWT%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-28T14:19:50.000Z</published>
    <updated>2020-08-03T10:38:50.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><ul><li><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</p></li><li><p>是一种<strong>认证授权机制</strong>。</p></li><li><p>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p></li><li><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p></li></ul><a id="more"></a><h2 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h2><p><img src="https://pic3.zhimg.com/v2-aa19a381cbae00402e82b710f2db6e06_b.jpg" alt=""></p><p><strong>JWT 认证流程：</strong></p><ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</li><li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li><p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</p></li><li><p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</p></li><li><p>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</p></li><li><p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</p></li></ul><h2 id="Token和JWT的区别"><a href="#Token和JWT的区别" class="headerlink" title="Token和JWT的区别"></a>Token和JWT的区别</h2><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>区别：</strong></p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul><h2 id="使用JWT时需要考虑的问题"><a href="#使用JWT时需要考虑的问题" class="headerlink" title="使用JWT时需要考虑的问题"></a>使用JWT时需要考虑的问题</h2><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/164696755" target="_blank" rel="noopener">JWT详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是JWT&quot;&gt;&lt;a href=&quot;#什么是JWT&quot; class=&quot;headerlink&quot; title=&quot;什么是JWT&quot;&gt;&lt;/a&gt;什么是JWT&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JSON Web Token（简称 JWT）是目前最流行的&lt;strong&gt;跨域认证&lt;/strong&gt;解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是一种&lt;strong&gt;认证授权机制&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JWT 是为了在网络应用环境间&lt;strong&gt;传递声明&lt;/strong&gt;而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JWT" scheme="https://sqwyyy.github.io/categories/JWT/"/>
    
    
      <category term="JWT" scheme="https://sqwyyy.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>NAT协议</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/25/NAT%E5%8D%8F%E8%AE%AE/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/25/NAT%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-07-25T14:47:52.000Z</published>
    <updated>2020-07-27T14:51:28.898Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决ip地址稀缺问题，采用NAT技术使内网（私网）转换为公网</p><a id="more"></a><p>具体的转换规则:</p><p>对于TCP/UDP使用：</p><p>Host’s 私有IPv4 + Port &lt;——-&gt; NAT 公网IPv4 + Port</p><p>对于ICMP使用</p><p>Host’s 私有IPv4 + session ID &lt;——-&gt; NAT 公网IPv4 + session ID</p><p>session ID在NAT设备上是独一无二的</p><p><a href="https://www.jianshu.com/p/4cd76e25b894" target="_blank" rel="noopener">NAT技术</a></p><p><a href="https://www.zhihu.com/question/31332694/answer/118410360" target="_blank" rel="noopener">NAT转换对应规则</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了解决ip地址稀缺问题，采用NAT技术使内网（私网）转换为公网&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="NAT协议" scheme="https://sqwyyy.github.io/tags/NAT%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/22/%E8%BF%9B%E7%A8%8B/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/22/%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-07-22T13:40:01.000Z</published>
    <updated>2020-07-23T14:28:48.223Z</updated>
    
    <content type="html"><![CDATA[<p>进程由进程控制块（PCB）、程序段、数据段三部分组成。</p><ul><li><p>进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。</p><ul><li><p>标识符：与进程相关的唯一标识符，用来区分其他进程。</p></li><li><p>状态：进程有不同的状态，例如运行，就绪，阻塞等。</p></li><li>优先级：为了给处理机调度提供支持，优先级用来区分各种进程的先后执行顺序</li><li>程序计数器：程序中即将执行的下一条指令的地址</li><li>内存指针：包括程序代码的进程相关数据的指针，以及与其他进程贡献那个内存块的指针。</li><li>上下文：进程是需要切换的，切换进程时需要保留进程的上下文信息，以防进程在切换时丢 失现场数据。</li><li>i/o状态信息：包括显示i/o请求，分配给进程的i/o设备和被进程使用的文件列表等。</li><li>记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li></ul></li><li>代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。</li><li>数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据</li></ul><a id="more"></a><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><ol><li>无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li><li>FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li><li>消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li><li>信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li><li>共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。</li></ol><h2 id="进程间五种通信方式的比较"><a href="#进程间五种通信方式的比较" class="headerlink" title="进程间五种通信方式的比较"></a>进程间五种通信方式的比较</h2><ul><li>管道：速度慢，容量有限，只有父子进程能通讯。</li><li>FIFO：任何进程间都能通讯，但速度慢。</li><li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</li><li>信号量：不能传递复杂消息，只能用来同步。</li><li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li></ul><h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><p>线程之间的通信机制有两种，<strong>共享内存和消息传递</strong></p><ul><li>使用volatile是属于共享内存模型</li><li>使用wait和notify方法属于消息传递(wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁)<br><a href="https://blog.csdn.net/jisuanji12306/article/details/86363390" target="_blank" rel="noopener">代码实例</a></li></ul><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p><a href="https://blog.csdn.net/kuangsonghan/article/details/80674777" target="_blank" rel="noopener">来源</a><br>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><p>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><h2 id="关于线程与进程的选取"><a href="#关于线程与进程的选取" class="headerlink" title="关于线程与进程的选取"></a>关于线程与进程的选取</h2><ol><li><p>需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。</p></li><li><p>线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p></li><li><p>因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；</p></li><li><p>并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；</p></li><li><p>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</p></li></ol><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>串行：一次只能取得一个任务并执行这一个任务<br>并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务<br>并发是一种现象：同时运行多个程序或多个任务需要被处理的现象<br><a href="https://www.cnblogs.com/f-ck-need-u/p/11161481.html" target="_blank" rel="noopener">来源</a></p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ol><li>新建：就是刚使用new方法，new出来的线程；</li><li>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li><li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</li><li>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</li><li>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;<br><a href="https://www.cnblogs.com/marsitman/p/11228684.html" target="_blank" rel="noopener">来源</a><br><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt=""></li></ol><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>​      在进程A切换到进程B的过程中，<strong>先保存A进程的上下文</strong>，以便于等A恢复运行的时候，能够知道A进程的下一条指令是什么。然后将<strong>要运行的B进程的上下文恢复到寄存器中</strong>，这个过程被称为<strong>上下文切换</strong>。</p><p>  上下文切换的主要开销有:</p><ol><li>切换页表全局目录</li><li>切换内核态堆栈</li><li>切换硬件上下文</li><li>刷新TLB</li><li>系统调用器的代码执行</li></ol><p><a href="https://zhuanlan.zhihu.com/p/52845869" target="_blank" rel="noopener">上下文切换</a></p><h2 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h2><p><strong>僵尸进程</strong>：</p><p><strong>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><p><strong>孤儿进程</strong>：</p><p><strong>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>孤儿进程并不会有什么危害，真正会对系统构成威胁的是僵尸进程</strong></p><p><strong>僵尸进程产生的问题：</strong></p><p>设想有这样一个父进程：它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵尸进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程</p><p><strong>解决僵尸进程的方法:</strong></p><p>当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶枪毙掉（通过kill发送SIGTERM或者SIGKILL信号）。</p><p>枪毙了元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经“僵尸”的孤儿进程就能瞑目而去了。</p><p><a href="https://www.zhihu.com/question/26432067/answer/70643183" target="_blank" rel="noopener">僵尸进程与孤儿进程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程由进程控制块（PCB）、程序段、数据段三部分组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标识符：与进程相关的唯一标识符，用来区分其他进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态：进程有不同的状态，例如运行，就绪，阻塞等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;优先级：为了给处理机调度提供支持，优先级用来区分各种进程的先后执行顺序&lt;/li&gt;
&lt;li&gt;程序计数器：程序中即将执行的下一条指令的地址&lt;/li&gt;
&lt;li&gt;内存指针：包括程序代码的进程相关数据的指针，以及与其他进程贡献那个内存块的指针。&lt;/li&gt;
&lt;li&gt;上下文：进程是需要切换的，切换进程时需要保留进程的上下文信息，以防进程在切换时丢 失现场数据。&lt;/li&gt;
&lt;li&gt;i/o状态信息：包括显示i/o请求，分配给进程的i/o设备和被进程使用的文件列表等。&lt;/li&gt;
&lt;li&gt;记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。&lt;/li&gt;
&lt;li&gt;数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="https://sqwyyy.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的线程</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/22/JAVA%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/22/JAVA%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-07-22T13:36:31.000Z</published>
    <updated>2020-08-13T11:47:33.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。<strong>调用sleep不会释放对象锁</strong>,在多线程异步时可能用到。</p><p>wait是Object类的方法，对此对象调用wait方法<strong>导致本线程放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池<strong>准备</strong>获得对象锁进入运行状态。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，</span></span><br><span class="line">            <span class="comment">// 我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。</span></span><br><span class="line">            <span class="comment">// 我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MultiThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"enter thread1..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread1 is waiting"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁有两种方式，第一种方式是程序自然离开监视器的范围，</span></span><br><span class="line">                    <span class="comment">// 也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字</span></span><br><span class="line">                    <span class="comment">// 管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。</span></span><br><span class="line">                    MultiThread<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"thread1 is going on..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread1 is being over!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MultiThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"enter thread2..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 notify other thread can release wait status.."</span>);</span><br><span class="line">                <span class="comment">// 由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，</span></span><br><span class="line">                <span class="comment">// 但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。</span></span><br><span class="line">                MultiThread<span class="class">.<span class="keyword">class</span>.<span class="title">notify</span>()</span>;</span><br><span class="line">                System.out.println(<span class="string">"thread2 is sleeping ten millisecond..."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"thread2 is going on..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 is being over!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter thread1...</span><br><span class="line">thread1 is waiting</span><br><span class="line">enter thread2...</span><br><span class="line">thread2 notify other thread can release wait status..</span><br><span class="line">thread2 is sleeping ten millisecond...</span><br><span class="line">thread2 is going on...</span><br><span class="line">thread2 is being over!</span><br><span class="line">thread1 is going on...</span><br><span class="line">thread1 is being over!</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/ab05baf75d75" target="_blank" rel="noopener">来源</a></p><h3 id="中断线程的方法"><a href="#中断线程的方法" class="headerlink" title="中断线程的方法"></a>中断线程的方法</h3><ol><li>使用interrupt()方法中断当前线程：interrupt()其本身并不是一个强制打断线程的方法，其仅仅会修改线程的interrupt标志位，然后让线程自行去读标志位，自行判断是否需要中断。在设计里，如果线程处于休眠状态，那一旦其被调用interrupt()方法，则就没有必要继续休眠下去了，直接抛出异常InterruptedException，让被打断线程去做收尾操作，及时释放线程资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i&#x3D;202053</span><br><span class="line">i&#x3D;202054</span><br><span class="line">i&#x3D;202055</span><br><span class="line">i&#x3D;202056</span><br></pre></td></tr></table></figure><ol><li>如果使用线程池可将线程池的状态修改为STOP状态(该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；)</li></ol><h3 id="控制多个线程按顺序执行"><a href="#控制多个线程按顺序执行" class="headerlink" title="控制多个线程按顺序执行"></a>控制多个线程按顺序执行</h3><p>join方法:</p><ol><li>在子线程中通过join()方法指定顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread2.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//下面三行代码顺序可随意调整，程序运行结果不受影响，因为我们在子线程中通过“join()方法”已经指定了运行顺序。</span></span><br><span class="line">        thread3.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在主线程中通过join()方法指定顺序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMainJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建单一化线程池newSingleThreadExecutor()实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span> ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(thread1);</span><br><span class="line">        executorService.submit(thread2);</span><br><span class="line">        executorService.submit(thread3);</span><br><span class="line">        executorService.shutdown();        <span class="comment">//使用完毕记得关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jqc874789596/article/details/100557300" target="_blank" rel="noopener">来源</a></p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;wait和sleep的区别&quot;&gt;&lt;a href=&quot;#wait和sleep的区别&quot; class=&quot;headerlink&quot; title=&quot;wait和sleep的区别&quot;&gt;&lt;/a&gt;wait和sleep的区别&lt;/h3&gt;&lt;p&gt;sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。&lt;strong&gt;调用sleep不会释放对象锁&lt;/strong&gt;,在多线程异步时可能用到。&lt;/p&gt;
&lt;p&gt;wait是Object类的方法，对此对象调用wait方法&lt;strong&gt;导致本线程放弃对象锁&lt;/strong&gt;，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池&lt;strong&gt;准备&lt;/strong&gt;获得对象锁进入运行状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="线程" scheme="https://sqwyyy.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>springboot整合swagger</title>
    <link href="https://sqwyyy.github.io/archives/2020/07/10/springboot%E6%95%B4%E5%90%88swagger/"/>
    <id>https://sqwyyy.github.io/archives/2020/07/10/springboot%E6%95%B4%E5%90%88swagger/</id>
    <published>2020-07-10T11:17:56.506Z</published>
    <updated>2020-07-10T11:19:44.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot整合swagger"><a href="#springboot整合swagger" class="headerlink" title="springboot整合swagger"></a>springboot整合swagger</h1><a id="more"></a><h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="新建配置类"><a href="#新建配置类" class="headerlink" title="新建配置类"></a>新建配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 createRestApi函数来构建一个DocketBean</span></span><br><span class="line"><span class="comment">     * 函数名,可以随意命名,喜欢什么命名就什么命名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())<span class="comment">//调用apiInfo方法,创建一个ApiInfo实例,里面是展示在文档页面信息内容</span></span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//控制暴露出去的路径下的实例</span></span><br><span class="line">                <span class="comment">//如果某个接口不想暴露,可以使用以下注解</span></span><br><span class="line">                <span class="comment">//@ApiIgnore 这样,该接口就不会暴露在 swagger2 的页面下</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.example.zwd.springbootswagger2.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建 api文档的详细信息函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                <span class="comment">//页面标题</span></span><br><span class="line">                .title(<span class="string">"Spring Boot Swagger2 构建RESTful API"</span>)</span><br><span class="line">                <span class="comment">//条款地址</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">"http://despairyoke.github.io/"</span>)</span><br><span class="line">                .contact(<span class="string">"zwd"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                <span class="comment">//描述</span></span><br><span class="line">                .description(<span class="string">"API 描述"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此时启动项目，输入<a href="http://localhost:8080/swagger-ui.html，能够看到如下页面，说明已经配置成功了：" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html，能够看到如下页面，说明已经配置成功了：</a></li><li><img src="https://img-blog.csdnimg.cn/20190324120135562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly93YW5nc29uZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt=""></li></ul><h2 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"用户管理相关接口"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"添加用户的接口"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParams</span>(&#123;</span><br><span class="line">            <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"username"</span>, value = <span class="string">"用户名"</span>, defaultValue = <span class="string">"李四"</span>),</span><br><span class="line">            <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"address"</span>, value = <span class="string">"用户地址"</span>, defaultValue = <span class="string">"深圳"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RespBean <span class="title">addUser</span><span class="params">(String username, @RequestParam(required = <span class="keyword">true</span>)</span> String address) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RespBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"根据id查询用户的接口"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"id"</span>, value = <span class="string">"用户id"</span>, defaultValue = <span class="string">"99"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"根据id更新用户的接口"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUserById</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>@Api注解可以用来标记当前Controller的功能。</p></li><li><p>@ApiOperation注解用来标记一个方法的作用。</p></li><li><p>@ApiImplicitParam注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。</p></li><li><p>如果有多个参数，则需要使用多个@ApiImplicitParam注解来描述，多个@ApiImplicitParam注解需要放在一个@ApiImplicitParams注解中。</p></li><li><p>需要注意的是，@ApiImplicitParam注解中虽然可以指定参数是必填的，但是却不能代替@RequestParam(required = true)，前者的必填只是在Swagger2框架内必填，抛弃了Swagger2，这个限制就没用了，所以假如开发者需要指定一个参数必填，@RequestParam(required = true)注解还是不能省略。</p></li><li><p>如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中。例如下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户地址"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190324120155527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly93YW5nc29uZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt=""></p></li></ol><p><a href="https://blog.csdn.net/u012702547/article/details/88775298" target="_blank" rel="noopener">来源</a></p><p><a href="https://www.jianshu.com/p/406e9d203300" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;springboot整合swagger&quot;&gt;&lt;a href=&quot;#springboot整合swagger&quot; class=&quot;headerlink&quot; title=&quot;springboot整合swagger&quot;&gt;&lt;/a&gt;springboot整合swagger&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round #645 (Div. 2)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/27/Codeforces-Round-645-Div-2/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/27/Codeforces-Round-645-Div-2/</id>
    <published>2020-05-27T14:06:35.000Z</published>
    <updated>2020-05-27T15:02:04.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Celex-Update"><a href="#Celex-Update" class="headerlink" title="Celex Update"></a><a href="https://codeforces.com/contest/1358/problem/C" target="_blank" rel="noopener">Celex Update</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p><img src="https://espresso.codeforces.com/ab3c49666e913d52a14ebf7f09d741f3f712bacb.png" alt=""></p><p>给定两点坐标，问从一点到另外一点所需权值的不同值有多少。权值即路径上方块值的和</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p><img src="https://img2020.cnblogs.com/blog/1626919/202005/1626919-20200527105926672-418175495.png" alt=""></p><p>会发现图中标出的路线每个田字格右上和左下的数字相差1，而这两条路线的数字之和只差1。一直往右再往下是和最小的走法。往右再往下的路径为一条，带有往下再往右拐点的路径（图中紫色路径）为(x1-x2)*(y1-y2)条，加起来输出即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span>)(x2-x1)*(y2-y1)+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-Best-Vacation"><a href="#The-Best-Vacation" class="headerlink" title="The Best Vacation"></a><a href="https://codeforces.com/contest/1358/problem/D" target="_blank" rel="noopener">The Best Vacation</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h2><script type="math/tex; mode=display">一个数组，a[i]表示第i月有a[i]天。在某个月的第j天去会得到j个拥抱，问连续x天最多可以得到的拥抱</script><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>连续的x天可能不在同一年，所以可以将数组存储两遍。</p><script type="math/tex; mode=display">sum1[i]表示a[1]-a[i]的总天数，sum[2]表示a[1]-a[i]的总拥抱数\\</script><p>1~2*n间寻找区间左端点，然后找满足条件的最大值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line">ll t,n,m,x,a[N],sum1[N],sum2[N];</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*(<span class="number">1</span>+a)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],a[i+n]=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  sum1[i]=sum1[i<span class="number">-1</span>]+a[i];</span><br><span class="line">sum2[i]=sum2[i<span class="number">-1</span>]+cal(a[i]);</span><br><span class="line">&#125; </span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sum1[i]&lt;=x)&#123;<span class="comment">//如果总天数小于等于x，则ans可取当前的总拥抱数。</span></span><br><span class="line">ans=<span class="built_in">max</span>(ans,sum2[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll l=<span class="number">0</span>,r=i;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)<span class="comment">//找区间左端点</span></span><br><span class="line">&#123;</span><br><span class="line">ll mid = l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sum1[i]-sum1[mid]&lt;x) r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;sum1[i]-sum1[l+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">ll res=sum2[i]-sum2[l+<span class="number">1</span>];<span class="comment">//l+1月的天数可能没有用完</span></span><br><span class="line">ll tmp=x-sum1[i]+sum1[l+<span class="number">1</span>];</span><br><span class="line">res+=(cal(a[l+<span class="number">1</span>])-cal(a[l+<span class="number">1</span>]-tmp));</span><br><span class="line">ans=<span class="built_in">max</span>(ans,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Celex-Update&quot;&gt;&lt;a href=&quot;#Celex-Update&quot; class=&quot;headerlink&quot; title=&quot;Celex Update&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1358/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Celex Update&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://espresso.codeforces.com/ab3c49666e913d52a14ebf7f09d741f3f712bacb.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;给定两点坐标，问从一点到另外一点所需权值的不同值有多少。权值即路径上方块值的和&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>hashcode</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/hashcode/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/hashcode/</id>
    <published>2020-05-25T13:41:08.000Z</published>
    <updated>2020-08-17T09:58:11.168Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h1><p><strong>值类型是存储在内存中的堆栈（以后简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。</strong></p><p>  <strong>==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。</strong></p><p> <strong>equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。</strong></p><p><strong>==比较的是两个对象的地址，而equals比较的是两个对象的内容。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String a = <span class="string">"qqq"</span>;</span><br><span class="line">String b = <span class="string">"qqq"</span>;  <span class="comment">//保存到字符串缓冲池里，当有相同值的对象，就引用该对象，否则重新创建字符串</span></span><br><span class="line">System.out.println(a==b);  <span class="comment">//比较的是地址</span></span><br><span class="line">System.out.println(a.equals(b));  <span class="comment">//比较的是值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p><strong>程序在运行的时候会创建一个字符串缓冲池当使用 b = “qqq” 这样的表达是创建字符串的时候，程序首先会在这个String缓冲池中寻找相同值的对象，在第一个程序中，a先被放到了池中，所以在b被创建的时候，程序找到了具有相同值的 a</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String a = <span class="string">"money"</span>;</span><br><span class="line">  String b = <span class="keyword">new</span> String(<span class="string">"money"</span>);</span><br><span class="line">  System.out.println(a==b);  <span class="comment">//比较的是地址</span></span><br><span class="line">System.out.println(a.equals(b));  <span class="comment">//比较的是值</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p> <strong>第二段程序中，使用了 new 操作符，他明白的告诉程序：”我要一个新的！不要旧的！”于是一个新的”money”Sting对象被创建在内存中。他们的值相同，但是位置不同。</strong></p><p><a href="https://blog.csdn.net/zxl1148377834/article/details/82858192" target="_blank" rel="noopener">equals与==的区别</a></p><h2 id="为什么重写equals要重写hashcode"><a href="#为什么重写equals要重写hashcode" class="headerlink" title="为什么重写equals要重写hashcode"></a>为什么重写equals要重写hashcode</h2><p>因为在hashmap等集合类中要根据各个类的hashcode来计算哈希值，如果根据equals来进行比较，两个相同的类在hashmap中存储的位置不同。</p><ul><li>默认情况下equals是比较对象的内存地址</li><li>hashcode也是根据对象的内存地址计算</li></ul><p><a href="https://www.zhihu.com/search?type=content&amp;q=%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E8%A6%81%E9%87%8D%E5%86%99hashcode" target="_blank" rel="noopener">为什么重写equals要重写hashcode</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;equals与-的区别&quot;&gt;&lt;a href=&quot;#equals与-的区别&quot; class=&quot;headerlink&quot; title=&quot;equals与==的区别&quot;&gt;&lt;/a&gt;equals与==的区别&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;值类型是存储在内存中的堆栈（以后简称栈
      
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/tags/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%AD%BB%E9%94%81/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%AD%BB%E9%94%81/</id>
    <published>2020-05-25T13:37:13.000Z</published>
    <updated>2020-05-25T13:38:10.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><a id="more"></a><h2 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h2><p>死锁的出现必须同时满足以下四个条件，缺一不可。</p><ul><li><p>互斥：所谓互斥就是进程在某一时间内独占资源（更准确得说，对于某个资源访问有限制。若资源数量有限，也有可能产生死锁）。</p></li><li><p>请求与保持：已经持有某一资源的进程不必释放当前拥有的资源，就可以申请并获得更多的资源。</p></li><li>不可剥夺：进程已获得资源，在末使用完之前，不能强行剥夺。</li><li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系，每个进程都在等待循环链中另一进程持有的资源。</li></ul><h2 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h2><ul><li><p>打破互斥条件。</p><ul><li><p>即允许进程同时访问某些资源。</p></li><li><p>但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。</p></li></ul></li><li><p>打破请求与保持条件</p><ul><li><p>进程在运行前一次性地向系统申请它所需要的全部资源。</p></li><li><p>如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。</p></li><li>由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。</li></ul></li><li><p>打破不可剥夺条件</p><ul><li><p>允许进程强行从占有者那里夺取某些资源。</p></li><li><p>当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。</p></li></ul></li><li><p>打破循环等待条件</p><ul><li><p>前面三种预防策略都很棘手，所以大部分预防死锁的算法都把重心放在这里。</p></li><li><p>为预防循环等待条件的出现，可以实行资源<strong>有序分配策略</strong>。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成循环链。<strong>所有进程对资源的请求必须严格按资源序号递增的顺序提出</strong>。进程占用了小号资源，才能申请大号资源，就不会产生循环链，从而预防了死锁。</p></li></ul></li></ul><h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><p>可以使用<strong>银行家算法</strong>来避免死锁产生<br>银行家算法有以下数据结构</p><ul><li><p>可利用资源向量Available<br>是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果- Available[j]=K，则表示系统中现有Rj类资源K个。</p></li><li><p>最大需求矩阵Max<br>这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。</p></li><li>3 分配矩阵Allocation<br>这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。</li><li>4 需求矩阵Need。<br>这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。</li></ul><p>列子：<br>| Process | Allocation | Need    | Available |<br>| ———- | ————— | ———- | ————- |<br>| P0      | 0,0,3,2    | 0,0,1,2 | 1,6,2,2   |<br>| P1      | 1,0,0,0    | 1,7,5,0 |           |<br>| P2      | 1,3,5,4    | 2,3,5,6 |           |<br>| P3      | 0,3,3,2    | 0,6,5,2 |           |<br>| P4      | 0,0,1,4    | 0,6,5,6 |           |<br>(1)该进程是否安全<br>(2)若进程P2提出请求（1，2，2，2）后，系统能否将资源分配给它</p><p>(1)<br>| Process | Allocation | Need    | Allocation | Work+Allocation | Finsh |<br>| ———- | ————— | ———- | ————— | ———————- | ——- |<br>| P0      | 0,0,3,2    | 0,0,1,2 | 0,0,3,2    | 1,6,5,4         | true  |<br>| P1      | 1,0,0,0    | 1,7,5,0 | 0,3,3,2    | 1,9,8,6         | true  |<br>| P2      | 1,3,5,4    | 2,3,5,6 | 0,0,1,4    | 1,9,9,10        | true  |<br>| P3      | 0,3,3,2    | 0,6,5,2 | 1,0,0,0    | 2,9,9,10        | true  |<br>| P4      | 0,0,1,4    | 0,6,5,6 | 1,3,5,4    | 3,12,14,14      | true  |</p><p>存在一个安全序列{P0,P3,P4,P1,P2}</p><p>(2) P2提出请求（1，2，2，2）后，因Request&lt;=Need,Request&lt;=Available,故系统可考虑将资源分配给它，分配后Available变成（0，4，0，0）进行安全性检测，发现不能满足任何进程的需求，系统进入不安全状态，所以系统不能向P2分配资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;h2 id=&quot;什么是死锁&quot;&gt;&lt;a href=&quot;#什么是死锁&quot; class=&quot;headerlink&quot; title=&quot;什么是死锁&quot;&gt;&lt;/a&gt;什么是死锁&lt;/h2&gt;&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="https://sqwyyy.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础知识</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-25T13:36:34.000Z</published>
    <updated>2020-05-27T14:19:48.649Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-05-25T13:33:47.000Z</published>
    <updated>2020-05-25T13:38:10.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本类型和引用类型在内存中的保存"><a href="#基本类型和引用类型在内存中的保存" class="headerlink" title="基本类型和引用类型在内存中的保存"></a>基本类型和引用类型在内存中的保存</h1><p>Java中数据类型分为两大类：<strong>基本类型和对象类型</strong><br>变量也有两种类型：<strong>基本类型和引用类型</strong></p><p><strong>基本类型的变量保存原始值，即它代表的值就是数值本身</strong><br><strong>引用类型的变量保存引用值，”引用值”指向内存空间的地址，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置</strong>。<br>基本类型包括：byte,short,int,long,char,float,double,boolean<br>引用类型包括：类类型，接口类型和数组</p><a id="more"></a><h1 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h1><p>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，<strong>后面方法中的操作都是对形参这个值的修改，不影响实际参数的值</strong>。</p><h1 id="引用传递："><a href="#引用传递：" class="headerlink" title="引用传递："></a>引用传递：</h1><p>也称为传地址。方法调用时，<strong>实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址</strong>；<br>在方法执行中，形参和实参内容相同，指向同一块内存地址，<strong>方法执行中对引用的操作将会影响到实际对象</strong>。</p><p><strong>在java中无论是浅拷贝还是深拷贝都要实现Clonenable接口，并且重写clone方法</strong></p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number=<span class="number">123</span>;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.setNumber(number);</span><br><span class="line">        Student stu2 =stu1;</span><br><span class="line">        stu2.setNumber(<span class="number">321</span>);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        System.out.println(stu1 == stu2);</span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());</span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">true</span><br><span class="line">学生1：321</span><br><span class="line">学生2：123</span><br></pre></td></tr></table></figure></p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number=<span class="number">123</span>;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.setNumber(number);</span><br><span class="line">        Student stu2 = (Student)stu1.clone();</span><br><span class="line">        stu2.setNumber(<span class="number">321</span>);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        System.out.println(stu1 == stu2);</span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());</span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Student stu = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                stu = (Student)<span class="keyword">super</span>.clone();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">false</span><br><span class="line">学生1：321</span><br><span class="line">学生2：123</span><br></pre></td></tr></table></figure></p><h1 id="clone和new的区别"><a href="#clone和new的区别" class="headerlink" title="clone和new的区别"></a>clone和new的区别</h1><ul><li><p>共同点：都是分配内存，对象都是指向不同的内存地址</p></li><li><p>不同点：new创建一个对象，clone复制一个对象。new是返回的新对象，而调用clone()方法时，拷贝对象已经包含了一些原来对象的信息，而不是对象的初始信息</p></li></ul><h1 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h1><p>在Object类的clone()是一个native方法，如果实现clone()方法的类没有实现Cloneable接口，并调用了Object的clone()方法（也就是调用了 super.clone()方法），那么Object的clone()方法就会抛出CloneNotSupportedException异常</p><p><a href="https://www.jianshu.com/p/e8c6155d9694" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本类型和引用类型在内存中的保存&quot;&gt;&lt;a href=&quot;#基本类型和引用类型在内存中的保存&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型在内存中的保存&quot;&gt;&lt;/a&gt;基本类型和引用类型在内存中的保存&lt;/h1&gt;&lt;p&gt;Java中数据类型分为两大类：&lt;strong&gt;基本类型和对象类型&lt;/strong&gt;&lt;br&gt;变量也有两种类型：&lt;strong&gt;基本类型和引用类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本类型的变量保存原始值，即它代表的值就是数值本身&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;引用类型的变量保存引用值，”引用值”指向内存空间的地址，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置&lt;/strong&gt;。&lt;br&gt;基本类型包括：byte,short,int,long,char,float,double,boolean&lt;br&gt;引用类型包括：类类型，接口类型和数组&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JAVA拷贝" scheme="https://sqwyyy.github.io/tags/JAVA%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-05-25T13:32:05.000Z</published>
    <updated>2020-08-18T06:50:53.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用阻塞队列"><a href="#为什么要用阻塞队列" class="headerlink" title="为什么要用阻塞队列"></a>为什么要用阻塞队列</h1><p>在并发编程中，有时候需要使用<strong>线程安全的队列</strong>。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。</p><ol><li>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li><li>非阻塞的实现方式则可以使用循环CAS的方式来实现。</li></ol><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<strong>这两个附加的操作支持阻塞的插入和移除方法</strong>, 意指再读取和插入操作情况下可能(注意是可能)会出现阻塞。</p><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>该阻塞队列是<strong>基于数组实现的，必须制定大小且不可变</strong>，同时使用ReentrantLock来实现并发问题的解决。同时需要注意的是<strong>ArrayBlockingQueue只有一把锁，put和take操作会相互阻塞</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;  <span class="comment">//队列的底层为数组，是个循环数组</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;  <span class="comment">//从队列中取元素的索引，用于take、poll、remove</span></span><br><span class="line"><span class="keyword">int</span> putIndex;  <span class="comment">//向队列中存放元素的索引，用于put、offer、add</span></span><br><span class="line"><span class="keyword">int</span> count;  <span class="comment">//队列中的元素数</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock; <span class="comment">//队列中的锁机制，可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">//notEmpty条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  <span class="comment">//notFull条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;  <span class="comment">//迭代器对象</span></span><br></pre></td></tr></table></figure><p>put操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Objects.requireNonNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>take 操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>LinkedBlockingQueue和ArrayBlockingQueue十分相似，其底层是<strong>借由链表</strong>实现。除此之外，还有一个不同点，<strong>LinkedBlockingQueue拥有两个锁，因此put和take的线程可以同时运行</strong>,count元素是用AtomicInteger来修饰的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;  <span class="comment">//元素</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//next指针</span></span><br><span class="line">        </span><br><span class="line">        Node(E x) &#123;  <span class="comment">//有参构造函数</span></span><br><span class="line">          item = x;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;  <span class="comment">//容量，默认为 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();  <span class="comment">//队列中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;  <span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//拿锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();  <span class="comment">//拿锁的条件，队列不为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">//放锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();  <span class="comment">//放锁的条件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>put操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">             * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">             * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">             * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">             * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">             * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>take操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E x;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p>PriorityBlockingQueue可以根据自定义的优先级来构建一个有序的二叉堆数据结构，这种结构在插入数据的时候就能够根据自定义的排序规则（对象实现Compareable和Comparator）来生成一个有序的堆，通过这样来定义一个按优先级顺序的队列集合，不再是默认的先进先出规则，需要注意的是优先级队列的put方法并不阻塞，默认的数组的长度是11，在插入满的时候会扩容。take方法在队列为空的时候会进入阻塞状态。</p><h1 id="生产者消费者模型的实现"><a href="#生产者消费者模型的实现" class="headerlink" title="生产者消费者模型的实现"></a>生产者消费者模型的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/29 - 18:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; q;</span><br><span class="line">    <span class="keyword">public</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> Condition producelock = lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> Condition wastelock = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span>  <span class="title">produce</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(cnt == num) &#123;</span><br><span class="line">                    producelock.await();</span><br><span class="line">                &#125;</span><br><span class="line">                String tmp = <span class="string">"生产线程"</span>+Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">"我已经制造了"</span>+Thread.currentThread().getName());</span><br><span class="line">                cnt++;</span><br><span class="line">                q.add(tmp);</span><br><span class="line">                wastelock.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">wate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    wastelock.await();</span><br><span class="line">                &#125;</span><br><span class="line">                String tmp = q.poll();</span><br><span class="line">                System.out.println(tmp);</span><br><span class="line">                <span class="comment">//System.out.println("我已经消耗了"+Thread.currentThread().getName()+" "+tmp);</span></span><br><span class="line">                cnt--;</span><br><span class="line">                producelock.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool(<span class="number">3</span>);</span><br><span class="line">        produce p = pool.<span class="keyword">new</span> produce();</span><br><span class="line">        wate w = pool.<span class="keyword">new</span> wate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(p).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(w).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要用阻塞队列&quot;&gt;&lt;a href=&quot;#为什么要用阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;为什么要用阻塞队列&quot;&gt;&lt;/a&gt;为什么要用阻塞队列&lt;/h1&gt;&lt;p&gt;在并发编程中，有时候需要使用&lt;strong&gt;线程安全的队列&lt;/strong&gt;。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。&lt;/li&gt;
&lt;li&gt;非阻塞的实现方式则可以使用循环CAS的方式来实现。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/categories/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/tags/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis常见问题</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-25T13:30:21.000Z</published>
    <updated>2020-05-25T13:31:20.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis快的原因"><a href="#redis快的原因" class="headerlink" title="redis快的原因"></a>redis快的原因</h1><a id="more"></a><h2 id="IO多路复用阻塞机制"><a href="#IO多路复用阻塞机制" class="headerlink" title="IO多路复用阻塞机制"></a>IO多路复用阻塞机制</h2><h3 id="为什么需要使用IO多路复用"><a href="#为什么需要使用IO多路复用" class="headerlink" title="为什么需要使用IO多路复用"></a>为什么需要使用IO多路复用</h3><p>Redis 是跑在<strong>单线程</strong>中的，所有的操作都是按照顺序线性执行的，但是<strong>由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务</strong>，而 I/O 多路复用就是为了解决这个问题而出现的。</p><h3 id="什么是I-O-多路复用"><a href="#什么是I-O-多路复用" class="headerlink" title="什么是I/O 多路复用"></a>什么是I/O 多路复用</h3><p><strong>I/O 多路复用其实是在单个线程中通过记录跟踪每一个sock（I/O流） 的状态来管理多个I/O流</strong>。<br>select, poll, epoll 都是I/O多路复用的具体的实现。epoll性能比其他几者要好。redis中的I/O多路复用的所有功能通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的。</p><h2 id="数据结构简单，操作节省时间"><a href="#数据结构简单，操作节省时间" class="headerlink" title="数据结构简单，操作节省时间"></a>数据结构简单，操作节省时间</h2><h2 id="运行在内存中"><a href="#运行在内存中" class="headerlink" title="运行在内存中"></a>运行在内存中</h2><h1 id="Redis的数据淘汰机制"><a href="#Redis的数据淘汰机制" class="headerlink" title="Redis的数据淘汰机制"></a>Redis的数据淘汰机制</h1><ul><li><p>volatile-lru 从<strong>已设置过期时间</strong>的数据集中挑选<strong>最近最少使用的数据</strong>淘汰</p></li><li><p>volatile-ttl 从<strong>已设置过期时间</strong>的数据集中挑选将<strong>要过期的数据</strong>淘汰</p></li><li>volatile-random从<strong>已设置过期时间</strong>的数据集中<strong>任意选择数据</strong>淘汰</li><li>allkeys-lru从<strong>所有数据集</strong>中挑选<strong>最近最少使用</strong>的数据淘汰</li><li>allkeys-random从<strong>所有数据集</strong>中<strong>任意选择数据进行淘汰noeviction禁止驱逐数据</strong></li></ul><h1 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h1><ul><li><p>RDB 持久化</p><ol><li><p>RDB持久化是将某个时间点上Redis中的数据保存到一个RDB文件中,该文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时Redis中的数据</p></li><li><p>Redis提供了2个命令来创建RDB文件，一个是SAVE，另一个是BGSAVE。</p><ul><li>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li><li>BGSAVE命令会派生出一个<strong>子进程</strong>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</li></ul></li><li>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</li><li>如果数据量很大，保存快照的时间会很长。</li></ol></li><li><p>AOF 持久化</p><ol><li><p>AOF持久化是通过将Redis服务器执行的所有写命令保存到AOF文件中来实现持久化的</p></li><li><p><strong>将写命令添加到 AOF 文件（Append Only File）的末尾</strong>。</p><ul><li><p>当AOF持久化功能处于打开状态时，Redis服务器在<strong>执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的AOF缓冲区的末尾</strong>，然后<strong>Redis服务器会根据配置文件中appendfsync选项的值来决定何时将AOF缓冲区中的内容写入和同步到AOF文件*</strong>里面有以下同步选项：</p><ol><li><p>always 选项会严重减低服务器的性能,<strong>服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件</strong>，并且同步AOF文件；</p></li><li><p>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，<strong>因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行同步</strong>；</p></li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量,<strong>因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制</strong></li></ol></li></ul><ol><li><p>为了解决AOF文件体积越来越大的问题，Redis提供了AOF文件重写功能<br>实现原理:</p><ol><li><strong>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令</strong>。</li></ol><p>AOF后台重写:</p><ol><li><p>服务器进程创建<strong>子进程</strong>，子进程开始AOF文件重写</p></li><li><p>从创建子进程开始，服务器进程执行的所有写命令不仅要写入AOF缓冲区，还要写入AOF重写缓冲区<br>写入AOF缓冲区的目的是为了同步到原有的AOF文件。<br>写入AOF重写缓冲区的目的是因为子进程在进行AOF文件重写期间，服务器进程还在继续处理命令请求，<br>而新的命令可能会对现有的数据库进行修改，从而使得服务器当前的数据库数据和重写后的AOF文件所<br>保存的数据库数据不一致。</p></li><li><p>子进程完成AOF重写工作，向父进程发送一个信号，父进程在接收到该信号后，会执行以下操作：</p><ol><li><p>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这样就保证了新AOF文件所保存的数据库数据和服务器当前的数据库数据是一致的。</p></li><li><p>对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p></li></ol></li></ol></li><li><p>采用子进程的好处:</p><ol><li><p>子进程进行AOF文件重写期间，服务器进程（父进程）可以继续处理命令请求。<br>子进程带有服务器进程的数据副本，</p></li><li><p>使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</p></li></ol></li></ol></li></ol></li></ul><p><a href="https://zhuanlan.zhihu.com/p/106997927" target="_blank" rel="noopener">RDB与AOF详解</a></p><h1 id="缓存穿透，缓存雪崩以及缓存击穿"><a href="#缓存穿透，缓存雪崩以及缓存击穿" class="headerlink" title="缓存穿透，缓存雪崩以及缓存击穿"></a>缓存穿透，缓存雪崩以及缓存击穿</h1><ul><li><p>缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。</p></li><li><p>缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中</p></li><li>缓存雪崩：就是大量数据同一时间失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</li><li>打个比方，你是个很有钱的人，开满了百度云，腾讯视频各种杂七杂八的会员，但是你就是没有netflix的会员，然后你把这些账号和密码发布到一个你自己做的网站上，然后你有一个朋友每过十秒钟就查询你的网站，发现你的网站没有Netflix的会员后打电话向你要。你就相当于是个数据库，网站就是Redis。这就是缓存穿透。</li><li>大家都喜欢看腾讯视频上的《水果传》，但是你的会员突然到期了，大家在你的网站上看不到腾讯视频的账号，纷纷打电话向你询问，这就是缓存击穿</li><li>你的各种会员突然同一时间都失效了，那这就是缓存雪崩了。</li></ul><p>解决方法</p><ul><li><p>缓存穿透：</p><ol><li><p>使用布隆过滤器判断改数据是否存在 <a href="https://zhuanlan.zhihu.com/p/72378274" target="_blank" rel="noopener">布隆过滤器</a></p></li><li><p>缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击</p></li></ol></li><li><p>缓存击穿：</p><ol><li>最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员</li></ol></li><li><p>缓存雪崩：</p><ol><li><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p></li><li><p>通过加锁或者队列来控制读数据库写缓存的线程数量。</p></li><li>通过synchronized+双重检查机制：某个key只让一个线程查询，阻塞其它线程</li></ol></li></ul><h1 id="缓存和数据库间的一致性问题"><a href="#缓存和数据库间的一致性问题" class="headerlink" title="缓存和数据库间的一致性问题"></a>缓存和数据库间的一致性问题</h1><p>读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：<strong>数据库和缓存更新</strong>，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。</p><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p><ol><li><p>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p></li><li><p>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p></li></ol><p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><ul><li><p>采用延时双删策略</p><ul><li>先删除缓存；</li><li>再写数据库；</li><li>休眠500毫秒；</li><li>再次删除缓存。</li></ul></li><li><p>设置缓存过期时间<br>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p></li><li><p>该方案的弊端<br>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p></li></ul><h3 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h3><p>技术整体思路：</p><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><ul><li><p>读Redis：热数据基本都在Redis</p></li><li><p>写MySQL:增删改都是操作MySQL</p></li><li>更新Redis数据：MySQ的数据操作binlog，来更新到Redis<br>Redis更新</li></ul><ol><li><p>数据操作主要分为两大块：</p><ul><li><p>一个是全量(将全部数据一次写入到redis)</p></li><li><p>一个是增量（实时更新）<br>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p></li></ul></li><li><p>读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</p></li><li><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p></li><li><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p></li><li><p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p></li><li><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p></li></ol><p><a href="https://zhuanlan.zhihu.com/p/58536781" target="_blank" rel="noopener">解决redis和数据库间数据一致性的问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis快的原因&quot;&gt;&lt;a href=&quot;#redis快的原因&quot; class=&quot;headerlink&quot; title=&quot;redis快的原因&quot;&gt;&lt;/a&gt;redis快的原因&lt;/h1&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
  </entry>
  
</feed>
