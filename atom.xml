<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-05-25T13:09:53.849Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sql语句练习</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</id>
    <published>2020-05-25T13:08:57.000Z</published>
    <updated>2020-05-25T13:09:53.849Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`salaries`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`salary`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`from_date`</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ( </span><br><span class="line">(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> emp_no = <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">to_date</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>) -</span><br><span class="line">(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> emp_no = <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">to_date</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>)</span><br><span class="line">) <span class="keyword">AS</span> growth</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`departments`</span> (</span><br><span class="line"><span class="string">`dept_no`</span> <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`dept_name`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`dept_no`</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`dept_emp`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`dept_no`</span> <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`dept_no`</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`birth_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`last_name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`gender`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`hire_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> departments.dept_name,employees.last_name,employees.first_name</span><br><span class="line"><span class="keyword">from</span> departments <span class="keyword">left</span> <span class="keyword">join</span> dept_emp <span class="keyword">on</span> departments.dept_no = dept_emp.dept_no</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> employees <span class="keyword">on</span> employees.emp_no = dept_emp.emp_no;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">本题思路为运用两次LEFT JOIN连接嵌套</span><br><span class="line">1、第一次LEFT JOIN连接employees表与dept_emp表，</span><br><span class="line">得到所有员工的last_name和first_name以及对应的dept_no，</span><br><span class="line">也包括暂时没有分配部门的员工</span><br><span class="line">2、第二次LEFT JOIN连接上表与departments表，</span><br><span class="line">即连接dept_no与dept_name，得到所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
      <category term="sql练习" scheme="https://sqwyyy.github.io/tags/sql%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试题</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-05-25T13:07:44.000Z</published>
    <updated>2020-05-25T13:08:22.793Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="主键、外键、超键、候选键"><a href="#主键、外键、超键、候选键" class="headerlink" title="主键、外键、超键、候选键"></a>主键、外键、超键、候选键</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。<br>候选键：是最小超键，即没有冗余元素的超键。<br>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。<br>外键：在一个表中存在的另一个表的主键称此表的外键。</p><h2 id="为什么用自增列作为主键"><a href="#为什么用自增列作为主键" class="headerlink" title="为什么用自增列作为主键"></a>为什么用自增列作为主键</h2><p>innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。</p><h2 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h2><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p><h2 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。<br>调用：<br>1）可以用一个命令对象来调用存储过程。<br>2）可以供外部程序调用，比如：java程序。</p><h1 id="什么是临时表，临时表什么时候删除"><a href="#什么是临时表，临时表什么时候删除" class="headerlink" title="什么是临时表，临时表什么时候删除"></a>什么是临时表，临时表什么时候删除</h1><ul><li>什么是临时表: MySQL用于存储一些中间结果集的表，临时表只在当前连接可见。</li><li>临时表什么时候删除: 当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。</li></ul><h2 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h2><p>优点：<br>1）存储过程是预编译过的，执行效率高。<br>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。<br>3）安全性高，执行存储过程需要有一定权限的用户。<br>4）存储过程可以重复使用，可减少数据库开发人员的工作量。<br>缺点：移植性差</p><h2 id="drop、truncate、-delete区别"><a href="#drop、truncate、-delete区别" class="headerlink" title="drop、truncate、 delete区别"></a>drop、truncate、 delete区别</h2><p>最基本：<br>drop直接删掉表。<br>truncate删除表中数据，再插入时自增长id又从1开始。<br>delete删除表中数据，可以加where字句。<br>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。<br>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。<br>（3） 一般而言，drop &gt; truncate &gt; delete<br>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view<br>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。<br>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。<br>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。<br>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。<br>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。<br>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。<br>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p><h2 id="查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序"></a>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序</h2><ul><li>from:需要从哪个数据表检索数据</li><li>where:过滤表中数据的条件</li><li>group by:如何将上面过滤出的数据分组</li><li>having:对上面已经分组的数据进行过滤的条件</li><li>select:查看结果集中的哪个列，或列的计算结果</li><li>order by :按照什么样的顺序来查看返回的数据</li></ul><h2 id="非关系型数据库和关系型数据库区别，优势比较"><a href="#非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="非关系型数据库和关系型数据库区别，优势比较?"></a>非关系型数据库和关系型数据库区别，优势比较?</h2><p>非关系型数据库的优势：</p><ol><li>性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li>可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ol><p>关系型数据库的优势：</p><ol><li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持：使得对于安全性能很高的数据访问要求得以实现。</li></ol><h2 id="SQL语言分类"><a href="#SQL语言分类" class="headerlink" title="SQL语言分类"></a>SQL语言分类</h2><ol><li>数据查询语言DQL(SELECT FROM WHERE子句构成的查询块)</li><li>数据操纵语言DML(INSERT UPDATE DELETE)</li><li>数据定义语言DDL(CREATE TABLE/VIEW/INDEX)</li><li>数据控制语言DCL(GRANT：授权 ROLLBACK回滚 COMMIT提交)</li></ol><h2 id="like-和-的区别"><a href="#like-和-的区别" class="headerlink" title="like %和-的区别"></a>like %和-的区别</h2><p>%百分号通配符:表示任何字符出现任意次数(可以是0次).<br><strong>_下划线通配符:</strong>表示只能匹配单个字符,不能多也不能少,就是一个字符.<br>like操作符: LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><h2 id="MYSQL的存储引擎"><a href="#MYSQL的存储引擎" class="headerlink" title="MYSQL的存储引擎"></a>MYSQL的存储引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别以及如何选择"><a href="#MySQL存储引擎MyISAM与InnoDB区别以及如何选择" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别以及如何选择"></a>MySQL存储引擎MyISAM与InnoDB区别以及如何选择</h3><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </li><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；</li><li>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</li><li>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</li><li>MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。<br>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。<br>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。<br>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。<br>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。</li></ol><h3 id="MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a>MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</h3><p>事务处理上方面<br>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。<br>锁级别<br>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。<br><a href="https://blog.csdn.net/qq_35642036/article/details/82820178" target="_blank" rel="noopener">来源</a></p><h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p><strong>1NF的定义为：符合1NF的关系中的每个属性都不可再分,具有原子性</strong></p><h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p><strong>满足1NF的基础上，要求：表中的所有列，都必需依赖于主键，而不能有任何一列与主键没有关系</strong></p><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p><strong>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</strong></p><p><a href="https://zhuanlan.zhihu.com/p/20028672" target="_blank" rel="noopener">数据库范式</a></p><h1 id="主从复制，分库分表？"><a href="#主从复制，分库分表？" class="headerlink" title="主从复制，分库分表？"></a>主从复制，分库分表？</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;主键、外键、超键、候选键&quot;&gt;&lt;a href=&quot;#主键、外键、超键、候选键&quot; class=&quot;headerlink&quot; title=&quot;主键、外键、超键、候选键&quot;&gt;&lt;/a&gt;主键、外键、超键、候选键&lt;/h2&gt;&lt;p&gt;超键：在关系中能唯一标识
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql优化</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E4%BC%98%E5%8C%96/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2020-05-25T13:06:50.000Z</published>
    <updated>2020-05-25T13:07:24.982Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h1><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，<strong>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</strong></p><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，<strong>应该尽量把字段设置为NOTNULL</strong>，这样在将来执行查询的时候，数据库不用去比较NULL值。 对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h1 id="使用连接查询来代替子查询"><a href="#使用连接查询来代替子查询" class="headerlink" title="使用连接查询来代替子查询"></a>使用连接查询来代替子查询</h1><p>例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CustomerID <span class="keyword">FROM</span> salesinfo)</span><br></pre></td></tr></table></figure><br>子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> salesinfo <span class="keyword">ON</span> customerinfo.CustomerID=salesinfo.CustomerID</span><br><span class="line"><span class="keyword">WHERE</span> salesinfo.CustomerID <span class="keyword">ISNULL</span></span><br></pre></td></tr></table></figure><p>连接查询</p><p>内连接：只显示两表id匹配的<br>左外连接：显示join左边的表的所有数据（不管两表是否匹配），对于不匹配的部分都用NULL显示<br>右外连接：与左外连接相反，显示join右边的表的所有数据<br><a href="https://blog.csdn.net/doubleguy/article/details/89708227" target="_blank" rel="noopener">来源</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--内连接（只显示两表id匹配的）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">inner</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--左外连接（显示join左边的表的所有数据，exam只有两条记录，所以stu.id,grade都用NULL显示）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">left</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--右外连接（与左外连接相反，显示join右边的表的所有数据）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">right</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br></pre></td></tr></table></figure></p><h2 id="子查询比连接查询慢的原因是"><a href="#子查询比连接查询慢的原因是" class="headerlink" title="子查询比连接查询慢的原因是"></a>子查询比连接查询慢的原因是</h2><p><strong>执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，<strong>就是可以保持数据库中数据的一致性和完整性</strong>。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><ol><li><p>原子性。事务是数据库的逻辑工作单位，<strong>事务中包含的各操作要么都做，要么都不做</strong></p></li><li><p>一致性。<strong>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</strong>。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p></li><li><p>隔离性。<strong>在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰</strong>。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p>持续性。也称永久性，<strong>指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的</strong>。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><h2 id="事务并发可能出现的问题"><a href="#事务并发可能出现的问题" class="headerlink" title="事务并发可能出现的问题"></a>事务并发可能出现的问题</h2></li><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：在一个事务的两次查询之中数据不一致，事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li><li>幻读：例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ol><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommitted（读取未提交内容）-RU"><a href="#Read-Uncommitted（读取未提交内容）-RU" class="headerlink" title="Read Uncommitted（读取未提交内容） RU"></a>Read Uncommitted（读取未提交内容） RU</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><h3 id="Read-Committed（读取提交内容）RC"><a href="#Read-Committed（读取提交内容）RC" class="headerlink" title="Read Committed（读取提交内容）RC"></a>Read Committed（读取提交内容）RC</h3><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><h3 id="Repeatable-Read（可重读）RR"><a href="#Repeatable-Read（可重读）RR" class="headerlink" title="Repeatable Read（可重读）RR"></a>Repeatable Read（可重读）RR</h3><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p><h2 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h2><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><div class="table-container"><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>x</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>x</td><td>x</td><td>√</td></tr><tr><td>Serializable</td><td>x</td><td>x</td><td>x</td></tr></tbody></table></div><h1 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mvcc是多版本并发控制 ，它是数据库管理系统一种常见的并发控制。</p><ul><li>事务版本号:每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</li><li><p>表格的隐藏列</p><ul><li>DB_TRX_ID: 记录操作该数据事务的事务ID；</li><li>DB_ROLL_PTR：指向上一个版本数据在undo log 里的位置指针；</li><li>DB_ROW_ID: 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</li><li>undoLog: 事务的回滚日志</li><li><p>Read view: 在innodb 中每个SQL语句执行前都会得到一个read_view</p><ul><li><p>trx_ids: trx_ids为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）</p></li><li><p>low_limit_id: 当前最大的事务号 + 1，事务号 &gt;= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。</p></li><li>up_limit_id: 当前已经提交的事务号 + 1，事务号 &lt; up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。</li></ul></li></ul></li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li><p>获取当前事务版本号</p></li><li><p>获得一个readview</p></li><li>查到数据，与readview的事务版本号进行匹配</li><li>不符合readview的规则，就从undo lo获取历史版本数据</li><li>返回符合规则的数据</li></ol><p>RC(read commit) 级别下<strong>同一个事务里面的每一次查询都会获得一个新的read view副本</strong>。这样就可能造成同一个事务里前后读取数据可能不一致的问题（幻读）</p><p>RR(重复读)级别下的<strong>一个事务里只会获取一次read view副本</strong>，从而保证每次查询的数据都是一样的。</p><h2 id="mvcc并未解决幻读问题"><a href="#mvcc并未解决幻读问题" class="headerlink" title="mvcc并未解决幻读问题"></a>mvcc并未解决幻读问题</h2><p>例如:<br>一开始表中有一条数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|id|name|</span><br><span class="line">|1|开发部|</span><br></pre></td></tr></table></figure><br>| 事务一                        | 事务二                                  |<br>| ——————————————- | ———————————————————- |<br>| begin                         | begin                                   |<br>| select * from dept            | -                                       |<br>| -                             | insert into dept(name) values(“研发部”) |<br>| -                             | commit                                  |<br>| update dept set name=”财务部” | -                                       |<br>| commit                        | -                                       |</p><p>上面的结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id name</span><br><span class="line">1 开发部</span><br><span class="line">9 开发部</span><br></pre></td></tr></table></figure><br>产生了幻读</p><p><strong>解决幻读的方法是添加next-key lock</strong></p><p><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68" target="_blank" rel="noopener">mvcc</a><br><a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">mvcc</a></p><h2 id="数据中的锁"><a href="#数据中的锁" class="headerlink" title="数据中的锁"></a>数据中的锁</h2><h3 id="读的分类"><a href="#读的分类" class="headerlink" title="读的分类"></a>读的分类</h3><ul><li>快照读是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</li><li>当前读是基于 临键锁（行锁 + 间歇锁）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。<br><a href="https://www.cnblogs.com/AlmostWasteTime/p/11466520.html" target="_blank" rel="noopener">快照读与当前读</a><h3 id="按锁的粒度分类"><a href="#按锁的粒度分类" class="headerlink" title="按锁的粒度分类:"></a>按锁的粒度分类:</h3></li></ul><ol><li>行锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。行级锁<strong>分为共享锁和排他锁。</strong></li><li>页锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li><li>表锁:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。<br>表级锁定分为表<strong>共享读锁（共享锁）与表独占写锁（排他锁）</strong></li></ol><p>InnoDB行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！(innodb和myISAM都不支持页锁)</p><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。<br>排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。<br>我们<strong>通过update、delete等语句加上的锁都是行级别的锁</strong>。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。<br>意向共享锁(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br>意向排他锁(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p><h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><ol><li>行锁:该锁是对索引记录进行加锁,innodb中一定存在聚簇索引，所以行锁最终在聚簇索引上.</li><li>间隙锁:是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<strong>Read Committed隔离级别下，隔离级别比Read Committed低的情况下，都不会使用间隙锁</strong></li><li>Next-Key Locks：这个理解为行锁+索引前面的间隙锁。<br>比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10](负无穷)</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><strong>表锁是通过Next-Key Locks来实现的锁表操作。</strong><h2 id="锁的用法"><a href="#锁的用法" class="headerlink" title="锁的用法"></a>锁的用法</h2>SELECT … LOCK IN SHARE MODE 共享行锁<br>SELECT … FOR UPDATE 排他行锁<br>LOCK TABLE … READ 共享读锁<br>LOCK TABLE … WRITE 排他写锁</li></ol><p><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">锁的详解</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><h1 id="优化sql语句"><a href="#优化sql语句" class="headerlink" title="优化sql语句"></a>优化sql语句</h1><ol><li>能用到索引尽量用到索引.对索引的优化实际上就是sql语句的调优</li><li>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段</li><li>尽量使用where,而不要使用having</li><li>尽量使用多表查询,不要使用子查询</li><li>where后的and.or左右执行顺序是从右至左,运算符为and时–尽量把为假的放在右边,运算符为or时–尽量把为真的放在右边</li></ol><h1 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h1><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Phone <span class="keyword">FROM</span> <span class="keyword">client</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,BirthDate <span class="keyword">FROM</span> author <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Supplier <span class="keyword">FROM</span> product</span><br></pre></td></tr></table></figure><br><a href="https://zhuanlan.zhihu.com/p/86871140" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;选取最适用的字段属性&quot;&gt;&lt;a href=&quot;#选取最适用的字段属性&quot; class=&quot;headerlink&quot; title=&quot;选取最适用的字段属性&quot;&gt;&lt;/a&gt;选取最适用的字段属性&lt;/h1&gt;&lt;p&gt;MySQL可以很好的支持大数据量的存取，
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2020-05-25T13:05:57.000Z</published>
    <updated>2020-05-25T13:06:37.409Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h1><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，<strong>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</strong></p><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，<strong>应该尽量把字段设置为NOTNULL</strong>，这样在将来执行查询的时候，数据库不用去比较NULL值。 对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h1 id="使用连接查询来代替子查询"><a href="#使用连接查询来代替子查询" class="headerlink" title="使用连接查询来代替子查询"></a>使用连接查询来代替子查询</h1><p>例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CustomerID <span class="keyword">FROM</span> salesinfo)</span><br></pre></td></tr></table></figure><br>子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> salesinfo <span class="keyword">ON</span> customerinfo.CustomerID=salesinfo.CustomerID</span><br><span class="line"><span class="keyword">WHERE</span> salesinfo.CustomerID <span class="keyword">ISNULL</span></span><br></pre></td></tr></table></figure><p>连接查询</p><p>内连接：只显示两表id匹配的<br>左外连接：显示join左边的表的所有数据（不管两表是否匹配），对于不匹配的部分都用NULL显示<br>右外连接：与左外连接相反，显示join右边的表的所有数据<br><a href="https://blog.csdn.net/doubleguy/article/details/89708227" target="_blank" rel="noopener">来源</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--内连接（只显示两表id匹配的）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">inner</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--左外连接（显示join左边的表的所有数据，exam只有两条记录，所以stu.id,grade都用NULL显示）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">left</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--右外连接（与左外连接相反，显示join右边的表的所有数据）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">right</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br></pre></td></tr></table></figure></p><h2 id="子查询比连接查询慢的原因是"><a href="#子查询比连接查询慢的原因是" class="headerlink" title="子查询比连接查询慢的原因是"></a>子查询比连接查询慢的原因是</h2><p><strong>执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，<strong>就是可以保持数据库中数据的一致性和完整性</strong>。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><ol><li><p>原子性。事务是数据库的逻辑工作单位，<strong>事务中包含的各操作要么都做，要么都不做</strong></p></li><li><p>一致性。<strong>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</strong>。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p></li><li><p>隔离性。<strong>在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰</strong>。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p>持续性。也称永久性，<strong>指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的</strong>。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><h2 id="事务并发可能出现的问题"><a href="#事务并发可能出现的问题" class="headerlink" title="事务并发可能出现的问题"></a>事务并发可能出现的问题</h2></li><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：在一个事务的两次查询之中数据不一致，事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li><li>幻读：例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ol><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommitted（读取未提交内容）-RU"><a href="#Read-Uncommitted（读取未提交内容）-RU" class="headerlink" title="Read Uncommitted（读取未提交内容） RU"></a>Read Uncommitted（读取未提交内容） RU</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><h3 id="Read-Committed（读取提交内容）RC"><a href="#Read-Committed（读取提交内容）RC" class="headerlink" title="Read Committed（读取提交内容）RC"></a>Read Committed（读取提交内容）RC</h3><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><h3 id="Repeatable-Read（可重读）RR"><a href="#Repeatable-Read（可重读）RR" class="headerlink" title="Repeatable Read（可重读）RR"></a>Repeatable Read（可重读）RR</h3><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p><h2 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h2><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><div class="table-container"><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>x</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>x</td><td>x</td><td>√</td></tr><tr><td>Serializable</td><td>x</td><td>x</td><td>x</td></tr></tbody></table></div><h1 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mvcc是多版本并发控制 ，它是数据库管理系统一种常见的并发控制。</p><ul><li>事务版本号:每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</li><li><p>表格的隐藏列</p><ul><li>DB_TRX_ID: 记录操作该数据事务的事务ID；</li><li>DB_ROLL_PTR：指向上一个版本数据在undo log 里的位置指针；</li><li>DB_ROW_ID: 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</li><li>undoLog: 事务的回滚日志</li><li><p>Read view: 在innodb 中每个SQL语句执行前都会得到一个read_view</p><ul><li><p>trx_ids: trx_ids为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）</p></li><li><p>low_limit_id: 当前最大的事务号 + 1，事务号 &gt;= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。</p></li><li>up_limit_id: 当前已经提交的事务号 + 1，事务号 &lt; up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。</li></ul></li></ul></li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li><p>获取当前事务版本号</p></li><li><p>获得一个readview</p></li><li>查到数据，与readview的事务版本号进行匹配</li><li>不符合readview的规则，就从undo lo获取历史版本数据</li><li>返回符合规则的数据</li></ol><p>RC(read commit) 级别下<strong>同一个事务里面的每一次查询都会获得一个新的read view副本</strong>。这样就可能造成同一个事务里前后读取数据可能不一致的问题（幻读）</p><p>RR(重复读)级别下的<strong>一个事务里只会获取一次read view副本</strong>，从而保证每次查询的数据都是一样的。</p><h2 id="mvcc并未解决幻读问题"><a href="#mvcc并未解决幻读问题" class="headerlink" title="mvcc并未解决幻读问题"></a>mvcc并未解决幻读问题</h2><p>例如:<br>一开始表中有一条数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|id|name|</span><br><span class="line">|1|开发部|</span><br></pre></td></tr></table></figure><br>| 事务一                        | 事务二                                  |<br>| ——————————————- | ———————————————————- |<br>| begin                         | begin                                   |<br>| select * from dept            | -                                       |<br>| -                             | insert into dept(name) values(“研发部”) |<br>| -                             | commit                                  |<br>| update dept set name=”财务部” | -                                       |<br>| commit                        | -                                       |</p><p>上面的结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id name</span><br><span class="line">1 开发部</span><br><span class="line">9 开发部</span><br></pre></td></tr></table></figure><br>产生了幻读</p><p><strong>解决幻读的方法是添加next-key lock</strong></p><p><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68" target="_blank" rel="noopener">mvcc</a><br><a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">mvcc</a></p><h2 id="数据中的锁"><a href="#数据中的锁" class="headerlink" title="数据中的锁"></a>数据中的锁</h2><h3 id="读的分类"><a href="#读的分类" class="headerlink" title="读的分类"></a>读的分类</h3><ul><li>快照读是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</li><li>当前读是基于 临键锁（行锁 + 间歇锁）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。<br><a href="https://www.cnblogs.com/AlmostWasteTime/p/11466520.html" target="_blank" rel="noopener">快照读与当前读</a><h3 id="按锁的粒度分类"><a href="#按锁的粒度分类" class="headerlink" title="按锁的粒度分类:"></a>按锁的粒度分类:</h3></li></ul><ol><li>行锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。行级锁<strong>分为共享锁和排他锁。</strong></li><li>页锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li><li>表锁:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。<br>表级锁定分为表<strong>共享读锁（共享锁）与表独占写锁（排他锁）</strong></li></ol><p>InnoDB行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！(innodb和myISAM都不支持页锁)</p><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。<br>排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。<br>我们<strong>通过update、delete等语句加上的锁都是行级别的锁</strong>。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。<br>意向共享锁(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br>意向排他锁(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p><h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><ol><li>行锁:该锁是对索引记录进行加锁,innodb中一定存在聚簇索引，所以行锁最终在聚簇索引上.</li><li>间隙锁:是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<strong>Read Committed隔离级别下，隔离级别比Read Committed低的情况下，都不会使用间隙锁</strong></li><li>Next-Key Locks：这个理解为行锁+索引前面的间隙锁。<br>比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10](负无穷)</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><strong>表锁是通过Next-Key Locks来实现的锁表操作。</strong><h2 id="锁的用法"><a href="#锁的用法" class="headerlink" title="锁的用法"></a>锁的用法</h2>SELECT … LOCK IN SHARE MODE 共享行锁<br>SELECT … FOR UPDATE 排他行锁<br>LOCK TABLE … READ 共享读锁<br>LOCK TABLE … WRITE 排他写锁</li></ol><p><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">锁的详解</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><h1 id="优化sql语句"><a href="#优化sql语句" class="headerlink" title="优化sql语句"></a>优化sql语句</h1><ol><li>能用到索引尽量用到索引.对索引的优化实际上就是sql语句的调优</li><li>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段</li><li>尽量使用where,而不要使用having</li><li>尽量使用多表查询,不要使用子查询</li><li>where后的and.or左右执行顺序是从右至左,运算符为and时–尽量把为假的放在右边,运算符为or时–尽量把为真的放在右边</li></ol><h1 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h1><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Phone <span class="keyword">FROM</span> <span class="keyword">client</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,BirthDate <span class="keyword">FROM</span> author <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Supplier <span class="keyword">FROM</span> product</span><br></pre></td></tr></table></figure><br><a href="https://zhuanlan.zhihu.com/p/86871140" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;选取最适用的字段属性&quot;&gt;&lt;a href=&quot;#选取最适用的字段属性&quot; class=&quot;headerlink&quot; title=&quot;选取最适用的字段属性&quot;&gt;&lt;/a&gt;选取最适用的字段属性&lt;/h1&gt;&lt;p&gt;MySQL可以很好的支持大数据量的存取，
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
      <category term="索引" scheme="https://sqwyyy.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/ThreadLocal/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/ThreadLocal/</id>
    <published>2020-05-25T13:02:05.000Z</published>
    <updated>2020-05-25T13:02:56.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaBase.LineDistance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉;</span></span><br><span class="line"><span class="comment"> * 〈功能详细描述〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> [相关类/方法]（可选）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> [产品/模块版本] （可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> MyThreadLocal();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程1："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程2："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程3："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">2</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">2</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">2</span>：<span class="number">3</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">3</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><h1 id="Threadlocal原理"><a href="#Threadlocal原理" class="headerlink" title="Threadlocal原理"></a>Threadlocal原理</h1><ol><li>void set(Object value)设置当前线程的线程局部变量的值。</li><li>public Object get()该方法返回当前线程所对应的线程局部变量。</li><li>public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li><li>protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</li></ol><h2 id="set方法的实现"><a href="#set方法的实现" class="headerlink" title="set方法的实现"></a>set方法的实现</h2><p>set方法是设置一个线程的局部变量的值，相当于当前线程通过set设置的局部变量的值，只对当前线程可见。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();<span class="comment">//获取当前执行的线程</span></span><br><span class="line">        ThreadLocalMap map = getMap(t); <span class="comment">//获得当前线程的ThreadLocalMap实例</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)<span class="comment">//如果map不为空，说明当前线程已经有了一个ThreadLocalMap实例</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);<span class="comment">//直接将当前value设置到ThreadLocalMap中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value); <span class="comment">//说明当前线程是第一次使用线程本地变量，构造map</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>map.set(this,value)中key是this，value是我们指定的值，this代表的是那个ThreadLocal类型的变量。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap是一个静态内部类，内部定义了一个Entry对象用来真正存储数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            <span class="comment">//构造一个Entry数组，并设置初始大小</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">//计算Entry数据下标</span></span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将`firstValue`存入到指定的table下标中</span></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;<span class="comment">//设置节点长度为1</span></span><br><span class="line">            setThreshold(INITIAL_CAPACITY); <span class="comment">//设置扩容的阈值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>每个线程自身都维护着一个ThreadLocalMap，用来存储线程本地的数据，可以简单理解成ThreadLocalMap的key是ThreadLocal变量，value是线程本地的数据。就这样很简单的实现了线程本地数据存储和交互访问。</p><h2 id="get方法的实现"><a href="#get方法的实现" class="headerlink" title="get方法的实现"></a>get方法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             T result = (T)e.value;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap中存放的就是Entry，Entry的KEY就是ThreadLocal，VALUE就是值。</p><h2 id="remo"><a href="#remo" class="headerlink" title="remo"></a>remo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();<span class="comment">//调用Entry的clear方法</span></span><br><span class="line">                    expungeStaleEntry(i);<span class="comment">//清除陈旧数据</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000017272578" target="_blank" rel="noopener">来源</a><br><a href="https://www.jianshu.com/p/69ae8c213b30" target="_blank" rel="noopener">来源</a><br><a href="https://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://sqwyyy.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/AQS/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/AQS/</id>
    <published>2020-05-25T12:59:22.000Z</published>
    <updated>2020-05-25T13:01:46.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AQS是一个抽象类，主要是通过继承的方式来使用，这个类在java.util.concurrent.locks包。<strong>一个用来实现同步锁以及其他涉及到同步功能的核心组件</strong>，列入有ReentrantLock、CountDownLatch等</p><a id="more"></a><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>从使用层面来说，AQS的功能分为两种：独占和共享</p><ol><li>独占锁，每次只能有一个线程持有锁，比如前面给大家演示的ReentrantLock就是以独占方式实现的互斥锁</li><li>共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><img src="1" alt="图片.png"></li></ol><h1 id="AQS源码（以ReentrantLock为例"><a href="#AQS源码（以ReentrantLock为例" class="headerlink" title="AQS源码（以ReentrantLock为例)"></a>AQS源码（以ReentrantLock为例)</h1><p>ReentrantLock.lock()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicvoid <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">   sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sync是一个静态内部类,它继承了AQS这个抽象类.Sync这个类有两个具体的实现分别是<strong>NofairSync(非公平锁)</strong>，<strong>FailSync(公平锁)</strong>.</p><ol><li>公平锁 表示所有线程严格按照FIFO来获取锁</li><li>非公平锁 表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁</li></ol><h2 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync.lock"></a>NonfairSync.lock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入acquire方法</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>acquire是AQS中的方法，如果CAS操作未能成功，说明state已经不为0，此时继续acquire(1)操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ol><li>通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false</li><li>如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部</li><li>acquireQueued，将Node作为参数，<strong>通过自旋去尝试获取锁</strong>。</li></ol><h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p>这个方法的作用是尝试获取锁，如果成功返回true，不成功返回false.它是重写AQS类中的tryAcquire方法,AQS中tryAcquire方法的定义，并没有实现，而是抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="nonfairTryAcquire方法"><a href="#nonfairTryAcquire方法" class="headerlink" title="nonfairTryAcquire方法"></a>nonfairTryAcquire方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">//获得state的值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//state=0说明当前是无锁状态</span></span><br><span class="line">        <span class="comment">//通过cas操作来替换state的值改为1，大家想想为什么要用cas呢？</span></span><br><span class="line">        <span class="comment">//理由是，在多线程环境中，直接修改state=1会存在线程安全问题，你猜到了吗？</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//保存当前获得锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这段逻辑就很简单了。如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">//增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="compareAndSetState方法"><a href="#compareAndSetState方法" class="headerlink" title="compareAndSetState方法"></a>compareAndSetState方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> STATE.compareAndSet(<span class="keyword">this</span>, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是通过cas乐观锁的方式来做比较并替换</p><ol><li>当state=0时，表示无锁状态</li><li>当state&gt;0时，表示已经有线程获得了锁，也就是state=1，但是因为ReentrantLock允许重入，所以同一个线程多次获得同步锁的时候，state会递增，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁</li></ol><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>当tryAcquire方法获取锁失败以后，则会先调用addWaiter将当前线程封装成Node，然后添加到AQS队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">//mode=Node.EXCLUSIVE</span></span><br><span class="line">        <span class="comment">//将当前线程封装成Node，并且mode为独占锁</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); </span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(node)方法</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//tail不为空的情况，说明队列中存在节点数据</span></span><br><span class="line">            node.prev = pred;  <span class="comment">//讲当前线程的Node的prev节点指向tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//通过cas讲node添加到AQS队列</span></span><br><span class="line">                pred.next = node;<span class="comment">//cas成功，把旧的tail的next指针指向新的tail</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">//tail=null，将node添加到同步队列中</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h3><p>enq就是通过自旋操作把当前节点加入队列中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail; <span class="comment">//如果是第一次添加到队列，那么tail=null</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//CAS的方式创建一个空的Node作为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   <span class="comment">//此时队列中只一个头结点，所以tail也指向它</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//进行第二次循环时，tail不为null，进入else区域。将当前线程的Node结点的prev指向tail，然后使用CAS将tail指向Node</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"><span class="comment">//t此时指向tail,所以可以CAS成功，将tail重新指向Node。此时t为更新前的tail的值，即指向空的头结点，t.next=node，就将头结点的后续结点指向Node，返回头结点</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>假如有两个线程t1,t2同时进入enq方法，t==null表示队列是首次使用，需要先初始化<br>另外一个线程cas失败，则进入下次循环，通过cas操作将node添加到队尾</p><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p>将添加到队列中的Node作为参数传入acquireQueued方法，这里面会做抢占锁的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 获取prev节点,若为null即刻抛出NullPointException</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 如果前驱为head才有资格进行锁的抢夺</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点</span></span><br><span class="line"><span class="comment">//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">//获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">// 若前面为true,则执行挂起,待下次唤醒的时候检测中断的标志</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果抛出异常则取消锁的获取,进行出队(sync queue)操作</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>获取当前节点的prev节点</li><li>如果prev节点为head节点，那么它就有资格去争抢锁，调用tryAcquire抢占锁</li><li>抢占锁成功以后，把获得锁的节点设置为head，并且移除原来的初始化head节点</li><li>如果获得锁失败，则根据waitStatus决定是否需要挂起线程</li><li>最后，通过cancelAcquire取消获得锁的操作</li></ol><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p>从上面的分析可以看出，只有队列的第二个节点可以有机会争用锁，如果成功获取锁，则此节点晋升为头节点。对于第三个及以后的节点，if (p == head)条件不成立，首先进行shouldParkAfterFailedAcquire(p, node)操作<br>shouldParkAfterFailedAcquire方法是判断一个争用锁的线程是否应该被阻塞。它首先判断一个节点的前置节点的状态是否为Node.SIGNAL，如果是，是说明此节点已经将状态设置-如果锁释放，则应当通知它，所以它可以安全的阻塞了，返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">//前继节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//如果是SIGNAL状态，意味着当前线程需要被unpark唤醒</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">如果前节点的状态大于<span class="number">0</span>，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回<span class="keyword">false</span>。在下次循环执行shouldParkAfterFailedAcquire时，返回<span class="keyword">true</span>。这个操作实际是把队列中CANCELLED的节点剔除掉。</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点'的前继节点”。</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release方法里面做两件事，1，释放锁 ；2，唤醒park的线程</p><h2 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个动作可以认为就是一个设置锁状态的操作，而且是将状态减掉传入的参数值（参数是1），如果结果状态为0，就将排它锁的Owner设置为null，以使得其它的线程有机会进行执行。<br>在排它锁中，加锁的时候状态会增加1（当然可以自己修改这个值），在解锁的时候减掉1，同一个锁，在可以重入后，可能会被叠加为2、3、4这些值，只有unlock()的次数与lock()的次数对应才会将Owner线程设置为空，而且也只有这种情况下才会返回true。</p><h2 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//判断后继节点是否为空或者是否是取消状态,</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点, 至于为什么从尾部开始向前遍历，因为在doAcquireInterruptibly.cancelAcquire方法的处理过程中只设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法unparkSuccessor(Node)中，就意味着真正要释放锁了，它传入的是head节点（head节点是占用锁的节点），当前线程被释放之后，需要唤醒下一个节点的线程</p><p><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;AQS是一个抽象类，主要是通过继承的方式来使用，这个类在java.util.concurrent.locks包。&lt;strong&gt;一个用来实现同步锁以及其他涉及到同步功能的核心组件&lt;/strong&gt;，列入有ReentrantLock、CountDownLatch等&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-05-25T12:57:16.000Z</published>
    <updated>2020-05-25T12:58:22.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用线程池的原因"><a href="#使用线程池的原因" class="headerlink" title="使用线程池的原因"></a>使用线程池的原因</h2><ol><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li><li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换<br><a href="https://www.jianshu.com/p/7726c70cdc40" target="_blank" rel="noopener">来源</a></li></ol><a id="more"></a><h2 id="线程池的主要参数"><a href="#线程池的主要参数" class="headerlink" title="线程池的主要参数"></a>线程池的主要参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> maximumPoolSize, // 线程数的上限</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">long</span> keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，</span></span></span><br><span class="line"><span class="function"><span class="params">                                     // 超过这个时间，多余的线程会被回收。</span></span></span><br><span class="line"><span class="function"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列</span></span></span><br><span class="line"><span class="function"><span class="params">  ThreadFactory threadFactory, // 新线程的产生方式</span></span></span><br><span class="line"><span class="function"><span class="params">  RejectedExecutionHandler handler)</span> <span class="comment">//拒绝策略</span></span></span><br></pre></td></tr></table></figure><ol><li>corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</li><li>maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</li><li>keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li><li>unit：存活时间单位（小时，分，秒等等）</li><li>workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</li><li>threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</li><li>handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。<h2 id="线程池流程"><a href="#线程池流程" class="headerlink" title="线程池流程"></a>线程池流程</h2></li><li>当提交一个新任务到线程池时首先线程池判断基本线程池(corePoolSize)是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程；</li><li>其次线程池判断工作队列(workQueue)是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程；</li><li>最后线程池判断整个线程池(maximumPoolSize)是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务；</li><li>如果线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；</li><li>如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过 keepAliveTime，线程也会被终止。</li></ol><h2 id="线程池为什么使用阻塞队列而不适用非阻塞队列"><a href="#线程池为什么使用阻塞队列而不适用非阻塞队列" class="headerlink" title="线程池为什么使用阻塞队列而不适用非阻塞队列"></a>线程池为什么使用阻塞队列而不适用非阻塞队列</h2><ol><li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。</li><li><p>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。使得在线程不至于一直占用cpu资源。</p><h2 id="java中提供的线程池"><a href="#java中提供的线程池" class="headerlink" title="java中提供的线程池"></a>java中提供的线程池</h2><p>Executors类提供了4种不同的线程池：newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool, newSingleThreadExecutor</p></li><li><p>newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>newScheduledThreadPool：适用于执行延时或者周期性任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2></li><li>RUNNING：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</li><li>SHUTDOWN： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>STOP ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>TIDYING ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；</li><li>TERMINATED： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2>RejectedExecutionHandler是一个接口：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当要创建的线程数量大于线程池的最大线程数的时候，新的任务就会被拒绝，就会调用这个接口里的这个方法。<br>可以自己实现这个接口，实现对这些超出数量的任务的处理。<br>ThreadPoolExecutor自己已经提供了四个拒绝策略，分别是<strong>CallerRunsPolicy,AbortPolicy,DiscardPolicy,DiscardOldestPolicy</strong><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3>ThreadPoolExecutor中默认的拒绝策略就是AbortPolicy。直接抛出异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mythread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程:"</span>+Thread.currentThread().getName() +<span class="string">" 执行:"</span>+name +<span class="string">"  run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">handerdom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,</span><br><span class="line">                TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"添加第"</span>+i+<span class="string">"个任务"</span>);</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Mythread(<span class="string">"线程"</span>+i));</span><br><span class="line">            Iterator iterator = executor.getQueue().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                Mythread thread = (Mythread) iterator.next();</span><br><span class="line">                System.out.println(<span class="string">"列表："</span>+thread.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task threadpoolexecutor.Mythread@7106e68e rejected from java.util.concurrent.ThreadPoolExecutor@7eda2dbb[Running, pool size &#x3D; 2, active threads &#x3D; 2, queued tasks &#x3D; 2, completed tasks &#x3D; 0]</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)</span><br><span class="line">at threadpoolexecutor.handerdom.main(handerdom.java:34)</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br></pre></td></tr></table></figure></li><li>添加第一个任务时，直接执行，任务列表为空。</li><li>添加第二个任务时，因为采用的LinkedBlockingDeque，，并且核心线程正在执行任务，所以会将第二个任务放在队列中，队列中有 线程1.</li><li>添加第三个任务时，也一样会放在队列中，队列中有 线程1，线程2.</li><li>添加第四个任务时，因为核心任务还在运行，而且任务队列已经满了，所以胡直接创建新线程执行第四个任务，。这时线程池中一共就有两个线程在运行了，达到了最大线程数。任务队列中还是有线程1， 线程2.</li><li>添加第五个任务时，再也没有地方能存放和执行这个任务了，就会被线程池拒绝添加，执行拒绝策略的rejectedExecution方法，这里就是执行AbortPolicy的rejectedExecution方法直接抛出异常。<br>最终，只有四个线程能完成运行。后面的都被拒绝了。<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3>CallerRunsPolicy在任务被拒绝添加后，<strong>会调用当前线程池的所在的线程去执行被拒绝的任务。</strong><br>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">线程:main 执行:线程4  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程2</span><br><span class="line">列表：线程5</span><br><span class="line">线程:pool-1-thread-1 执行:线程1  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程2  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程5  run</span><br></pre></td></tr></table></figure>这个策略的缺点就是可能会阻塞主线程。<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3>采用这个拒绝策略，会让被线程池拒绝的任务直接抛弃，不会抛异常也不会执行。<br>运行结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程2  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程1  run</span><br></pre></td></tr></table></figure><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3>当任务被拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的弹出，再把这个新任务添加进去。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">列表：线程2</span><br><span class="line">列表：线程4</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程4</span><br><span class="line">列表：线程5</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程5  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程4  run</span><br></pre></td></tr></table></figure></li><li>在添加第五个任务时，会被线程池拒绝。这时任务队列中有 任务2，任务3</li><li>这时，拒绝策略会让任务队列中最先加入的任务弹出，也就是任务2.</li><li>然后把被拒绝的任务5添加人任务队列，这时任务队列中就成了 任务3，任务5.</li><li>添加第六个任务时会因为同样的过程，将队列中的任务3抛弃，把任务6加进去，任务队列中就成了 任务5，任务6</li><li>因此，最终能被执行的任务只有1，4，5，6. 任务2和任务3倍抛弃了，不会执行。</li></ol><h3 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h3><p>实现一个让被拒绝的任务在一个新的线程中执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"新线程"</span>+<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">new</span> MyRejectedExecutionHandler());</span><br></pre></td></tr></table></figure><br><a href="https://blog.csdn.net/qq_25806863/article/details/71172823" target="_blank" rel="noopener">来源</a></p><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p><a href="https://www.cnblogs.com/pejsidney/p/9001875.html" target="_blank" rel="noopener">来源</a></p><h2 id="如何实现一个简单的线程池"><a href="#如何实现一个简单的线程池" class="headerlink" title="如何实现一个简单的线程池"></a>如何实现一个简单的线程池</h2><p><a href="https://www.jianshu.com/p/9b7dfb407f72" target="_blank" rel="noopener">来源</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义简单线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">/**存放线程的集合*/</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;MyThead&gt; threads;</span><br><span class="line">    <span class="comment">/**任务队列*/</span></span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">/**线程池初始限定大小*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line">    <span class="comment">/**已经工作的线程数目*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workThreadNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span><span class="params">(<span class="keyword">int</span> initPoolNum)</span> </span>&#123;</span><br><span class="line">        threadNum = initPoolNum;</span><br><span class="line">        threads = <span class="keyword">new</span> ArrayList&lt;&gt;(initPoolNum);</span><br><span class="line">        <span class="comment">//任务队列初始化为线程池线程数的四倍</span></span><br><span class="line">        taskQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(initPoolNum*<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        threadNum = initPoolNum;</span><br><span class="line">        workThreadNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="comment">//线程池未满，每加入一个任务则开启一个线程</span></span><br><span class="line">            <span class="keyword">if</span>(workThreadNum &lt; threadNum) &#123;</span><br><span class="line">                MyThead myThead = <span class="keyword">new</span> MyThead(runnable);</span><br><span class="line">                myThead.start();</span><br><span class="line">                threads.add(myThead);</span><br><span class="line">                workThreadNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程池已满，放入任务队列，等待有空闲线程时执行</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//队列已满，无法添加时，拒绝任务</span></span><br><span class="line">                <span class="keyword">if</span>(!taskQueue.offer(runnable)) &#123;</span><br><span class="line">                    rejectTask();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rejectTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"任务队列已满，无法继续添加，请扩大您的初始化线程池！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadPool myThreadPool = <span class="keyword">new</span> MyThreadPool(<span class="number">5</span>);</span><br><span class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"执行中"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            myThreadPool.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThead</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThead</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = runnable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//该线程一直启动着，不断从任务队列取出任务执行</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//如果初始化任务不为空，则执行初始化任务</span></span><br><span class="line">                <span class="keyword">if</span>(task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则去任务队列取任务并执行</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Runnable queueTask = taskQueue.poll();</span><br><span class="line">                    <span class="keyword">if</span>(queueTask != <span class="keyword">null</span>)</span><br><span class="line">                        queueTask.run();    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>过程:</p><ol><li>初始化线程池，指定线程池的大小。</li><li>向线程池中放入任务执行。</li><li>如果线程池中创建的线程数目未到指定大小，则创建我们自定义的线程类放入线程池集合，并执行任务。执行完了后该线程会一直监听队列</li><li>如果线程池中创建的线程数目已满，则将任务放入缓冲任务队列</li><li>线程池中所有创建的线程，都会一直从缓存任务队列中取任务，取到任务马上执行<h3 id="ThreadPoolExecutor源码分析"><a href="#ThreadPoolExecutor源码分析" class="headerlink" title="ThreadPoolExecutor源码分析"></a>ThreadPoolExecutor源码分析</h3><a href="https://www.jianshu.com/p/9b7dfb407f72" target="_blank" rel="noopener">来源</a></li></ol><h3 id="线程池与异步任务"><a href="#线程池与异步任务" class="headerlink" title="线程池与异步任务"></a>线程池与异步任务</h3><p><a href="https://www.cnblogs.com/wyq1995/p/10076949.html" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用线程池的原因&quot;&gt;&lt;a href=&quot;#使用线程池的原因&quot; class=&quot;headerlink&quot; title=&quot;使用线程池的原因&quot;&gt;&lt;/a&gt;使用线程池的原因&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗&lt;/li&gt;
&lt;li&gt;提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；&lt;/li&gt;
&lt;li&gt;方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/7726c70cdc40&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA线程池" scheme="https://sqwyyy.github.io/tags/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>CAS机制</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/CAS%E6%9C%BA%E5%88%B6/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/CAS%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-25T12:55:01.000Z</published>
    <updated>2020-05-25T12:56:51.829Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">来源</a><br><a href="https://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="noopener">来源</a><br>什么是CAS呢？Compare-and-Swap，即比较并替换，也有叫做Compare-and-Set的，比较并设置。</p><p>1、比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。</p><p>2、设置：如果是，将A更新为B，结束。[1]如果不是，则什么都不做。</p><a id="more"></a><p>上面的两步操作是原子性的，可以简单地理解为瞬间完成，在CPU看来就是一步操作。</p><p>下面以AtomicInteger的实现为例，分析一下CAS是如何实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>Unsafe，是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。</li><li>变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</li><li>变量value用volatile修饰，保证了多线程之间的内存可见性。</li></ol><p>AtomicInteger在并发下如何进行累加:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A和线程B同时执行getAndAdd操作（分别跑在不同CPU上）：</p><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为3。</li><li>线程A通过getIntVolatile(var1, var2)拿到value值3，这时线程A被挂起。</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值3，运气好，线程B没有被挂起，并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为2。</li><li>这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值(3)和内存的值(2)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li><li>重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。<br>整个过程中，利用CAS保证了对于value的修改的并发安全，</li></ol><p>getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。<br><strong>compareAndSwapInt，是一个本地方法</strong></p><p><strong>getAndIncrement 方法是返回旧值（即加1前的原始值）</strong><br><strong>incrementAndGet 返回的是新值（即加1后的值）</strong></p><hr><p>AtomicIntegerArray<br><strong>可以保证数组中的元素具有可见性</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取int[]在内存中的初始地址。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     <span class="comment">//用来存储移位个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化变量。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">        <span class="comment">//得出scale为2的几次方，即需要移位个数</span></span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查第i个元素的地址值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前索引i*shift(偏移位置) + base(基础位置)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//获取第i个元素的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过地址值来获取偏移量的元素值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用cas方式，在元素i的位置设置新值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><strong>AtomicIntegerArray中的数组申明为final类型，set和get方法都是调用unsafe类里面具有volatile语义的方法来保证可见性</strong><br><a href="https://www.cnblogs.com/zyy1688/p/10654943.html" target="_blank" rel="noopener">AtomicIntegerArray</a></p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><ol><li>CAS存在ABA问题：比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。<br>AtomicStampedReference来解决ABA问题:<strong>这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</strong>（相当于给其加上一个版本号，每次进行操作版本号+1，进行比较时，比较版本号和值是否相等)</li><li>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71156910&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/fb6e91b013cc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;br&gt;什么是CAS呢？Compare-and-Swap，即比较并替换，也有叫做Compare-and-Set的，比较并设置。&lt;/p&gt;
&lt;p&gt;1、比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。&lt;/p&gt;
&lt;p&gt;2、设置：如果是，将A更新为B，结束。[1]如果不是，则什么都不做。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/synchronized/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/synchronized/</id>
    <published>2020-05-25T12:52:17.000Z</published>
    <updated>2020-05-25T12:54:34.518Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">来源</a></p><h2 id="Synchronized的基本使用"><a href="#Synchronized的基本使用" class="headerlink" title="Synchronized的基本使用"></a>Synchronized的基本使用</h2><p>synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。从语法上讲，synchronized总共有三种用法：</p><a id="more"></a><ol><li>修饰普通方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectMethod3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是对象锁的方法修饰方式，我叫 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// while空循环的作用是，让t1,t2线程执行结束后再执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是对象锁的代码块形式，我叫 ： Thread-0</span><br><span class="line">Thread-0运行结束</span><br><span class="line">我是对象锁的代码块形式，我叫 ： Thread-1</span><br><span class="line">Thread-1运行结束</span><br><span class="line">finished</span><br></pre></td></tr></table></figure></li></ol><p>再声明一个实例instance2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectMethod3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance2 = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是对象锁的方法修饰方式，我叫 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// while空循环的作用是，让t1,t2线程执行结束后再执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是对象锁的方法修饰方式，我叫 Thread-0</span><br><span class="line">我是对象锁的方法修饰方式，我叫 Thread-1</span><br><span class="line">Thread-1  运行结束</span><br><span class="line">Thread-0  运行结束</span><br><span class="line">finished</span><br></pre></td></tr></table></figure><br><strong>sychronized没有启动到互斥作用</strong></p><ol><li><p>修饰静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectMethod3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedObjectMethod3 instance2 = <span class="keyword">new</span> SynchronizedObjectMethod3();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是对象锁的方法修饰方式，我叫 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  运行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// while空循环的作用是，让t1,t2线程执行结束后再执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是对象锁的方法修饰方式，我叫 Thread-0</span><br><span class="line">Thread-0  运行结束</span><br><span class="line">我是对象锁的方法修饰方式，我叫 Thread-1</span><br><span class="line">Thread-1  运行结束</span><br><span class="line">finished</span><br></pre></td></tr></table></figure><p>sychronized启动了互斥的作用</p></li><li><p>修饰代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedClassClass5</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedClassClass5 instance1 = <span class="keyword">new</span> SynchronizedClassClass5();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedClassClass5 instance2 = <span class="keyword">new</span> SynchronizedClassClass5();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedClassClass5<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是类锁的第二种形式：synchronized(*.class)代码块形式，我叫 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instance1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instance2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while空循环的作用是，让t1,t2线程执行结束后再执行主线程</span></span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"finished"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上<br>sychronized也启动了互斥的作用</p></li></ol><p>总结:</p><ul><li>对于普通方法:锁的是当前的实例对象</li><li>对于静态同步方法:锁的是当前类的class对象</li><li>对于同步代码块:锁的是synchronized指定的对象</li></ul><h2 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h2><p>对象头中主要包括两部分数据：类型指针和标记字段</p><ul><li>通过类型指针可以知道该对象是哪个类的实例</li><li><strong>标记字段用来存储对象运行时的数据，其中就有锁对象的指针</strong>.<strong>锁对象指针指向了一个monitor对象,每个对象都有一个对应的monitor对象</strong> (标记字段又叫Mark Word)</li></ul><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p><strong>Monitor是线程私有的数据结构</strong>，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p><strong>Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步.</strong></p><p><strong>线程在执行加了Synchronized的代码段的时候要先去获取对象的monitor,执行完毕释放monitor。此过程是互斥的，一次只能有一个线程获取monitor,只有该线程释放monitor以后其它线程才能再获取它</strong>(原理概括）。</p><p><a href="https://www.zhihu.com/question/57794716/answer/807823977" target="_blank" rel="noopener">sychronized</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.paddx.test.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Method 1 start"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译结果：<br><img src="https://pic4.zhimg.com/v2-da522fd0c4ed856125b7f6d0c154461f_b.jpg" alt="与上面代码可能不对应"><br>monitorenter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</span><br><span class="line">• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</span><br><span class="line">• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</span><br><span class="line">• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor&#39;s entry count is zero, then tries again to gain ownership.</span><br></pre></td></tr></table></figure><br>这段话的大概意思为：<br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：<br>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。<br>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.<br>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p><p>monitorexit：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</span><br><span class="line">The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</span><br></pre></td></tr></table></figure><br>执行monitorexit的线程必须是objectref所对应的monitor的所有者。<br>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p><hr><p><strong>由于Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一条线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间</strong><br>锁一共有4种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级</strong>。<br><img src="https://pic2.zhimg.com/80/v2-4b9d8ababbb870b76d6e0284caca45f1_720w.jpg" alt=""></p><h2 id="锁状态："><a href="#锁状态：" class="headerlink" title="锁状态："></a>锁状态：</h2><p>对象头中的Mark Word根据锁标志位的不同而被复用 </p><ol><li><p>无锁:无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，修改数据时采用CAS操作来进行，最终只有一个线程能修改成功。</p></li><li><p>偏向锁：<strong>在只有一个线程执行同步块时提高性能。Mark Word存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单比较ThreadID</strong>。特点：<strong>只有等到线程竞争出现才释放偏向锁，持有偏向锁的线程不会主动释放偏向锁</strong>。之后的线程竞争偏向锁，会先检查持有偏向锁的线程是否存活，如果不存活，则对象变为无锁状态，重新偏向；如果仍存活，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁</p></li><li><p>轻量级锁：</p><ul><li><p><strong>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能</strong>。</p></li><li><p>在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象目前的Mark Word到栈帧的Lock Record</p></li><li>若拷贝成功：虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向对象的Mark Word。</li><li>若拷贝失败：若当前只有一个等待线程，则可通过自旋稍微等待一下，可能持有轻量级锁的线程很快就会释放锁。</li><li>但是<strong>当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁</strong></li></ul></li><li>重量级锁：<ul><li><strong>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态</strong></li><li>指向互斥量（mutex），底层通过操作系统的mutex lock实现。等待锁的线程会被阻塞，由于Linux下Java线程与操作系统内核态线程一一映射，所以涉及到用户态和内核态的切换、操作系统内核态中的线程的阻塞和恢复。</li></ul></li></ol><p><a href="https://zhuanlan.zhihu.com/p/50098743" target="_blank" rel="noopener">美团技术博文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/paddix/p/5367116.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Synchronized的基本使用&quot;&gt;&lt;a href=&quot;#Synchronized的基本使用&quot; class=&quot;headerlink&quot; title=&quot;Synchronized的基本使用&quot;&gt;&lt;/a&gt;Synchronized的基本使用&lt;/h2&gt;&lt;p&gt;synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。从语法上讲，synchronized总共有三种用法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>HashMap与ConcurrentHashMap</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/HashMap%E4%B8%8EConcurrentHashMap/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/HashMap%E4%B8%8EConcurrentHashMap/</id>
    <published>2020-05-25T12:49:04.000Z</published>
    <updated>2020-05-25T12:51:44.579Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/search?type=content&amp;q=hashmap" target="_blank" rel="noopener">来源</a><br><a href="https://zhuanlan.zhihu.com/p/114508758" target="_blank" rel="noopener">来源</a><br><img src="https://pic2.zhimg.com/26341ef9fe5caf66ba0b7c40bba264a5_b.png" alt="1"></p><a id="more"></a><p><strong>HashMap:</strong></p><ol><li>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的</li><li>HashMap是线程不安全的，在多线程环境下会容易产生死循环，但是单线程环境下运行效率高；Hashtable线程安全的，很多方法都有synchronized修饰，但同时因为加锁导致单线程环境下效率较低。</li><li>HashMap允许有一个key为null，允许多个value为null；而Hashtable不允许key或者value为null。</li></ol><p><strong>ConcurrentHashMap</strong></p><ol><li>ConcurrentHashMap是线程安全的，ConcurrentHashMap引入了分段锁，并发性高于HashTable。</li><li>Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li></ol><p><strong>LinkedHashMap</strong></p><ol><li>nkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li></ol><p><strong>TreeMap</strong></p><ol><li>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ol><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>从结构实现来讲，HashMap是<strong>数组+链表+红黑树（JDK1.8增加了红黑树部分</strong>实现的</p><ol><li>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组 初始size为16</li><li>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)</li><li>HashMap就是使用哈希表来存储的,采用链地址法来处理冲突</li><li>哈希桶数组table的长度length大小必须为2的n次方(主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。)</li></ol><hr><p>功能实现:<br>1.确定哈希桶数组索引位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>当m为2^n^时，k%m=k&amp;(m-1)</strong><br>hash值为h^(h&gt;&gt;&gt;16)</p><h2 id="为什么要设计成h-h-gt-gt-16"><a href="#为什么要设计成h-h-gt-gt-16" class="headerlink" title="为什么要设计成h^(h&gt;&gt;16)"></a>为什么要设计成h^(h&gt;&gt;16)</h2><p>因为在确认数组索引位置时时hash&amp;(n-1)，索引的位置为后几位，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。</p><p><strong>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</strong></p><p><img src="https://pic2.zhimg.com/80/8e8203c1b51be6446cda4026eaaccf19_720w.png" alt=""></p><p><strong>2. put方法:</strong><br><img src="https://pic3.zhimg.com/80/58e67eae921e4b431782c07444af824e_720w.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">             <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">         <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3.扩容机制</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                       <span class="comment">//HashMap在JDK1.8的时候改善了扩容机制，原数组索引i上的链表不需要再反转。</span></span><br><span class="line">                   <span class="comment">// 扩容之后的索引位置只能是i或者i+oldCap（原数组的长度）</span></span><br><span class="line">                   <span class="comment">// 所以我们只需要看hashcode新增的bit为0或者1。</span></span><br><span class="line">                  <span class="comment">// 假如是0扩容之后就在新数组索引i位置，新增为1，就在索引i+oldCap位置</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>扩容之后将数组的长度扩大为2倍，那么n（数组的长度），转换为2进制数后相较于未扩容之前的n多增加了一个1的有效bit位</strong></p><p><strong>当链表长度大于等于8并且数组的长度大于等于64时才会转变为红黑树</strong></p><h2 id="树化过程"><a href="#树化过程" class="headerlink" title="树化过程"></a>树化过程</h2><p>红黑树的定义:</p><ol><li><p>节点是红色或黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>每个叶子节点都是黑色的空节点（NIL节点）。</p></li><li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p></li><li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p></li></ol><p>为了保持红黑树的规则，可以用变色，左旋转和右旋转实现</p><p><a href="https://www.cnblogs.com/finite/p/8251587.html" target="_blank" rel="noopener">树化的具体过程</a></p><h3 id="为什么链表是8次以后就转换为红黑树"><a href="#为什么链表是8次以后就转换为红黑树" class="headerlink" title="为什么链表是8次以后就转换为红黑树"></a>为什么链表是8次以后就转换为红黑树</h3><p>根据泊松分布，在负载因子0.75（HashMap默认）的情况下，单个hash槽内元素个数为8的概率小于百万分之一，将7作为一个分水岭，等于7时不做转换，大于等于8才转红黑树，小于等于6才转链表。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><strong>在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有数据覆盖的问题</strong></p><p>当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；还有++size这个地方也会造成多线程同时扩容等问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//putVal方法中</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  <span class="comment">//多线程执行到这里</span></span><br><span class="line">   tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><h1 id="Concurrenthashmap"><a href="#Concurrenthashmap" class="headerlink" title="Concurrenthashmap"></a>Concurrenthashmap</h1><p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：<br><img src="https://images2017.cnblogs.com/blog/926638/201708/926638-20170809132445011-2033999443.png" alt=""></p><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样</p><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒</p><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p>ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null</p><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>计算ConcurrentHashMap的元素大小是一个有趣的问题，因为他是并发操作的，就是在你计算size的时候，他还在并发的插入数据，可能会导致你计算出来的size和你实际的size有相差，有两种方法来实现size的计算<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0L</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        overflow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123; sum += seg.modCount; <span class="keyword">int</span> c = seg.count; <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">               overflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == last) <span class="keyword">break</span>;</span><br><span class="line">        last = sum; &#125; &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的</p></li><li><p>第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回</p></li></ol><h1 id="Concurrenthashmap-1"><a href="#Concurrenthashmap-1" class="headerlink" title="Concurrenthashmap"></a>Concurrenthashmap</h1><p>在jdk1.8版本中：</p><ol><li><p><strong>取消segments字段，直接采用transient volatile HashEntry<K,V>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率</strong>。</p></li><li><p><strong>将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构</strong>。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p></li></ol><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">//两次hash，减少hash冲突，可以均匀分布</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">//对这个table进行迭代</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;<span class="comment">//如果i位置没有数据，就直接无锁插入</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//如果在进行扩容，则先进行扩容操作</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果以上条件都不满足，那就要进行加锁操作，也就是存在hash冲突，锁住链表或者红黑树的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">//表示该节点是链表结构</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//这里涉及到相同的key进行put就会覆盖原先的value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;  <span class="comment">//插入链表尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">//红黑树结构</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//红黑树结构旋转插入</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">//如果链表的长度大于8时就会进行红黑树的转换</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);<span class="comment">//统计size，并且检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下:</p><ol><li><p>如果没有初始化就先调用initTable（）方法来进行初始化过程</p></li><li><p>如果没有hash冲突就直接CAS插入</p></li><li>如果还在进行扩容操作就先进行扩容</li><li>如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，</li><li>最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环</li><li>如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容</li></ol><p><strong>他在并发处理中使用的是乐观锁，当有冲突的时候才进行并发处理</strong></p><h2 id="get操作-1"><a href="#get操作-1" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode()); <span class="comment">//计算两次hash</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;<span class="comment">//读取首节点的Node元素</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123; <span class="comment">//如果该节点就是首节点就返回</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来</span></span><br><span class="line">        <span class="comment">//查找，查找到就返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;<span class="comment">//既不是首节点也不是ForwardingNode，那就往下遍历</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get流程如下:</p><ol><li><p>计算hash值，定位到该table索引位置，如果是首节点符合就返回</p></li><li><p>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</p></li><li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li></ol><p><a href="https://blog.csdn.net/xingxiupaioxue/article/details/88062163" target="_blank" rel="noopener">concurrenthashmap1.7和1.8的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/search?type=content&amp;amp;q=hashmap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/114508758&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://pic2.zhimg.com/26341ef9fe5caf66ba0b7c40bba264a5_b.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/categories/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="HashMap" scheme="https://sqwyyy.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #642 (Div. 3)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-642-Div-3/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-642-Div-3/</id>
    <published>2020-05-18T15:32:35.000Z</published>
    <updated>2020-05-19T06:35:52.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="E-K-periodic-Garland"><a href="#E-K-periodic-Garland" class="headerlink" title="E. K-periodic Garland"></a><a href="https://codeforces.com/contest/1353/problem/E" target="_blank" rel="noopener">E. K-periodic Garland</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>给一个01串,一次操作可以把一个0变成1，或者把1变成0.求最小的操作次数使得01串中相邻得两个1之间间隔为k。</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>假设<strong>dp(i)为第i栈灯亮并且[1,i]的灯都是合法的且操作数最少</strong></p><p>则递推式为</p><script type="math/tex; mode=display">当i为第一个1的位置时\quad dp_i = 区间(1,i-1)中1的个数+(s_i=='0')</script><script type="math/tex; mode=display">当i不为第一个1的位置时\\ dp_i= min(dp_i,dp_{i-k}+区间(i-k+1,i-1)中1的个数+(s_i=='0'))</script><p>由于dp(i)只是(1,i)合法的需要将(i+1,n)全部置0，这样区间(1,n)则合法但不一定是最小，在枚举每个dp(i)+sum(n)-sum(i)取最小值就是答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn],sum[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1e6</span>;</span><br><span class="line">            sum[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+(s[i]==<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum[n]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=(s[i]==<span class="string">'0'</span>)+sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k)&#123;</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i],(s[i]==<span class="string">'0'</span>)+dp[i-k]+(sum[i<span class="number">-1</span>]-sum[i-k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,sum[n]-sum[i]+dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Decreasing-Heights"><a href="#F-Decreasing-Heights" class="headerlink" title="F. Decreasing Heights"></a><a href="https://codeforces.com/problemset/problem/1353/F" target="_blank" rel="noopener">F. Decreasing Heights</a></h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p> 给定一个n∗m的矩阵,起点位(1,1)终点为(n,m),每次可以向右或向下走1格，并且<strong>只能走比当前位置的权值大1的位置</strong>。在开始走之前你可以进行任意次操作，每次操作可以把任意位置的权值减少1，求走到终点需要的最小操作次数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>在本题中需要确定一条性质从<strong>(1,1)的(n,m)的路径中一定存在至少一个点的权值不变</strong></p><script type="math/tex; mode=display">如果确定了起点的权值为b_{1,1}\\那么从起点(1,1)走到(i,j)时,(i,j)的权值一定为b_{1,1}+i+j。\\则整个路径的总和则为b_{1,1}+b_{1,1}+1+\cdots+b_{1,1}+n+m</script><p>需要操作数最小，则从<strong>(1,1)的(n,m)的路径中一定存在至少一个点的权值不变</strong></p><p>则本题可以枚举不变点(x,y)，以(x,y)将矩阵分为上下两个矩阵，分别进行dp即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码:"></a>代码:</h2><script type="math/tex; mode=display">dp(i,j)代表以(x,y)为权值不变的点，所确定(i,j)的最小值\\答案则为ans=min(ans,dp(1,1)+dp(n,m))</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">ll dp[maxn][maxn],mpt[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mpt[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=m;y++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                        dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[x][y]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==x&amp;&amp;j==y) <span class="keyword">continue</span>;</span><br><span class="line">                        ll val = mpt[x][y]-(x-i+y-j);</span><br><span class="line">                        ll cost = mpt[i][j] - val;</span><br><span class="line">                        <span class="keyword">if</span>(cost&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> pos1 = i+<span class="number">1</span>&gt;n?n:i+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">int</span> pos2 = j+<span class="number">1</span>&gt;m?m:j+<span class="number">1</span>;</span><br><span class="line">                        dp[i][j]=<span class="built_in">min</span>(dp[pos1][j],dp[i][pos2])+cost;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;=m;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==x&amp;&amp;j==y) <span class="keyword">continue</span>;</span><br><span class="line">                        ll val = mpt[x][y]+(i-x+j-y);</span><br><span class="line">                        ll cost = mpt[i][j] - val;</span><br><span class="line">                        <span class="keyword">if</span>(cost&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> pos1 = i<span class="number">-1</span>&lt;=<span class="number">0</span>?<span class="number">1</span>:i<span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">int</span> pos2 = j<span class="number">-1</span>&lt;=<span class="number">0</span>?<span class="number">1</span>:j<span class="number">-1</span>;</span><br><span class="line">                        dp[i][j]=<span class="built_in">min</span>(dp[pos1][j],dp[i][pos2])+cost;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,dp[<span class="number">1</span>][<span class="number">1</span>]+dp[n][m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;E-K-periodic-Garland&quot;&gt;&lt;a href=&quot;#E-K-periodic-Garland&quot; class=&quot;headerlink&quot; title=&quot;E. K-periodic Garland&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1353/problem/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;E. K-periodic Garland&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;给一个01串,一次操作可以把一个0变成1，或者把1变成0.求最小的操作次数使得01串中相邻得两个1之间间隔为k。&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
      <category term="dp" scheme="https://sqwyyy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #641(Div.2)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-641-Div-2/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/18/Codeforces-Round-641-Div-2/</id>
    <published>2020-05-18T14:22:57.000Z</published>
    <updated>2020-05-18T14:27:51.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Orac-and-LCM"><a href="#C-Orac-and-LCM" class="headerlink" title="C Orac and LCM"></a><a href="https://codeforces.com/contest/1350/problem/C" target="_blank" rel="noopener">C Orac and LCM</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>给了n个数，让求gcd{ lcm{a[i],a[j]} } (i&lt;j)<br>就是n个数，两两配对求出他们的lcm，对于所有lcm在求出gcd</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>根据唯一分解定理</p><script type="math/tex; mode=display">x=p_1^{a_1}*p_2^{a_2}*..*p_k^{a_k} \quad y=p_1^{b_1}*p_2^{b_2}*..*p_k^{b_k}</script><p>则gcd和lcm在算术基本定理下的含义:</p><script type="math/tex; mode=display">lcm(x,y)=p_1^{max(a_1,b_1)}*p_2^{max(a_2,b_2)}*...*p_k^{max(a_k,b_k)}</script><script type="math/tex; mode=display">gcd(x,y)=p_1^{min(a_1,b_1)}*p_2^{min(a_2,b_2)}*...*p_k^{min(a_k,b_k)}</script><p>对于n个数而言:</p><ol><li>如果n-1个数都有质因子x，那么所求答案的gcd一定含有x，不含质因子的那个数一定会与含有质因子的数求lcm，则求出来的数一定含有质因子x，则答案应该乘以这个质因子的<strong>最小</strong></li><li>如果n个数都有质因子x，那么所求答案的gcd一定含有x，则答案应该乘以这个质因子的<strong>第二小</strong></li><li>如果少于n-1个数含有质因子x，则一定存在没有质因子的两个数求lcm，则对答案没有贡献</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>vis代表第j个数为质因子i的幂次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">     ll x;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*j&lt;=x;j++)&#123;</span><br><span class="line">         ll cnt=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(x%j==<span class="number">0</span>)&#123;</span><br><span class="line">           x/=j;</span><br><span class="line">           cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">         vis[j].push_back(cnt);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(x!=<span class="number">1</span>) vis[x].push_back(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(vis[i].<span class="built_in">size</span>()&gt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">       sort(vis[i].<span class="built_in">begin</span>(),vis[i].<span class="built_in">end</span>());</span><br><span class="line">       <span class="keyword">if</span>(vis[i].<span class="built_in">size</span>()==n) ans*=_pow(i,vis[i][<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">else</span> ans*=_pow(i,vis[i][<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Orac-and-Medians"><a href="#D-Orac-and-Medians" class="headerlink" title="D. Orac and Medians"></a><a href="https://codeforces.com/contest/1350/problem/D" target="_blank" rel="noopener">D. Orac and Medians</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h2><p>给出一个长度为 n 的数列，以及一个数字 k ，每次操作可以将一段连续区间 [ l , r ] 内的数字全部替换成该区间的中位数(如果该区间长度为偶数则中位数为a[n/2])，问能否通过适当的操作使得整个数列的 n 个数字全部等于 k </p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h2><p>首先不难看出，如果区间内不存在数字 k 的话一定是 no ，然后我设:</p><ol><li>小于 k 的数为 -1</li><li>大于 k 的数为 1</li><li>等于 k 的数为 0</li></ol><p>对[1,n]区间进行讨论，sum为区间[1,n]的和，有以下三种情况:</p><ol><li>如果 sum == 0 的话，说明等于 k 的数已经位于中位数的位置了，显然为 yes</li><li>如果 sum &gt; 0 的话，说明大于 k 的数比较多，需要减少大于 k 的数量，因为此时经过筛选后，区间内一定存在等于 k 的数，即一定存在着非正数（ -1 和 0 ），<strong>与这些非正数相邻的正数可以组成长度为 2 的区间，此时正数都可以根据规则被同化为非正数</strong>，所以通过适当的操作可以使 sum 不断减小，直到 sum == 0 ，所以这种情况也显然为 yes</li><li>如果 sum &lt; 0 的话，根据上面的思想，我们的目标是令 sum 不断增大，直到 sum == 0 为止，如果负数想要被同化为非负数的话，需要在长度至少为 3 的区间内，满足：<strong>有一个负数以及两个非负数</strong>才行</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> pi =<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">      <span class="keyword">if</span>(a[i]==k) num++,a[i]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;k) a[i]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> a[i]=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!num)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;a[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">1</span>&amp;&amp;a[i<span class="number">-2</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Orac-and-Game-of-Life"><a href="#E-Orac-and-Game-of-Life" class="headerlink" title="E. Orac and Game of Life"></a><a href="https://codeforces.com/contest/1350/problem/E" target="_blank" rel="noopener">E. Orac and Game of Life</a></h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意:"></a>题意:</h2><p>给个n*m的网格，里面一些格子一开始是白色(0)，另一些是黑色(1)，接下来网格可进行迭代，对于每次迭代，格子里颜色的变化遵循以下规则：</p><ol><li><p>若该格子有相邻格子的颜色与之相同，则颜色翻转</p></li><li><p>若该格子没有相邻格子的颜色与之相同，则颜色不变</p></li></ol><p>有t次询问，每次询问都有i, j, p，表示问第i行第j列格子在第p次迭代后是什么颜色</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h2><p>网格中一共有两种点:</p><ol><li>它的周围没有任何相同的点，不会变换</li><li>它的周围有相同的点，会与周围的点一直变换</li></ol><p><strong>对于第二种点，它周围和它同色的点会每个状态交替变换，且永远不会变成第一种点</strong></p><p><strong>对于第一种点，它周围第一次迭代可能没有相同的点，第k次则可能出现与其相同的点，则会变成第二种点</strong></p><p><strong>对于每个点只要求出第一次发生变化的迭代时刻，则根据t-p计算奇偶性就能知道这个点的颜色</strong></p><p>则问题就变成了</p><p>在一个新的01棋盘，0和1分别代表第一种和第二种点，<strong>求出所有第一种点离最近的第二种点的距离</strong></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li><p>设dp(i,j)表示第(i, j)个格子在dp(i,j)次迭代后会开始变色</p></li><li><p>初始dist数组的值为inf</p></li><li><p>对一开始就能变色的格子进行深搜，设其dp(x,y)=0，并把该格子加入宽搜队列</p></li><li><p>进行宽搜，把宽搜队列中的元素取出来进行四联通的搜索，如果有dp(x,y)+ 1 &lt; dp(xx,yy)，那么dp(xx,yy)更新并将第(xx, yy)格子加入宽搜队列</p></li><li><p>对于dist(i,j)为inf的格子，说明不管怎么迭代永远都不会变色，p &lt; dp(x,y)时，说明直到该次迭代都没有变色，p &gt;= dp(x,y)时，若p - dp(x,y)是奇数就说明这次迭代与初始色相反，偶数就是与初始色相同</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="built_in">string</span> mpt[maxn];</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkboundary</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=n||j&lt;<span class="number">0</span>||j&gt;=m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bx[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> by[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;mpt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            dp[i][j]=<span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pr&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(checkboundary(i+bx[k],j+by[k]))&#123;</span><br><span class="line">                    <span class="keyword">int</span> l=i+bx[k],r=j+by[k];</span><br><span class="line">                    <span class="keyword">if</span>(mpt[l][r]==mpt[i][j])&#123;</span><br><span class="line">                      <span class="keyword">if</span>(!vis[l][r]) q.push(make_pair(l,r));</span><br><span class="line">                      dp[l][r]=<span class="number">0</span>;</span><br><span class="line">                      vis[l][r]=<span class="number">1</span>;</span><br><span class="line">                      num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>&amp;&amp;!vis[i][j])&#123;</span><br><span class="line">                q.push(make_pair(i,j));</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                vis[i][j]=<span class="number">1</span>;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;m;j++)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;vis[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;q.size()&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        pr now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=now.first+bx[i];</span><br><span class="line">            <span class="keyword">int</span> y=now.second+by[i];</span><br><span class="line">            <span class="keyword">if</span>(checkboundary(x,y))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y]&amp;&amp;dp[x][y]&gt;dp[now.first][now.second]+<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">                    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">                    dp[x][y]=dp[now.first][now.second]+<span class="number">1</span>;</span><br><span class="line">                    q.push(make_pair(x,y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">      ll i,j,p;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j&gt;&gt;p;</span><br><span class="line">      <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&gt;p)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        ll num = p - dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;((mpt[i<span class="number">-1</span>][j<span class="number">-1</span>]-<span class="string">'0'</span>)^<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-Orac-and-LCM&quot;&gt;&lt;a href=&quot;#C-Orac-and-LCM&quot; class=&quot;headerlink&quot; title=&quot;C Orac and LCM&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1350/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C Orac and LCM&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;给了n个数，让求gcd{ lcm{a[i],a[j]} } (i&amp;lt;j)&lt;br&gt;就是n个数，两两配对求出他们的lcm，对于所有lcm在求出gcd&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
      <category term="数论" scheme="https://sqwyyy.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>codeforces round #643(Div.2)</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/17/codeforces-round-643-Div-2/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/17/codeforces-round-643-Div-2/</id>
    <published>2020-05-17T07:36:17.000Z</published>
    <updated>2020-05-17T07:49:30.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Count-Triangles"><a href="#C-Count-Triangles" class="headerlink" title="C. Count Triangles"></a><a href="https://codeforces.com/contest/1355/problem/C" target="_blank" rel="noopener">C. Count Triangles</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>给你 A , B , C , D</p><p>问有多少种方法构造出三角形(X , Y , Z)使得 A ≤ X ≤ B ≤ Y ≤ C ≤ Z ≤ D</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol><li><p>构成三角形的条件是：x+y&gt;z</p></li><li><p>那么可以进行<strong>枚举x+y来优化,令m=x+y，算出当x+y和为m的时候，有几种可行的构造数量s2，然后去乘s1=max(m-1,d)-c+1就可以了</strong>，前提是s1和s2均非0</p></li><li><p>∵x+y=m, ∴y=m-x, 又∵B≤y=m-x≤C,∴m-C≤x≤m-B，又因为A≤x≤B，所以取交集，该组数目等于右界-左界+1</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pr;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">ll _pow(ll  a,ll b) &#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=ans*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ll a,b,c,d;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=a+b;i&lt;=b+c;i++)&#123;</span><br><span class="line">        ll s1=<span class="built_in">min</span>(d,i<span class="number">-1</span>)-c+<span class="number">1</span>;</span><br><span class="line">        ll s2=<span class="built_in">min</span>(i-b,b)-<span class="built_in">max</span>(i-c,a)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1&lt;<span class="number">0</span>||s2&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sum+=s1*s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Game-With-Array"><a href="#D-Game-With-Array" class="headerlink" title="D. Game With Array"></a><a href="https://codeforces.com/contest/1355/problem/D" target="_blank" rel="noopener">D. Game With Array</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h2><p>问你能否构造一个长度为 N 且和为 S 的序列</p><p>使得对于该序列你无法找到一个子序列使得子序列的和等于 K 或 S - K (0 &lt;= K &lt;= S)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>猜结论</p><p>我们构造一个前 N - 1项为 1，第 N 项为 S - N + 1 的序列</p><p>对于前 N - 1项构成的序列的和我们设为 K，那么第 N 项构成的序列和就为 S - K</p><p>这样就很好的使用上了题目给的信息，所以盲猜该构造方法是可行的</p><p>那么对于该序列，[ 1 , N - 1 ] 和 [ S - (N - 1) , S ] 的值我们都是可以通过选取子序列得到</p><p>而 [ N , S - N ] 的值无法得到，所以只要判断 N 是否小于等于 S - N 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n , s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s ;</span><br><span class="line">    <span class="keyword">int</span> ans = s - n;</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - <span class="number">1</span> ; i ++) <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-Count-Triangles&quot;&gt;&lt;a href=&quot;#C-Count-Triangles&quot; class=&quot;headerlink&quot; title=&quot;C. Count Triangles&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codeforces.com/contest/1355/problem/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C. Count Triangles&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意:&quot;&gt;&lt;/a&gt;题意:&lt;/h2&gt;&lt;p&gt;给你 A , B , C , D&lt;/p&gt;
&lt;p&gt;问有多少种方法构造出三角形(X , Y , Z)使得 A ≤ X ≤ B ≤ Y ≤ C ≤ Z ≤ D&lt;/p&gt;
    
    </summary>
    
    
      <category term="codeforces" scheme="https://sqwyyy.github.io/categories/codeforces/"/>
    
    
      <category term="思维 三分" scheme="https://sqwyyy.github.io/tags/%E6%80%9D%E7%BB%B4-%E4%B8%89%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/Java%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2020-05-10T15:52:45.000Z</published>
    <updated>2020-05-10T15:55:13.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h1><pre><code>1. 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化（因为外部类的非静态方法是需要创建外部类对象才能调用的，而你的静态内部类是不需要外部类对象就可以得到的）。</code></pre><h1 id="成员内部类："><a href="#成员内部类：" class="headerlink" title="成员内部类："></a>成员内部类：</h1><pre><code>1. 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。</code></pre><h1 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h1><pre><code>1. 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。2. 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。</code></pre><h1 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h1><pre><code>1. 没有类名的内部类，不能使用class，extends和implements，没有构造方法。2. 多用于GUI中的事件处理。3. 不能定义静态资源4. 只能创建一个匿名内部类实例。5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效</code></pre><hr><a id="more"></a><h1 id="非静态内部类为什么不能有静态成员变量和静态方法："><a href="#非静态内部类为什么不能有静态成员变量和静态方法：" class="headerlink" title="非静态内部类为什么不能有静态成员变量和静态方法："></a>非静态内部类为什么不能有静态成员变量和静态方法：</h1><p>JVM的类加载规则 ：</p><ol><li>static类型的属性和方法，在类加载的时候就会存在于内存中。</li><li>要想使用某个类的static属性和方法，那么这个类必须要加载到JAVA虚拟机中。</li><li>非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。<br>现在考虑这个情况：在外部类并没有实例化，内部类还没有加载，这时候如果<br>调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内<br>部类的静态成员，这明显是矛盾的。所以非静态内部类不能有静态成员变量或<br>静态方法。</li></ol><hr><h1 id="为什么静态内部类不允许访问外部非静态成员："><a href="#为什么静态内部类不允许访问外部非静态成员：" class="headerlink" title="为什么静态内部类不允许访问外部非静态成员："></a>为什么静态内部类不允许访问外部非静态成员：</h1><p>成员变量也叫实例变量，随着对象的创建而存在<br>静态成员随着类的加载而加载， 生命周期比对象长<br>静态成员在的时候还没成员变量，那还怎么调用</p><hr><h1 id="为什么局部内部类和匿名内部类只能访问final的局部变量"><a href="#为什么局部内部类和匿名内部类只能访问final的局部变量" class="headerlink" title="为什么局部内部类和匿名内部类只能访问final的局部变量?"></a>为什么局部内部类和匿名内部类只能访问final的局部变量?</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> InTest().f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test t=<span class="keyword">new</span> Test();</span><br><span class="line">t.play();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要原因还是生命周期：当我的t.play（）出栈后，play中的局部变量<br>就会随之销毁，但是我的内部类对象可能仍然还存在的（当不在被使用才会被垃圾回收器回收）这时在内部类中访问了局部变量x，但此时的x已经被销毁，内部类访问了一个并不会存在的变量，这就形成了一个矛盾。根本原因就是：内部类的生命周期比局部变量的长</strong><br>其实如果我们编译Test.java文件发现会出现两个class文件，Test.class和Test$InTest.class文件，java会将Test中的局部变量x复制一份到TestInTest.class中当做是内部类的成员常量。这样我们访问的其实就是复制的那个成员常量。</p><p><strong>如何保证数据的一致性：当我们修改局部变量的时候如何保证被复制出来的变量也会同步一致：用final修饰。这样只要这个局部变量进栈初始化的时候就是一个常量。在生命周期内不能被改变，这里注意生命周期。这样就保证了内部类的成员变量和方法的局部变量的一致性。</strong></p><hr><h1 id="内部类为什么能访问外部类的成员变量"><a href="#内部类为什么能访问外部类的成员变量" class="headerlink" title="内部类为什么能访问外部类的成员变量"></a>内部类为什么能访问外部类的成员变量</h1><p>1 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用；<br>2 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值；<br>3 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。<br><a href="https://blog.csdn.net/zhangjg_blog/article/details/20000769" target="_blank" rel="noopener">来源</a><br><a href="https://www.nowcoder.com/questionTerminal/e886e58981c346098a043c3c2ad2d736" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;静态内部类：&quot;&gt;&lt;a href=&quot;#静态内部类：&quot; class=&quot;headerlink&quot; title=&quot;静态内部类：&quot;&gt;&lt;/a&gt;静态内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化（因为外部类的非静态方法是需要创建外部类对象才能调用的，而你的静态内部类是不需要外部类对象就可以得到的）。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;成员内部类：&quot;&gt;&lt;a href=&quot;#成员内部类：&quot; class=&quot;headerlink&quot; title=&quot;成员内部类：&quot;&gt;&lt;/a&gt;成员内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;局部内部类：&quot;&gt;&lt;a href=&quot;#局部内部类：&quot; class=&quot;headerlink&quot; title=&quot;局部内部类：&quot;&gt;&lt;/a&gt;局部内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰。
2. 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;匿名内部类：&quot;&gt;&lt;a href=&quot;#匿名内部类：&quot; class=&quot;headerlink&quot; title=&quot;匿名内部类：&quot;&gt;&lt;/a&gt;匿名内部类：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 没有类名的内部类，不能使用class，extends和implements，没有构造方法。
2. 多用于GUI中的事件处理。
3. 不能定义静态资源
4. 只能创建一个匿名内部类实例。
5. 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口。
6. 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="内部类" scheme="https://sqwyyy.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Session和Cookie</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/Session%E5%92%8CCookie/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/Session%E5%92%8CCookie/</id>
    <published>2020-05-10T15:50:05.000Z</published>
    <updated>2020-05-10T15:55:13.857Z</updated>
    
    <content type="html"><![CDATA[<p><strong>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session,Cookie是实现Session的一种方式（并不是唯一的）</strong><br><a id="more"></a></p><hr><p>1，session 在服务器端，cookie 在客户端（浏览器）<br>2，session 默认被存在在服务器的一个文件里（不是内存）<br>3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）<br>4，session 可以放在 文件、数据库、或内存中都可以。<br>5，用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id</p><hr><p>==如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。==</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session,Cookie是实现Session的一种方式（并不是唯一的）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Session" scheme="https://sqwyyy.github.io/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList和LinkedList</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/ArrayList%E5%92%8CLinkedList/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/ArrayList%E5%92%8CLinkedList/</id>
    <published>2020-05-10T15:45:16.000Z</published>
    <updated>2020-05-10T15:49:31.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的区别"><a href="#简单的区别" class="headerlink" title="简单的区别"></a>简单的区别</h1><ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous） </li><li><p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p></li><li><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</p><a id="more"></a></li></ol><h1 id="深度的区别"><a href="#深度的区别" class="headerlink" title="深度的区别"></a>深度的区别</h1><ol><li>对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。</li><li>在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。</li><li><p>LinkedList不支持高效的随机元素访问。</p></li><li><p>ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间</p></li></ol><h1 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h1><p>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，并且ArrayList不是线程安全的。</p><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">      * The array buffer into which the elements of the ArrayList are stored. </span></span><br><span class="line"><span class="comment">      * The capacity of the ArrayList is the length of this array buffer. </span></span><br><span class="line"><span class="comment">      */</span>  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;  </span><br><span class="line">   </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">      * The size of the ArrayList (the number of elements it contains). </span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * <span class="doctag">@serial</span> </span></span><br><span class="line"><span class="comment">      */</span>  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><br>被标记为transient的属性在对象被序列化的时候不会被保存。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法:"></a>构造方法:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList带容量大小的构造函数。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">super</span>();    </span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+    </span><br><span class="line">                                               initialCapacity);    </span><br><span class="line">        <span class="comment">// 新建一个数组    </span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ArrayList无参构造函数。默认容量是10。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个包含collection的ArrayList    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    </span><br><span class="line">        elementData = c.toArray();    </span><br><span class="line">        size = elementData.length;    </span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)    </span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="元素存储"><a href="#元素存储" class="headerlink" title="元素存储:"></a>元素存储:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </span><br><span class="line">   RangeCheck(index);  </span><br><span class="line"> </span><br><span class="line">   E oldValue = (E) elementData[index];  </span><br><span class="line">   elementData[index] = element;  </span><br><span class="line">   <span class="keyword">return</span> oldValue;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 将指定的元素添加到此列表的尾部。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">   ensureCapacity(size + <span class="number">1</span>);   </span><br><span class="line">   elementData[size++] = e;  </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 将指定的元素插入此列表中的指定位置。  </span></span><br><span class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);  </span><br><span class="line">   <span class="comment">// 如果数组长度不足，将进行扩容。  </span></span><br><span class="line">   ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></span><br><span class="line">   <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，  </span></span><br><span class="line">   <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。  </span></span><br><span class="line">   <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></span><br><span class="line">   System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);  </span><br><span class="line">   elementData[index] = element;  </span><br><span class="line">   size++;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">   Object[] a = c.toArray();  </span><br><span class="line">   <span class="keyword">int</span> numNew = a.length;  </span><br><span class="line">   ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></span><br><span class="line">   System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);  </span><br><span class="line">   size += numNew;  </span><br><span class="line">   <span class="keyword">return</span> numNew != <span class="number">0</span>;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(  </span><br><span class="line">           <span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);  </span><br><span class="line"> </span><br><span class="line">   Object[] a = c.toArray();  </span><br><span class="line">   <span class="keyword">int</span> numNew = a.length;  </span><br><span class="line">   ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> numMoved = size - index;  </span><br><span class="line">   <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </span><br><span class="line"> </span><br><span class="line">   System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </span><br><span class="line">   size += numNew;  </span><br><span class="line">   <span class="keyword">return</span> numNew != <span class="number">0</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="元素读取"><a href="#元素读取" class="headerlink" title="元素读取:"></a>元素读取:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容:"></a>扩容:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">            &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">                 &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                    minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                    oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">            <span class="keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elementData = <span class="keyword">new</span> Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除:"></a>元素删除:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除此列表中指定位置上的元素。  </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    modCount++;  </span><br><span class="line">    E oldValue = (E) elementData[index];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);  </span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> oldValue;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的区别&quot;&gt;&lt;a href=&quot;#简单的区别&quot; class=&quot;headerlink&quot; title=&quot;简单的区别&quot;&gt;&lt;/a&gt;简单的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 （LinkedList是双向链表，有next也有previous） &lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="集合类" scheme="https://sqwyyy.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode907</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/10/Leetcode907/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/10/Leetcode907/</id>
    <published>2020-05-10T15:40:10.000Z</published>
    <updated>2020-05-10T15:42:56.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。<br>由于答案可能很大，因此返回答案模 10^9 + 7<br><a id="more"></a><br>输入：[3,1,2,4]<br>输出：17<br>解释：<br>子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。<br>最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>找出这个数字左边有几个，右边有几个，赋值为m、n；</li><li>计算以这个数字为最小值的情况有集中：(m+1)*(n+1);</li><li>遍历数组A的每一个元素，以其为最小数的次数乘其本身，再求和就是最后结果啦。</li><li>正常情况下，找出数组中每一个元素左边和右边各有几个连续的、比它小的数字的复杂度为n的二次方，怎样可以优化算法复杂度呢。</li><li>==是否可以维护一个栈，只存比当前栈顶元素更大的元素，在一个元素入栈之前要将所有比它小的数都弹出栈，那么，在这个元素入栈的时候，可以知道左边（连续）比他大的数有几个，出栈的时候会知道右边的数有几个。这样，复杂度变为了O（N）.==</li></ol><hr><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Stack&lt;Integer&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty()&amp;&amp;A[i]&lt;=A[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> pos = stack.pop();</span><br><span class="line">                right[pos]=i-pos-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">                left[i]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left[i]=i-stack.peek()-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = stack.pop();</span><br><span class="line">            right[pos]=len-pos-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            ans+=((left[i]+<span class="number">1</span>)*(right[i]+<span class="number">1</span>)%mod)*A[i]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/onfu-za-du-de-javajie-fa-by-mei-shou-gan/" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。&lt;br&gt;由于答案可能很大，因此返回答案模 10^9 + 7&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单调栈" scheme="https://sqwyyy.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>poj2796</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/08/poj2796/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/08/poj2796/</id>
    <published>2020-05-08T15:46:26.000Z</published>
    <updated>2020-05-09T13:05:02.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个序列，要求的是一个区间，这个区间的最小值乘以这个区间数字的和是最大值<br><a id="more"></a></p><p>==单调栈处理的问题就是对每一个节点进行扩展的问题，<br>这个题目要维护的是一个单调递减栈，即从栈顶元素到栈底元素，值是单调递减的，即栈顶元素的值始终是栈的最大值。然后每一个值有属于自己的区间，这个区间目的是为了记录之后的元素向前延伸的用处。<br>向后延伸就靠从1到n扫描元素，(维护单调递减栈)这样当扫描的元素大于栈顶元素时，直接入栈。<br>当扫描的元素等于栈顶元素时，不记录，只将区间延伸到后面。<br>当扫描的元素小于栈顶元素时，这时要计算栈内当前的值。因为扫描的元素时小于栈顶元素的，要求的是一个区间的最小值，所以栈内那些大于该元素的值你会发现没有用处了，只需要将它们的那些区间留下来就对了，这就是向前扩展。==</p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>3 1 6 4 5 2</p><p>一开始每一个数都有自己的区间：</p><p>3(1,1)  1(2,2)  6(3,3)  4(4,4)  5(5,5)  2(6,6)  -1(7,7)后面加一个最小值，为了最后计算栈内元素使用。</p><p>先是3入栈。栈内元素 3(1,1)</p><p>1<3，首先计算一下栈内元素的值，记录下来。然后要把栈内大于1的全部弹出来，但是把它们的区间留下，栈内就变成了1(1,2)。实际上此时就会知道(1,2)这段区间之内的最小值是1。6>1，直接入栈，栈内元素变为1(1,2)，6(3,3)。<br>4<6，将6弹出，弹出之前计算值。然后栈内就变为1(1,2)，4(3,4)。5>4，直接入栈。栈内元素是1(1,2),4(3,4),5(5,5)。会发现因为5没有办法向前扩展了所以会知道5只能够在(5,5)的区间内最小，所以说站内元素是在自己区间的左端点与栈顶元素的右端点，这段区间之内满足着最小值的关系。1是在(1,5)这段区间内最小，4是在(3,5)这段区间内最小。这些值都会在碰到扫描的元素小于该元素时计算，记录下来，就是这样单调栈完成了对每一个元素进行左右扩展的目的。<br>2&lt;5,2&lt;4。要把5(5,5) 4(3,4)分别弹出，它们走之前要计算各自区间的值。<br>最后是-1，目的就是要将栈内所有元素弹出，计算每一个元素左右扩展的值。</p><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[N], lef[N], s[N], top;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">ll ans = <span class="number">-1</span>, tmp;</span><br><span class="line"><span class="keyword">int</span> i, j, n;</span><br><span class="line"><span class="keyword">int</span> ll, rr;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line">a[++n] = <span class="number">-1</span>;</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">0</span> || a[i] &gt; a[s[top - <span class="number">1</span>]])</span><br><span class="line">&#123;</span><br><span class="line">s[top++] = i;</span><br><span class="line">lef[i] = i;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] == a[s[top - <span class="number">1</span>]])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span> (top &gt;= <span class="number">1</span> &amp;&amp; a[i] &lt; a[s[top - <span class="number">1</span>]])</span><br><span class="line">&#123;</span><br><span class="line">--top;</span><br><span class="line">tmp = <span class="number">1L</span>L*a[s[top]] * (sum[i - <span class="number">1</span>] - sum[lef[s[top]] - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp &gt; ans)</span><br><span class="line">&#123;</span><br><span class="line">ll = lef[s[top]];</span><br><span class="line">rr = i - <span class="number">1</span>;</span><br><span class="line">ans = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lef[i] = lef[s[top]];</span><br><span class="line">s[top++] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给出一个序列，要求的是一个区间，这个区间的最小值乘以这个区间数字的和是最大值&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://sqwyyy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单调栈" scheme="https://sqwyyy.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
</feed>
