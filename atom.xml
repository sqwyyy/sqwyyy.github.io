<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sqwyyy.github.io/"/>
  <updated>2020-05-25T13:37:52.979Z</updated>
  <id>https://sqwyyy.github.io/</id>
  
  <author>
    <name>100Cooke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死锁</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%AD%BB%E9%94%81/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%AD%BB%E9%94%81/</id>
    <published>2020-05-25T13:37:13.000Z</published>
    <updated>2020-05-25T13:37:52.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><a id="more"></a><h2 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h2><p>死锁的出现必须同时满足以下四个条件，缺一不可。</p><ul><li><p>互斥：所谓互斥就是进程在某一时间内独占资源（更准确得说，对于某个资源访问有限制。若资源数量有限，也有可能产生死锁）。</p></li><li><p>请求与保持：已经持有某一资源的进程不必释放当前拥有的资源，就可以申请并获得更多的资源。</p></li><li>不可剥夺：进程已获得资源，在末使用完之前，不能强行剥夺。</li><li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系，每个进程都在等待循环链中另一进程持有的资源。</li></ul><h2 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h2><ul><li><p>打破互斥条件。</p><ul><li><p>即允许进程同时访问某些资源。</p></li><li><p>但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。</p></li></ul></li><li><p>打破请求与保持条件</p><ul><li><p>进程在运行前一次性地向系统申请它所需要的全部资源。</p></li><li><p>如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。</p></li><li>由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。</li></ul></li><li><p>打破不可剥夺条件</p><ul><li><p>允许进程强行从占有者那里夺取某些资源。</p></li><li><p>当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。</p></li></ul></li><li><p>打破循环等待条件</p><ul><li><p>前面三种预防策略都很棘手，所以大部分预防死锁的算法都把重心放在这里。</p></li><li><p>为预防循环等待条件的出现，可以实行资源<strong>有序分配策略</strong>。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成循环链。<strong>所有进程对资源的请求必须严格按资源序号递增的顺序提出</strong>。进程占用了小号资源，才能申请大号资源，就不会产生循环链，从而预防了死锁。</p></li></ul></li></ul><h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><p>可以使用<strong>银行家算法</strong>来避免死锁产生<br>银行家算法有以下数据结构</p><ul><li><p>可利用资源向量Available<br>是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果- Available[j]=K，则表示系统中现有Rj类资源K个。</p></li><li><p>最大需求矩阵Max<br>这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。</p></li><li>3 分配矩阵Allocation<br>这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。</li><li>4 需求矩阵Need。<br>这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。</li></ul><p>列子：<br>| Process | Allocation | Need    | Available |<br>| ———- | ————— | ———- | ————- |<br>| P0      | 0,0,3,2    | 0,0,1,2 | 1,6,2,2   |<br>| P1      | 1,0,0,0    | 1,7,5,0 |           |<br>| P2      | 1,3,5,4    | 2,3,5,6 |           |<br>| P3      | 0,3,3,2    | 0,6,5,2 |           |<br>| P4      | 0,0,1,4    | 0,6,5,6 |           |<br>(1)该进程是否安全<br>(2)若进程P2提出请求（1，2，2，2）后，系统能否将资源分配给它</p><p>(1)<br>| Process | Allocation | Need    | Allocation | Work+Allocation | Finsh |<br>| ———- | ————— | ———- | ————— | ———————- | ——- |<br>| P0      | 0,0,3,2    | 0,0,1,2 | 0,0,3,2    | 1,6,5,4         | true  |<br>| P1      | 1,0,0,0    | 1,7,5,0 | 0,3,3,2    | 1,9,8,6         | true  |<br>| P2      | 1,3,5,4    | 2,3,5,6 | 0,0,1,4    | 1,9,9,10        | true  |<br>| P3      | 0,3,3,2    | 0,6,5,2 | 1,0,0,0    | 2,9,9,10        | true  |<br>| P4      | 0,0,1,4    | 0,6,5,6 | 1,3,5,4    | 3,12,14,14      | true  |</p><p>存在一个安全序列{P0,P3,P4,P1,P2}</p><p>(2) P2提出请求（1，2，2，2）后，因Request&lt;=Need,Request&lt;=Available,故系统可考虑将资源分配给它，分配后Available变成（0，4，0，0）进行安全性检测，发现不能满足任何进程的需求，系统进入不安全状态，所以系统不能向P2分配资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;h2 id=&quot;什么是死锁&quot;&gt;&lt;a href=&quot;#什么是死锁&quot; class=&quot;headerlink&quot; title=&quot;什么是死锁&quot;&gt;&lt;/a&gt;什么是死锁&lt;/h2&gt;&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="https://sqwyyy.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-05-25T13:35:21.000Z</published>
    <updated>2020-05-25T13:36:04.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p>进程由进程控制块（PCB）、程序段、数据段三部分组成。</p><ul><li><p>进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。</p><ul><li><p>标识符：与进程相关的唯一标识符，用来区分其他进程。</p></li><li><p>状态：进程有不同的状态，例如运行，就绪，阻塞等。</p></li><li>优先级：为了给处理机调度提供支持，优先级用来区分各种进程的先后执行顺序</li><li>程序计数器：程序中即将执行的下一条指令的地址</li><li>内存指针：包括程序代码的进程相关数据的指针，以及与其他进程贡献那个内存块的指针。</li><li>上下文：进程是需要切换的，切换进程时需要保留进程的上下文信息，以防进程在切换时丢 失现场数据。</li><li>i/o状态信息：包括显示i/o请求，分配给进程的i/o设备和被进程使用的文件列表等。</li><li>记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</li></ul></li><li>代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。</li><li>数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据</li></ul><a id="more"></a><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><ol><li>无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li><li>FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li><li>消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li><li>信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li><li>共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。</li></ol><h2 id="进程间五种通信方式的比较"><a href="#进程间五种通信方式的比较" class="headerlink" title="进程间五种通信方式的比较"></a>进程间五种通信方式的比较</h2><ul><li>管道：速度慢，容量有限，只有父子进程能通讯。</li><li>FIFO：任何进程间都能通讯，但速度慢。</li><li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</li><li>信号量：不能传递复杂消息，只能用来同步。</li><li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li></ul><h2 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h2><p>线程之间的通信机制有两种，<strong>共享内存和消息传递</strong></p><ul><li>使用volatile是属于共享内存模型</li><li>使用wait和notify方法属于消息传递(wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁)<br><a href="https://blog.csdn.net/jisuanji12306/article/details/86363390" target="_blank" rel="noopener">代码实例</a></li></ul><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p><a href="https://blog.csdn.net/kuangsonghan/article/details/80674777" target="_blank" rel="noopener">来源</a><br>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><p>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p><p>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><h2 id="关于线程与进程的选取"><a href="#关于线程与进程的选取" class="headerlink" title="关于线程与进程的选取"></a>关于线程与进程的选取</h2><ol><li><p>需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。</p></li><li><p>线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p></li><li><p>因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；</p></li><li><p>并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求；</p></li><li><p>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</p></li></ol><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>串行：一次只能取得一个任务并执行这一个任务<br>并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务<br>并发是一种现象：同时运行多个程序或多个任务需要被处理的现象<br><a href="https://www.cnblogs.com/f-ck-need-u/p/11161481.html" target="_blank" rel="noopener">来源</a></p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ol><li><p>新建：就是刚使用new方法，new出来的线程；</p></li><li><p>就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</p></li><li><p>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</p></li><li><p>阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</p></li><li><p>销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;<br><a href="https://www.cnblogs.com/marsitman/p/11228684.html" target="_blank" rel="noopener">来源</a><br><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt=""></p></li></ol><h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。<strong>调用sleep不会释放对象锁</strong>,在多线程异步时可能用到。</p><p>wait是Object类的方法，对此对象调用wait方法<strong>导致本线程放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池<strong>准备</strong>获得对象锁进入运行状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，</span></span><br><span class="line">            <span class="comment">// 我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。</span></span><br><span class="line">            <span class="comment">// 我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MultiThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"enter thread1..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread1 is waiting"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁有两种方式，第一种方式是程序自然离开监视器的范围，</span></span><br><span class="line">                    <span class="comment">// 也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字</span></span><br><span class="line">                    <span class="comment">// 管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。</span></span><br><span class="line">                    MultiThread<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"thread1 is going on..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread1 is being over!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MultiThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"enter thread2..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 notify other thread can release wait status.."</span>);</span><br><span class="line">                <span class="comment">// 由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，</span></span><br><span class="line">                <span class="comment">// 但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。</span></span><br><span class="line">                MultiThread<span class="class">.<span class="keyword">class</span>.<span class="title">notify</span>()</span>;</span><br><span class="line">                System.out.println(<span class="string">"thread2 is sleeping ten millisecond..."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>*<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"thread2 is going on..."</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread2 is being over!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter thread1...</span><br><span class="line">thread1 is waiting</span><br><span class="line">enter thread2...</span><br><span class="line">thread2 notify other thread can release wait status..</span><br><span class="line">thread2 is sleeping ten millisecond...</span><br><span class="line">thread2 is going on...</span><br><span class="line">thread2 is being over!</span><br><span class="line">thread1 is going on...</span><br><span class="line">thread1 is being over!</span><br></pre></td></tr></table></figure><br><a href="https://www.jianshu.com/p/ab05baf75d75" target="_blank" rel="noopener">来源</a></p><h3 id="中断线程的方法"><a href="#中断线程的方法" class="headerlink" title="中断线程的方法"></a>中断线程的方法</h3><ol><li><p>使用interrupt()方法中断当前线程：interrupt()其本身并不是一个强制打断线程的方法，其仅仅会修改线程的interrupt标志位，然后让线程自行去读标志位，自行判断是否需要中断。在设计里，如果线程处于休眠状态，那一旦其被调用interrupt()方法，则就没有必要继续休眠下去了，直接抛出异常InterruptedException，让被打断线程去做收尾操作，及时释放线程资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">500000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程已经终止， for循环不再执行"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"i="</span>+(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">i&#x3D;202053</span><br><span class="line">i&#x3D;202054</span><br><span class="line">i&#x3D;202055</span><br><span class="line">i&#x3D;202056</span><br></pre></td></tr></table></figure></li><li><p>如果使用线程池可将线程池的状态修改为STOP状态(该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；)</p></li></ol><h3 id="控制多个线程按顺序执行"><a href="#控制多个线程按顺序执行" class="headerlink" title="控制多个线程按顺序执行"></a>控制多个线程按顺序执行</h3><p>join方法:</p><ol><li>在子线程中通过join()方法指定顺序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thread2.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//下面三行代码顺序可随意调整，程序运行结果不受影响，因为我们在子线程中通过“join()方法”已经指定了运行顺序。</span></span><br><span class="line">        thread3.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在主线程中通过join()方法指定顺序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMainJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>3.创建单一化线程池newSingleThreadExecutor()实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span> ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"打开冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"拿出一瓶牛奶！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关上冰箱！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(thread1);</span><br><span class="line">        executorService.submit(thread2);</span><br><span class="line">        executorService.submit(thread3);</span><br><span class="line">        executorService.shutdown();        <span class="comment">//使用完毕记得关闭线程池</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a href="https://blog.csdn.net/jqc874789596/article/details/100557300" target="_blank" rel="noopener">来源</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程的组成&quot;&gt;&lt;a href=&quot;#进程的组成&quot; class=&quot;headerlink&quot; title=&quot;进程的组成&quot;&gt;&lt;/a&gt;进程的组成&lt;/h2&gt;&lt;p&gt;进程由进程控制块（PCB）、程序段、数据段三部分组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程控制块（PCB)：用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进存在的一个重要数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标识符：与进程相关的唯一标识符，用来区分其他进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态：进程有不同的状态，例如运行，就绪，阻塞等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;优先级：为了给处理机调度提供支持，优先级用来区分各种进程的先后执行顺序&lt;/li&gt;
&lt;li&gt;程序计数器：程序中即将执行的下一条指令的地址&lt;/li&gt;
&lt;li&gt;内存指针：包括程序代码的进程相关数据的指针，以及与其他进程贡献那个内存块的指针。&lt;/li&gt;
&lt;li&gt;上下文：进程是需要切换的，切换进程时需要保留进程的上下文信息，以防进程在切换时丢 失现场数据。&lt;/li&gt;
&lt;li&gt;i/o状态信息：包括显示i/o请求，分配给进程的i/o设备和被进程使用的文件列表等。&lt;/li&gt;
&lt;li&gt;记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码段：是进程中能被进程调度程序在CPU上执行的程序代码段。&lt;/li&gt;
&lt;li&gt;数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="https://sqwyyy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程&amp;线程" scheme="https://sqwyyy.github.io/tags/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-05-25T13:33:47.000Z</published>
    <updated>2020-05-25T13:34:23.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本类型和引用类型在内存中的保存"><a href="#基本类型和引用类型在内存中的保存" class="headerlink" title="基本类型和引用类型在内存中的保存"></a>基本类型和引用类型在内存中的保存</h1><p>Java中数据类型分为两大类：<strong>基本类型和对象类型</strong><br>变量也有两种类型：<strong>基本类型和引用类型</strong></p><p><strong>基本类型的变量保存原始值，即它代表的值就是数值本身</strong><br><strong>引用类型的变量保存引用值，”引用值”指向内存空间的地址，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置</strong>。<br>基本类型包括：byte,short,int,long,char,float,double,boolean<br>引用类型包括：类类型，接口类型和数组</p><a id="more"></a><h1 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h1><p>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，<strong>后面方法中的操作都是对形参这个值的修改，不影响实际参数的值</strong>。</p><h1 id="引用传递："><a href="#引用传递：" class="headerlink" title="引用传递："></a>引用传递：</h1><p>也称为传地址。方法调用时，<strong>实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址</strong>；<br>在方法执行中，形参和实参内容相同，指向同一块内存地址，<strong>方法执行中对引用的操作将会影响到实际对象</strong>。</p><p><strong>在java中无论是浅拷贝还是深拷贝都要实现Clonenable接口，并且重写clone方法</strong></p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number=<span class="number">123</span>;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.setNumber(number);</span><br><span class="line">        Student stu2 =stu1;</span><br><span class="line">        stu2.setNumber(<span class="number">321</span>);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        System.out.println(stu1 == stu2);</span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());</span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">true</span><br><span class="line">学生1：321</span><br><span class="line">学生2：123</span><br></pre></td></tr></table></figure></p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number=<span class="number">123</span>;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.setNumber(number);</span><br><span class="line">        Student stu2 = (Student)stu1.clone();</span><br><span class="line">        stu2.setNumber(<span class="number">321</span>);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">        System.out.println(stu1 == stu2);</span><br><span class="line">        System.out.println(<span class="string">"学生1:"</span> + stu1.getNumber());</span><br><span class="line">        System.out.println(<span class="string">"学生2:"</span> + stu2.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Student stu = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                stu = (Student)<span class="keyword">super</span>.clone();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">false</span><br><span class="line">学生1：321</span><br><span class="line">学生2：123</span><br></pre></td></tr></table></figure></p><h1 id="clone和new的区别"><a href="#clone和new的区别" class="headerlink" title="clone和new的区别"></a>clone和new的区别</h1><ul><li><p>共同点：都是分配内存，对象都是指向不同的内存地址</p></li><li><p>不同点：new创建一个对象，clone复制一个对象。new是返回的新对象，而调用clone()方法时，拷贝对象已经包含了一些原来对象的信息，而不是对象的初始信息</p></li></ul><h1 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h1><p>在Object类的clone()是一个native方法，如果实现clone()方法的类没有实现Cloneable接口，并调用了Object的clone()方法（也就是调用了 super.clone()方法），那么Object的clone()方法就会抛出CloneNotSupportedException异常</p><p><a href="https://www.jianshu.com/p/e8c6155d9694" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本类型和引用类型在内存中的保存&quot;&gt;&lt;a href=&quot;#基本类型和引用类型在内存中的保存&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型在内存中的保存&quot;&gt;&lt;/a&gt;基本类型和引用类型在内存中的保存&lt;/h1&gt;&lt;p&gt;Java中数据类型分为两大类：&lt;strong&gt;基本类型和对象类型&lt;/strong&gt;&lt;br&gt;变量也有两种类型：&lt;strong&gt;基本类型和引用类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本类型的变量保存原始值，即它代表的值就是数值本身&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;引用类型的变量保存引用值，”引用值”指向内存空间的地址，代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置&lt;/strong&gt;。&lt;br&gt;基本类型包括：byte,short,int,long,char,float,double,boolean&lt;br&gt;引用类型包括：类类型，接口类型和数组&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JAVA拷贝" scheme="https://sqwyyy.github.io/tags/JAVA%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-05-25T13:32:05.000Z</published>
    <updated>2020-05-25T13:33:13.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用阻塞队列"><a href="#为什么要用阻塞队列" class="headerlink" title="为什么要用阻塞队列"></a>为什么要用阻塞队列</h1><p>在并发编程中，有时候需要使用<strong>线程安全的队列</strong>。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。</p><ol><li>使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li><li>非阻塞的实现方式则可以使用循环CAS的方式来实现。</li></ol><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<strong>这两个附加的操作支持阻塞的插入和移除方法</strong>, 意指再读取和插入操作情况下可能(注意是可能)会出现阻塞。</p><h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><p>该阻塞队列是<strong>基于数组实现的，必须制定大小且不可变</strong>，同时使用ReentrantLock来实现并发问题的解决。同时需要注意的是<strong>ArrayBlockingQueue只有一把锁，put和take操作会相互阻塞</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;  <span class="comment">//队列的底层为数组，是个循环数组</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;  <span class="comment">//从队列中取元素的索引，用于take、poll、remove</span></span><br><span class="line"><span class="keyword">int</span> putIndex;  <span class="comment">//向队列中存放元素的索引，用于put、offer、add</span></span><br><span class="line"><span class="keyword">int</span> count;  <span class="comment">//队列中的元素数</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock; <span class="comment">//队列中的锁机制，可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">//notEmpty条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  <span class="comment">//notFull条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;  <span class="comment">//迭代器对象</span></span><br></pre></td></tr></table></figure><p>put操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Objects.requireNonNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>take 操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>LinkedBlockingQueue和ArrayBlockingQueue十分相似，其底层是<strong>借由链表</strong>实现。除此之外，还有一个不同点，<strong>LinkedBlockingQueue拥有两个锁，因此put和take的线程可以同时运行</strong>,count元素是用AtomicInteger来修饰的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;  <span class="comment">//元素</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//next指针</span></span><br><span class="line">        </span><br><span class="line">        Node(E x) &#123;  <span class="comment">//有参构造函数</span></span><br><span class="line">          item = x;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;  <span class="comment">//容量，默认为 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();  <span class="comment">//队列中元素的数量</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;  <span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//拿锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();  <span class="comment">//拿锁的条件，队列不为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">//放锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();  <span class="comment">//放锁的条件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>put操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">             * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">             * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">             * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">             * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">             * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>take操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> E x;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p>PriorityBlockingQueue可以根据自定义的优先级来构建一个有序的二叉堆数据结构，这种结构在插入数据的时候就能够根据自定义的排序规则（对象实现Compareable和Comparator）来生成一个有序的堆，通过这样来定义一个按优先级顺序的队列集合，不再是默认的先进先出规则，需要注意的是优先级队列的put方法并不阻塞，默认的数组的长度是11，在插入满的时候会扩容。take方法在队列为空的时候会进入阻塞状态。</p><h1 id="生产者消费者模型的实现"><a href="#生产者消费者模型的实现" class="headerlink" title="生产者消费者模型的实现"></a>生产者消费者模型的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/29 - 18:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; q;</span><br><span class="line">    <span class="keyword">public</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> Condition producelock = lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> Condition wastelock = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span>  <span class="title">produce</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(cnt == num) &#123;</span><br><span class="line">                    producelock.await();</span><br><span class="line">                &#125;</span><br><span class="line">                String tmp = <span class="string">"生产线程"</span>+Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">"我已经制造了"</span>+Thread.currentThread().getName());</span><br><span class="line">                cnt++;</span><br><span class="line">                q.add(tmp);</span><br><span class="line">                wastelock.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">wate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    wastelock.await();</span><br><span class="line">                &#125;</span><br><span class="line">                String tmp = q.poll();</span><br><span class="line">                System.out.println(tmp);</span><br><span class="line">                <span class="comment">//System.out.println("我已经消耗了"+Thread.currentThread().getName()+" "+tmp);</span></span><br><span class="line">                cnt--;</span><br><span class="line">                producelock.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Pool pool = <span class="keyword">new</span> Pool(<span class="number">3</span>);</span><br><span class="line">        produce p = pool.<span class="keyword">new</span> produce();</span><br><span class="line">        wate w = pool.<span class="keyword">new</span> wate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(p).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(w).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 为什么要用阻塞队列</span><br><span class="line">在并发编程中，有时候需要使用**线程安全的队列**。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 非阻塞的实现方式则可以使用循环CAS的方式来实现。</span><br><span class="line"></span><br><span class="line"># 基本概念</span><br><span class="line">阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。**这两个附加的操作支持阻塞的插入和移除方法**, 意指再读取和插入操作情况下可能(注意是可能)会出现阻塞。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ArrayBlockingQueue</span><br><span class="line">该阻塞队列是**基于数组实现的，必须制定大小且不可变**，同时使用ReentrantLock来实现并发问题的解决。同时需要注意的是**ArrayBlockingQueue只有一把锁，put和take操作会相互阻塞**。</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">    <span class="keyword">final</span> Object[] items;  <span class="comment">//队列的底层为数组，是个循环数组</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;  <span class="comment">//从队列中取元素的索引，用于take、poll、remove</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;  <span class="comment">//向队列中存放元素的索引，用于put、offer、add</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">//队列中的元素数</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock; <span class="comment">//队列中的锁机制，可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">//notEmpty条件对象，由lock创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  <span class="comment">//notFull条件对象，由lock创建</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;  <span class="comment">//迭代器对象</span></span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>put操作:<br>​```java<br>public void put(E e) throws InterruptedException {<br>        Objects.requireNonNull(e);<br>        final ReentrantLock lock = this.lock;<br>        lock.lockInterruptibly();<br>        try {<br>            while (count == items.length)<br>                notFull.await();<br>            enqueue(e);<br>        } finally {<br>            lock.unlock();<br>        }<br>    }</p><p>​<code>take 操作​</code>java<br>public E take() throws InterruptedException {<br>        final ReentrantLock lock = this.lock;<br>        lock.lockInterruptibly();<br>        try {<br>            while (count == 0)<br>                notEmpty.await();<br>            return dequeue();<br>        } finally {<br>            lock.unlock();<br>        }<br>    }</p><p>​```</p><h1 id="LinkedBlockingQueue-1"><a href="#LinkedBlockingQueue-1" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>LinkedBlockingQueue和ArrayBlockingQueue十分相似，其底层是<strong>借由链表</strong>实现。除此之外，还有一个不同点，<strong>LinkedBlockingQueue拥有两个锁，因此put和take的线程可以同时运行</strong>,count元素是用AtomicInteger来修饰的<br>​```java<br>static class Node<E> {<br>        E item;  //元素<br>        Node<E> next;//next指针</p><pre><code>    Node(E x) {  //有参构造函数      item = x;      }private final int capacity;  //容量，默认为 Integer.MAX_VALUEprivate final AtomicInteger count = new AtomicInteger();  //队列中元素的数量transient Node&lt;E&gt; head;  //头节点private transient Node&lt;E&gt; last;  //尾节点private final ReentrantLock takeLock = new ReentrantLock(); //拿锁private final Condition notEmpty = takeLock.newCondition();  //拿锁的条件，队列不为空private final ReentrantLock putLock = new ReentrantLock();  //放锁private final Condition notFull = putLock.newCondition();  //放锁的条件}</code></pre><p>​<code>put操作:​</code>java<br>public void put(E e) throws InterruptedException {<br>        if (e == null) throw new NullPointerException();<br>        final int c;<br>        final Node<E> node = new Node<E>(e);<br>        final ReentrantLock putLock = this.putLock;<br>        final AtomicInteger count = this.count;<br>        putLock.lockInterruptibly();<br>        try {<br>            /*</p><pre><code>         * Note that count is used in wait guard even though it is         * not protected by lock. This works because count can         * only decrease at this point (all other puts are shut         * out by lock), and we (or some other waiting put) are         * signalled if it ever changes from capacity. Similarly         * for all other uses of count in other wait guards.         */        while (count.get() == capacity) {            notFull.await();        }        enqueue(node);        c = count.getAndIncrement();        if (c + 1 &lt; capacity)            notFull.signal();    } finally {        putLock.unlock();    }    if (c == 0)        signalNotEmpty();}</code></pre><p>​<code>take操作:​</code>java<br>public E take() throws InterruptedException {<br>        final E x;<br>        final int c;<br>        final AtomicInteger count = this.count;<br>        final ReentrantLock takeLock = this.takeLock;<br>        takeLock.lockInterruptibly();<br>        try {<br>            while (count.get() == 0) {<br>                notEmpty.await();<br>            }<br>            x = dequeue();<br>            c = count.getAndDecrement();<br>            if (c &gt; 1)<br>                notEmpty.signal();<br>        } finally {<br>            takeLock.unlock();<br>        }<br>        if (c == capacity)<br>            signalNotFull();<br>        return x;<br>    }</p><p>​```</p><h1 id="PriorityBlockingQueue-1"><a href="#PriorityBlockingQueue-1" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h1><p>PriorityBlockingQueue可以根据自定义的优先级来构建一个有序的二叉堆数据结构，这种结构在插入数据的时候就能够根据自定义的排序规则（对象实现Compareable和Comparator）来生成一个有序的堆，通过这样来定义一个按优先级顺序的队列集合，不再是默认的先进先出规则，需要注意的是优先级队列的put方法并不阻塞，默认的数组的长度是11，在插入满的时候会扩容。take方法在队列为空的时候会进入阻塞状态。</p><h1 id="生产者消费者模型的实现-1"><a href="#生产者消费者模型的实现-1" class="headerlink" title="生产者消费者模型的实现"></a>生产者消费者模型的实现</h1><p>​```java<br>package test;</p><p>import java.util.LinkedList;<br>import java.util.Queue;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.locks.Condition;<br>import java.util.concurrent.locks.ReentrantLock;</p><p>/**</p><ul><li><p>@date 2020/3/29 - 18:42<br>*/<br>public class Pool {<br> private int num;<br> private volatile int cnt;<br> private Queue<String> q;<br> public ReentrantLock lock = new ReentrantLock();<br> public Condition producelock = lock.newCondition();<br> public Condition wastelock = lock.newCondition();</p><p> public Pool(int num){</p><pre><code> this.num = num; q = new LinkedList&lt;&gt;(); cnt = 0;</code></pre><p> }</p><p> class  produce implements Runnable{</p><pre><code> @Override public void run() {     lock.lock();     try {         while(cnt == num) {             producelock.await();         }         String tmp = &quot;生产线程&quot;+Thread.currentThread().getName();         System.out.println(&quot;我已经制造了&quot;+Thread.currentThread().getName());         cnt++;         q.add(tmp);         wastelock.signalAll();     } catch (InterruptedException e) {         e.printStackTrace();     }     finally {         lock.unlock();     } }</code></pre><p> }</p><p> class wate implements Runnable{</p><pre><code> public void run(){     lock.lock();     try {         while(cnt == 0) {             wastelock.await();         }         String tmp = q.poll();         System.out.println(tmp);         //System.out.println(&quot;我已经消耗了&quot;+Thread.currentThread().getName()+&quot; &quot;+tmp);         cnt--;         producelock.signalAll();     } catch (InterruptedException e) {         e.printStackTrace();     }     finally {         lock.unlock();     } }</code></pre><p> }</p><p> public static void main(String[] args) {</p><pre><code> Pool pool = new Pool(3); produce p = pool.new produce(); wate w = pool.new wate(); for(int i = 0 ; i&lt;5;i++){     new Thread(p).start();     new Thread(w).start(); }</code></pre><p> }</p></li></ul><p>}</p><p>​```</p><p>```</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要用阻塞队列&quot;&gt;&lt;a href=&quot;#为什么要用阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;为什么要用阻塞队列&quot;&gt;&lt;/a&gt;为什么要用阻塞队列&lt;/h1&gt;&lt;p&gt;在并发编程中，有时候需要使用&lt;strong&gt;线程安全的队列&lt;/strong&gt;。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。&lt;/li&gt;
&lt;li&gt;非阻塞的实现方式则可以使用循环CAS的方式来实现。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JAVA基础知识" scheme="https://sqwyyy.github.io/categories/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JAVA集合类" scheme="https://sqwyyy.github.io/tags/JAVA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis常见问题</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-25T13:30:21.000Z</published>
    <updated>2020-05-25T13:31:20.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis快的原因"><a href="#redis快的原因" class="headerlink" title="redis快的原因"></a>redis快的原因</h1><a id="more"></a><h2 id="IO多路复用阻塞机制"><a href="#IO多路复用阻塞机制" class="headerlink" title="IO多路复用阻塞机制"></a>IO多路复用阻塞机制</h2><h3 id="为什么需要使用IO多路复用"><a href="#为什么需要使用IO多路复用" class="headerlink" title="为什么需要使用IO多路复用"></a>为什么需要使用IO多路复用</h3><p>Redis 是跑在<strong>单线程</strong>中的，所有的操作都是按照顺序线性执行的，但是<strong>由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务</strong>，而 I/O 多路复用就是为了解决这个问题而出现的。</p><h3 id="什么是I-O-多路复用"><a href="#什么是I-O-多路复用" class="headerlink" title="什么是I/O 多路复用"></a>什么是I/O 多路复用</h3><p><strong>I/O 多路复用其实是在单个线程中通过记录跟踪每一个sock（I/O流） 的状态来管理多个I/O流</strong>。<br>select, poll, epoll 都是I/O多路复用的具体的实现。epoll性能比其他几者要好。redis中的I/O多路复用的所有功能通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的。</p><h2 id="数据结构简单，操作节省时间"><a href="#数据结构简单，操作节省时间" class="headerlink" title="数据结构简单，操作节省时间"></a>数据结构简单，操作节省时间</h2><h2 id="运行在内存中"><a href="#运行在内存中" class="headerlink" title="运行在内存中"></a>运行在内存中</h2><h1 id="Redis的数据淘汰机制"><a href="#Redis的数据淘汰机制" class="headerlink" title="Redis的数据淘汰机制"></a>Redis的数据淘汰机制</h1><ul><li><p>volatile-lru 从<strong>已设置过期时间</strong>的数据集中挑选<strong>最近最少使用的数据</strong>淘汰</p></li><li><p>volatile-ttl 从<strong>已设置过期时间</strong>的数据集中挑选将<strong>要过期的数据</strong>淘汰</p></li><li>volatile-random从<strong>已设置过期时间</strong>的数据集中<strong>任意选择数据</strong>淘汰</li><li>allkeys-lru从<strong>所有数据集</strong>中挑选<strong>最近最少使用</strong>的数据淘汰</li><li>allkeys-random从<strong>所有数据集</strong>中<strong>任意选择数据进行淘汰noeviction禁止驱逐数据</strong></li></ul><h1 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h1><ul><li><p>RDB 持久化</p><ol><li><p>RDB持久化是将某个时间点上Redis中的数据保存到一个RDB文件中,该文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时Redis中的数据</p></li><li><p>Redis提供了2个命令来创建RDB文件，一个是SAVE，另一个是BGSAVE。</p><ul><li>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li><li>BGSAVE命令会派生出一个<strong>子进程</strong>，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</li></ul></li><li>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</li><li>如果数据量很大，保存快照的时间会很长。</li></ol></li><li><p>AOF 持久化</p><ol><li><p>AOF持久化是通过将Redis服务器执行的所有写命令保存到AOF文件中来实现持久化的</p></li><li><p><strong>将写命令添加到 AOF 文件（Append Only File）的末尾</strong>。</p><ul><li><p>当AOF持久化功能处于打开状态时，Redis服务器在<strong>执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的AOF缓冲区的末尾</strong>，然后<strong>Redis服务器会根据配置文件中appendfsync选项的值来决定何时将AOF缓冲区中的内容写入和同步到AOF文件*</strong>里面有以下同步选项：</p><ol><li><p>always 选项会严重减低服务器的性能,<strong>服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件</strong>，并且同步AOF文件；</p></li><li><p>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，<strong>因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行同步</strong>；</p></li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量,<strong>因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制</strong></li></ol></li></ul><ol><li><p>为了解决AOF文件体积越来越大的问题，Redis提供了AOF文件重写功能<br>实现原理:</p><ol><li><strong>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令</strong>。</li></ol><p>AOF后台重写:</p><ol><li><p>服务器进程创建<strong>子进程</strong>，子进程开始AOF文件重写</p></li><li><p>从创建子进程开始，服务器进程执行的所有写命令不仅要写入AOF缓冲区，还要写入AOF重写缓冲区<br>写入AOF缓冲区的目的是为了同步到原有的AOF文件。<br>写入AOF重写缓冲区的目的是因为子进程在进行AOF文件重写期间，服务器进程还在继续处理命令请求，<br>而新的命令可能会对现有的数据库进行修改，从而使得服务器当前的数据库数据和重写后的AOF文件所<br>保存的数据库数据不一致。</p></li><li><p>子进程完成AOF重写工作，向父进程发送一个信号，父进程在接收到该信号后，会执行以下操作：</p><ol><li><p>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这样就保证了新AOF文件所保存的数据库数据和服务器当前的数据库数据是一致的。</p></li><li><p>对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p></li></ol></li></ol></li><li><p>采用子进程的好处:</p><ol><li><p>子进程进行AOF文件重写期间，服务器进程（父进程）可以继续处理命令请求。<br>子进程带有服务器进程的数据副本，</p></li><li><p>使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</p></li></ol></li></ol></li></ol></li></ul><p><a href="https://zhuanlan.zhihu.com/p/106997927" target="_blank" rel="noopener">RDB与AOF详解</a></p><h1 id="缓存穿透，缓存雪崩以及缓存击穿"><a href="#缓存穿透，缓存雪崩以及缓存击穿" class="headerlink" title="缓存穿透，缓存雪崩以及缓存击穿"></a>缓存穿透，缓存雪崩以及缓存击穿</h1><ul><li><p>缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。</p></li><li><p>缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中</p></li><li>缓存雪崩：就是大量数据同一时间失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</li><li>打个比方，你是个很有钱的人，开满了百度云，腾讯视频各种杂七杂八的会员，但是你就是没有netflix的会员，然后你把这些账号和密码发布到一个你自己做的网站上，然后你有一个朋友每过十秒钟就查询你的网站，发现你的网站没有Netflix的会员后打电话向你要。你就相当于是个数据库，网站就是Redis。这就是缓存穿透。</li><li>大家都喜欢看腾讯视频上的《水果传》，但是你的会员突然到期了，大家在你的网站上看不到腾讯视频的账号，纷纷打电话向你询问，这就是缓存击穿</li><li>你的各种会员突然同一时间都失效了，那这就是缓存雪崩了。</li></ul><p>解决方法</p><ul><li><p>缓存穿透：</p><ol><li><p>使用布隆过滤器判断改数据是否存在 <a href="https://zhuanlan.zhihu.com/p/72378274" target="_blank" rel="noopener">布隆过滤器</a></p></li><li><p>缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击</p></li></ol></li><li><p>缓存击穿：</p><ol><li>最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员</li></ol></li><li><p>缓存雪崩：</p><ol><li><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p></li><li><p>通过加锁或者队列来控制读数据库写缓存的线程数量。</p></li><li>通过synchronized+双重检查机制：某个key只让一个线程查询，阻塞其它线程</li></ol></li></ul><h1 id="缓存和数据库间的一致性问题"><a href="#缓存和数据库间的一致性问题" class="headerlink" title="缓存和数据库间的一致性问题"></a>缓存和数据库间的一致性问题</h1><p>读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：<strong>数据库和缓存更新</strong>，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。</p><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p><ol><li><p>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p></li><li><p>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p></li></ol><p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><ul><li><p>采用延时双删策略</p><ul><li>先删除缓存；</li><li>再写数据库；</li><li>休眠500毫秒；</li><li>再次删除缓存。</li></ul></li><li><p>设置缓存过期时间<br>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p></li><li><p>该方案的弊端<br>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p></li></ul><h3 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h3><p>技术整体思路：</p><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><ul><li><p>读Redis：热数据基本都在Redis</p></li><li><p>写MySQL:增删改都是操作MySQL</p></li><li>更新Redis数据：MySQ的数据操作binlog，来更新到Redis<br>Redis更新</li></ul><ol><li><p>数据操作主要分为两大块：</p><ul><li><p>一个是全量(将全部数据一次写入到redis)</p></li><li><p>一个是增量（实时更新）<br>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p></li></ul></li><li><p>读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</p></li><li><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p></li><li><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p></li><li><p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p></li><li><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p></li></ol><p><a href="https://zhuanlan.zhihu.com/p/58536781" target="_blank" rel="noopener">解决redis和数据库间数据一致性的问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis快的原因&quot;&gt;&lt;a href=&quot;#redis快的原因&quot; class=&quot;headerlink&quot; title=&quot;redis快的原因&quot;&gt;&lt;/a&gt;redis快的原因&lt;/h1&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>springboot整合redis</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/springboot%E6%95%B4%E5%90%88redis/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/springboot%E6%95%B4%E5%90%88redis/</id>
    <published>2020-05-25T13:28:32.000Z</published>
    <updated>2020-05-25T13:31:20.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导入maven依赖"><a href="#导入maven依赖" class="headerlink" title="导入maven依赖"></a>导入maven依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 添加Redis缓存支持 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--spring2.0集成redis所需common-pool2--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 必须加上，jedis依赖此  --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- spring boot 2.0 的操作手册有标注 大家可以去看看 地址是：https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="配置application-properties文件"><a href="#配置application-properties文件" class="headerlink" title="配置application.properties文件"></a>配置application.properties文件</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>= <span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">60s</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">-1</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1s</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">500</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure><h1 id="创建一个RedisCaCheConfig"><a href="#创建一个RedisCaCheConfig" class="headerlink" title="创建一个RedisCaCheConfig"></a>创建一个RedisCaCheConfig</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DigestUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/22 - 23:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">//private Logger logger = LoggerFactory.getLogger(RedisCacheConfig.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LettuceConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新配置缓存</span></span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置缓存的默认超时时间：30分钟</span></span><br><span class="line">        redisCacheConfiguration = redisCacheConfiguration.entryTtl(Duration.ofMinutes(<span class="number">30L</span>))</span><br><span class="line">                .disableCachingNullValues()</span><br><span class="line">                .disableKeyPrefix()</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer((<span class="keyword">new</span> GenericJackson2JsonRedisSerializer())));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. entryTtl: 定义默认的cache time-to-live.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2. disableCachingNullValues: 禁止缓存Null对象. 这个识需求而定.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3. computePrefixWith: 此处定义了cache key的前缀, 避免公司不同项目之间的key名称冲突.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4. serializeKeysWith, serializeValuesWith: 定义key和value的序列化协议, 同时的hash key和hash value也被定义.</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(RedisCacheWriter</span><br><span class="line">                .nonLockingRedisCacheWriter(redisConnectionFactory))</span><br><span class="line">                .cacheDefaults(redisCacheConfiguration).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  设置自动key的生成规则，配置spring boot的注解，进行方法级别的缓存,使用：进行分割，可以很多显示出层级关系</span></span><br><span class="line">        <span class="comment">// 这里其实就是new了一个KeyGenerator对象，只是这是lambda表达式的写法，我感觉很好用，大家感兴趣可以去了解下</span></span><br><span class="line">        <span class="keyword">return</span> (target, method, params) -&gt; &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(target.getClass().getName());</span><br><span class="line">            sb.append(<span class="string">":"</span>);</span><br><span class="line">            sb.append(method.getName());</span><br><span class="line">            <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                sb.append(<span class="string">":"</span> + String.valueOf(obj));</span><br><span class="line">            &#125;</span><br><span class="line">            String rsToUse = String.valueOf(sb);</span><br><span class="line">            System.out.println(<span class="string">"调用Redis缓存Key : "</span> + rsToUse);</span><br><span class="line">            <span class="keyword">return</span> rsToUse;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建一个Redisconfig"><a href="#创建一个Redisconfig" class="headerlink" title="创建一个Redisconfig"></a>创建一个Redisconfig</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.AutoConfigureAfter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(RedisAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Serializable&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置key和value的序列化规则</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/5 - 13:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span>  String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findUserbyId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">test</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.findUserById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;导入maven依赖&quot;&gt;&lt;a href=&quot;#导入maven依赖&quot; class=&quot;headerlink&quot; title=&quot;导入maven依赖&quot;&gt;&lt;/a&gt;导入maven依赖&lt;/h1&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-cache&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 添加Redis缓存支持 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-redis&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.4.3.RELEASE&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--spring2.0集成redis所需common-pool2--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 必须加上，jedis依赖此  --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- spring boot 2.0 的操作手册有标注 大家可以去看看 地址是：https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.commons&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-pool2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.5.0&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
      <category term="缓存" scheme="https://sqwyyy.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/redis/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/redis/</id>
    <published>2020-05-25T13:27:14.000Z</published>
    <updated>2020-05-25T13:31:20.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>Redis 有 5 种基础数据结构，它们分别是：<strong>string、list、字典、压缩列表和跳跃表</strong>。</p><a id="more"></a><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis中的每一个对象都由一个redisObject结构表示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><br>对于Redis数据库保持的键值对来说，<strong>键总是一个字符串对象</strong>，值可以是<strong>字符串对象，列表对象，哈希对象，集合对象或者有序集合对象</strong></p><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>SDS是<strong>一种动态字符串</strong>，在redis中，它并未使用C语言中的字符串，而是自己实现了<strong>一种叫做SDS的数据结构</strong>，它的结构表示如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用字节的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中剩余空间的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[]; <span class="comment">//字节数组，用于存储字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="SDS相比于char字符数组的优势"><a href="#SDS相比于char字符数组的优势" class="headerlink" title="SDS相比于char字符数组的优势"></a>SDS相比于char字符数组的优势</h2><ul><li>获取字符串长度为 O(1) 级别的操作</li><li>可以避免缓冲区溢出/内存泄漏 </li><li>二进制安全，C字符串的字符必须符合某种编码（ASCII）,SDS可以保持像图片，视频等这样的二进制文件。在C中的字符数组以’\0’结束，在SDS中可以允许多个’\0’的存在。<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2>双向链表的插入删除的时间复杂度为O(1)，查询的时间复杂度为O(N)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;<span class="comment">//节点的值</span></span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);<span class="comment">//节点赋值函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);<span class="comment">//节点释放函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);<span class="comment">//节点对比函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;<span class="comment">//双向链表的长度</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Redis的字典使用哈希表作为底层实现,<strong>一个字典中有两个哈希表，一个哈希表里面可以有多个哈希表节点，每个哈希表节点就保存字典中的一个键值对</strong>。<br>字典:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><p>哈希表:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><br>Hash表节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">// 单链表结构</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><br>dict结构大概如上所示，</p><ul><li>dictht ht[2]：在dict的内部，维护了两张哈希表，作用等同于是一对滚动数组，一张表是旧表，一张表是新表，当hashtable的大小需要动态改变的时候，旧表中的元素就往新开辟的新表中迁移，当下一次变动大小，当前的新表又变成了旧表，以此达到资源的复用和效率的提升</li><li>dictht::table：哈希表内部的table结构使用了<strong>链地址法来解决哈希冲突</strong>，这其实是一个指向数组的指针，数组中的每一项都是entry链表的头结点</li><li>rehashidx：因为是渐进式的哈希，数据的迁移并不是一步完成的，所以需要有一个索引来指示当前的rehash进度。当rehashidx为-1时，代表没有哈希操作。</li></ul><ol><li><p>Reids的Hash采用<strong>链地址法来处理冲突，然后它没有使用红黑树优化</strong>。</p></li><li><p>哈希表节点采用<strong>单链表结构</strong>。</p></li><li><p>rehash优化。</p></li></ol><h2 id="rehash优化"><a href="#rehash优化" class="headerlink" title="rehash优化"></a>rehash优化</h2><p><strong>渐进式哈希的精髓在于：数据的迁移不是一次性完成的，而是可以通过dictRehash()这个函数分步规划的，并且调用方可以及时知道是否需要继续进行渐进式哈希操作。如果dict数据结构中存储了海量的数据，那么一次性迁移势必带来redis性能的下降，别忘了redis是单线程模型，在实时性要求高的场景下这可能是致命的。而渐进式哈希则将这种代价可控地分摊了，调用方可以在dict做插入，删除，更新的时候执行dictRehash()，最小化数据迁移的代价。<br>在迁移的过程中，数据是在新表还是旧表中并不是一个非常急迫的需求，迁移的过程并不会丢失数据，在旧表中找不到再到新表中寻找就是了。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://blog.csdn.net/cqk0100/article/details/80400811" target="_blank" rel="noopener">渐进式rahash讲解</a></p><p>rehash过程的图解:<br><img src="http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png" alt=""><br><img src="http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png" alt=""></p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>Redis的跳跃表由zskiplistNode(跳跃表节点)与zskiplist（跳跃表头）组成<br>跳跃表性质:</p><ol><li><p>由很多层结构组成；</p></li><li><p>每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</p></li><li>最底层的链表包含了所有的元素；</li><li>如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</li><li>链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</li></ol><p><img src="https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt=""></p><p>zskiplist的结构:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点和尾节点</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">     <span class="comment">//表中节点的数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">     <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">     <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure></p><ul><li><p>header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)</p></li><li><p>tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)</p></li><li><p>level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。</p></li><li><p>length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</p></li></ul><p>跳跃表节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">     <span class="comment">//后退指针</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="keyword">double</span> sorce;</span><br><span class="line">     <span class="comment">//成员对象</span></span><br><span class="line">     robj *obj;</span><br><span class="line">     <span class="comment">//层</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">         <span class="comment">//前进指针</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">foward</span>;</span></span><br><span class="line">         <span class="comment">//跨度</span></span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">     &#125;level[];</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure></p><ul><li><p>层(level):</p><p>  每个层都带有两个属性:<strong>前进指针和跨度</strong>。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。<br>  每次<strong>创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小</strong>,这个大小就是层的“高度”。</p></li><li><p>跨度<br><strong>跨度实际是用来计算排位次序的，在查看某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位次序</strong></p></li><li><p>后退(backward)指针：<br>节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。</p></li><li><p>分值(score):<br> 各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。</p></li><li><p>成员对象(oj):<br>  各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,<strong>各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的</strong>:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p></li></ul><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><ul><li>赋值:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure></li><li>取值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure></li><li>取值并赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSET key value</span><br></pre></td></tr></table></figure></li><li>递增数字(当value为整形数据时，才可以）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure></li><li>递增数字(当value为整形数据时，才可以）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></table></figure></li><li>减少指定的整数(当value为整形数据时，才可以）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECRBY key decrement(指定整数)</span><br></pre></td></tr></table></figure></li><li>仅当不存在时赋值（使用该命令可以实现分布式锁的功能）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure></li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><p>HSET 命令不区分插入和更新操作，当执行插入操作时 HSET 命令返回1，当执行更新操作时返回0。</p><ul><li><p>一次给一个字段赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br><span class="line"></span><br><span class="line">hset user username AlanShelby</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p>一次给多个字段赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMSET key field value [field value ...]</span><br><span class="line"></span><br><span class="line">hmset user username AlanShelby password admin name AlanShelby</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>一次取一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line">hget user username</span><br><span class="line">&quot;AlanShelby&quot;</span><br></pre></td></tr></table></figure></li><li><p>一次取多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br><span class="line"></span><br><span class="line">hmget user username password</span><br><span class="line">1) &quot;AlanShelby&quot;</span><br><span class="line">2) &quot;admin&quot;</span><br></pre></td></tr></table></figure></li><li><p>一次取所有的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br><span class="line">hgetall user</span><br><span class="line">1) &quot;username&quot; (filed)</span><br><span class="line">2) &quot;AlanShelby&quot;(vaule)</span><br><span class="line">3) &quot;password&quot;(filed)</span><br><span class="line">4) &quot;admin&quot;(vaule)</span><br><span class="line">5) &quot;name&quot;</span><br><span class="line">6) &quot;AlanShelby&quot;</span><br><span class="line">7) &quot;age&quot;</span><br><span class="line">8) &quot;24&quot;</span><br></pre></td></tr></table></figure></li><li><p>删除字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br><span class="line"></span><br><span class="line">hdel user age name</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><p>增加数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br><span class="line"></span><br><span class="line">hincrby user age 2</span><br><span class="line">(integer) 26</span><br></pre></td></tr></table></figure></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li><p>向两边添加元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">向左边添加元素</span><br><span class="line">LPUSH key value [value ...]</span><br><span class="line"></span><br><span class="line">lpush nameList tom lucy jack</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">向右边添加元素</span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"></span><br><span class="line">rpush nameList alan kim joy</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></li><li><p>查看列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br><span class="line">当索引是-1时表示是最后一个元素</span><br><span class="line"></span><br><span class="line">lrange nameList 0 5</span><br><span class="line">1) &quot;jack&quot;</span><br><span class="line">2) &quot;lucy&quot;</span><br><span class="line">3) &quot;tom&quot;</span><br><span class="line">4) &quot;alan&quot;</span><br><span class="line">5) &quot;kim&quot;</span><br><span class="line">6) &quot;joy&quot;</span><br></pre></td></tr></table></figure></li><li><p>从列表两端弹出元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">左弹出LPOP key 右弹出：RPOP key</span><br><span class="line"></span><br><span class="line">lpop nameList</span><br><span class="line">&quot;jack&quot;</span><br><span class="line"></span><br><span class="line">rpop nameList</span><br><span class="line">&quot;joy&quot;</span><br></pre></td></tr></table></figure></li><li>获取列表中元素个数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br><span class="line"></span><br><span class="line">LLEN nameList</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li><p>增加元素（重复的元素是无法添加进去的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br><span class="line"></span><br><span class="line">sadd nameSet tom bob ben lucy</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></li><li><p>删除元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br><span class="line"></span><br><span class="line">srem nameSet tom lucy</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><p>获取集合中的所有元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br><span class="line"></span><br><span class="line">smembers nameSet</span><br><span class="line">1) &quot;ben&quot;</span><br><span class="line">2) &quot;bob&quot;</span><br></pre></td></tr></table></figure></li><li><p>判断元素是否在集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br><span class="line"></span><br><span class="line">sismember nameSet bob</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p>集合运算命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">集合的差集运算 A-B</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd setA 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd setB 2 3 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sdiff setA setB</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff setB setA</span><br><span class="line">1) &quot;4&quot;</span><br><span class="line"></span><br><span class="line">集合的交集运算 A ∩ B</span><br><span class="line"></span><br><span class="line">语法：SINTER key [key ...]</span><br><span class="line">127.0.0.1:6379&gt; sinter setA setB</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line"></span><br><span class="line">集合的并集运算 A ∪ B</span><br><span class="line"></span><br><span class="line">语法：SUNION key [key ...]</span><br><span class="line">127.0.0.1:6379&gt; sunion setA setB</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><ul><li><p>增加元素<br>增加元素向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：ZADD key score member [score member ...]</span><br><span class="line">127.0.0.1:6379&gt; zadd scoreSet 80 tom 90 lucy 89 alan 97 jack</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zadd scoreSet 94 lucy</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li><li><p>获取排名在某个范围的元素列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">按照元素分数从小到大的顺序返回索引从 start 到 stop 之间的所有元素:</span><br><span class="line"></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">127.0.0.1:6379&gt; zrange scoreSet 0 2</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;alan&quot;</span><br><span class="line">3) &quot;lucy&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange scoreSet 0 2 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;80&quot;</span><br><span class="line">3) &quot;alan&quot;</span><br><span class="line">4) &quot;89&quot;</span><br><span class="line">5) &quot;lucy&quot;</span><br><span class="line">6) &quot;94&quot;</span><br><span class="line"></span><br><span class="line">按照元素分数从大到小的顺序返回索引从 start 到 stop 之间的所有元素（包含两端的元素）</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrevrange scoreSet 0 2</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;alan&quot;</span><br><span class="line">3) &quot;lucy&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange scoreSet 0 2 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;80&quot;</span><br><span class="line">3) &quot;alan&quot;</span><br><span class="line">4) &quot;89&quot;</span><br><span class="line">5) &quot;lucy&quot;</span><br><span class="line">6) &quot;94&quot;</span><br><span class="line"></span><br><span class="line">注意：如果需要获得元素的分数的可以在命令尾部加上 WITHSCORES 参数</span><br></pre></td></tr></table></figure></li><li>获取元素的分数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br><span class="line">127.0.0.1:6379&gt; zscore scoreSet jack</span><br><span class="line">&quot;97&quot;</span><br></pre></td></tr></table></figure></li><li><p>删除元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem scoreSet tom jack</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange scoreSet 0 1</span><br><span class="line">1) &quot;alan&quot;</span><br><span class="line">2) &quot;lucy&quot;</span><br></pre></td></tr></table></figure></li><li><p>Keys 命令用于查找所有符合给定模式 pattern 的 key </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET w3c1 redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; SET w3c2 mysql</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; SET w3c3 mongodb</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; KEYS w3c*</span><br><span class="line">1) &quot;w3c3&quot;</span><br><span class="line">2) &quot;w3c1&quot;</span><br><span class="line">3) &quot;w3c2&quot;</span><br><span class="line"></span><br><span class="line">获取 redis 中所有的 key 可用使用 *</span><br><span class="line">redis 127.0.0.1:6379&gt; KEYS *</span><br><span class="line">1) &quot;w3c3&quot;</span><br><span class="line">2) &quot;w3c1&quot;</span><br><span class="line">3) &quot;w3c2&quot;</span><br></pre></td></tr></table></figure></li><li>SCAN指令<br>当<strong>redis中key数量越大，keys 命令执行越慢，而且最重要的会阻塞服务器</strong></li><li>SCAN 命令用于迭代当前数据库中的数据库键。</li><li>SSCAN 命令用于迭代集合键中的元素。</li><li>HSCAN 命令用于迭代哈希键中的键值对。</li><li>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以用count 参数指定返回数据量：</span><br><span class="line">127.0.0.1:6379&gt; scan 0 count 1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) 1) &quot;w3c3&quot;</span><br><span class="line"></span><br><span class="line">可以用match参数来匹配模式</span><br><span class="line">127.0.0.1:6379&gt; scan 0 match w3c*</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;w3c3&quot;</span><br><span class="line">   2) &quot;w3c2&quot;</span><br><span class="line">   3) &quot;w3c1&quot;</span><br></pre></td></tr></table></figure>优点:</li></ul><ol><li>不会阻塞服务器</li></ol><p>缺点:</p><ol><li>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回</li><li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责</li></ol><p><a href="http://doc.redisfans.com/key/scan.html#scan" target="_blank" rel="noopener">scan指令详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h1&gt;&lt;p&gt;Redis 有 5 种基础数据结构，它们分别是：&lt;strong&gt;string、list、字典、压缩列表和跳跃表&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://sqwyyy.github.io/categories/redis/"/>
    
    
      <category term="redis基础使用" scheme="https://sqwyyy.github.io/tags/redis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/JVM/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/JVM/</id>
    <published>2020-05-25T13:26:15.000Z</published>
    <updated>2020-05-25T13:31:20.661Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下都是以hotspot虚拟机为准</strong></p><h1 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h1><p>Java虚拟机在执行java程序的过程中会把它所管理的内存划分为几个不同的数据区域，分别是<br><strong>程序计数器，java虚拟机栈，本地方法栈，堆，方法区</strong>。</p><a id="more"></a><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，<strong>为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储</strong>。</p><p><strong>如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空</strong>。这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。</p><h2 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h2><p><strong>每个方法被执行的时候都会创建一个栈帧</strong>用于存储<strong>局部变量表，操作栈，动态链接，方法出口</strong>等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><a href="https://www.cnblogs.com/noKing/p/8167700.html" target="_blank" rel="noopener">局部变量等详解</a></p><ul><li>局部变量表（内存）<ul><li>存放方法参数和局部变量，必须显式初始化</li><li>若是非静态方法，在index[0]位置上存储方法所属对象的实例引用（占4字节），随后存储参数和局部变量</li><li>字节码中STORE指令：将操作栈中计算完成的布局变量写回局部变量表</li><li>操作栈</li><li>动态链接<ul><li>每个栈帧中包含一个在常量池中对当前方法的引用</li></ul></li><li>方法返回地址 </li></ul></li></ul><p>出现的异常:</p><ol><li>线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。</li><li>虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。</li></ol><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++</p><p>出现的异常与java虚拟机栈的异常相同</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的时存放对象实例</strong>。同时它也是GC所管理的主要区域，因此常被称为GC堆，又由于现在收集器常使用分代算法，Java堆中还可以细分为新生代和老年代。</p><p>出现的异常:</p><ol><li>如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误</li></ol><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。<strong>用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中</strong>。<br>出现的异常:</p><ol><li>当方法区无法满足新的内存分配需求时,将抛出OOM异常</li></ol><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池时方法去的一部分</strong>，用于<strong>存放编译期间生成的各种字面量和符号引用</strong></p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象在内存中存储的布局：<strong>1.对象头 2.实例数据 3.对齐填充</strong></p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头主要存储两类信息，第一类时用于存储对象自身的运行时数据，<strong>如哈希码，GC分代年龄，锁的状态标志，线程持有的锁，偏向线程ID，偏向时间戳</strong><br>第二类则是<strong>类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象时哪个类的实例</strong>。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。<br>分配策略:相同宽度的字段总是放在一起，比如double和long</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。并不是必然存在的。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>java程序需要<strong>通过引用(ref)数据来操作堆上面的对象</strong>，主要有两种方式:</p><ol><li>句柄访问对象</li><li>直接指针访问对象<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3>java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3>reference中存储的就是对象实例数据与类型数据各自具体的地址信息。</li></ol><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h2><p>Java堆是GC回收的“重点区域”。堆中基本存放着所有对象实例，gc进行回收前，第一件事就是确认哪些对象存活，哪些死去[即不可能再被引用]</p><p>为了高效的回收，jvm将堆分为三个区域</p><ol><li>新生代（Young Generation）NewSize和MaxNewSize分别可以控制年轻代的初始大小和最大的大小</li><li>老年代（Old Generation）</li></ol><p>可作为GC Roots的对象有四种:</p><ul><li>虚拟机栈(栈桢中的本地变量表)中的引用的对象，就是平时所指的java对象，存放在堆中。</li><li>方法区中的类静态属性引用的对象，一般指被static修饰引用的对象，加载类的时候就加载到内存中。</li><li>方法区中的常量引用的对象,</li><li>本地方法栈中JNI（native方法)引用的对象</li></ul><hr><ul><li>部分收集(Partial GC):指目标不是完整收集整个java堆的垃圾收集，其中又分为:<ul><li>新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集</li><li>老年代收集(Major GC/old GC):指目标只是老年代的垃圾收集（目前只有CMS收集器会单独收集老年代）</li><li>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。(目前只有G1收集器会有这样的行为</li></ul></li><li>整堆收集:收集整个java堆和方法区的垃圾收集</li><li><p>major gc有可能是指老年代收集也有可能是指整堆收集</p></li><li><p>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</p></li><li>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC</li></ul><h2 id="什么时候回收内存"><a href="#什么时候回收内存" class="headerlink" title="什么时候回收内存"></a>什么时候回收内存</h2><ol><li><p>在程序空闲时。</p></li><li><p>程序不可预知的时候/手动调用 System.gc() 。不要手动调用GC，不管是 JVM 自己调用还是手动调用都会使系统陷入短暂的停顿，给垃圾回收让路，手动调用就违背了我们优化 GC 的初衷了</p></li><li><p>堆内存不足时 GC 会被调用。当应用线程在运行，并在运行过程中穿件对象，若这时内存空间不足，JVM就会强制的调用 GC ，一遍回收内存用于新的分配。若GC 一次之后仍不满足内存分配的要求，JVM会再次进行两次 GC 做进一步尝试，若还是不满足需求则会抛出 “out of memort” 的错误使应用异常停止</p></li></ol><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><ul><li><p>引用计数算法<br>早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。<br>优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。<br>缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。</p></li><li><p>可达性分析算法<br>目前主流的商用语言[如java、c#]采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。<br>它的基本思路是<strong>通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的</strong>。</p></li></ul><p><strong>上述两种算法都要依据引用来实现</strong></p><p>对象的引用分为四种:</p><ul><li><p>强引用<br>如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello"</span>;    <span class="comment">// 强引用</span></span><br><span class="line">str = <span class="keyword">null</span>;              <span class="comment">// 取消强引用</span></span><br></pre></td></tr></table></figure></li><li><p>软引用<br>在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收；只有在内存空间不足时，软引用才会被垃圾回收器回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softName = <span class="keyword">new</span>  SoftReference&lt;&gt;(<span class="string">"张三"</span>);</span><br></pre></td></tr></table></figure></li><li><p>弱引用<br>当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; weakName = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p>虚引用<br>如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收<br>虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;String&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"hello"</span>), queue);</span><br></pre></td></tr></table></figure></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ol><li>标记/清除算法</li><li>复制算法</li><li>标记/整理算法<h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记/清除"></a>标记/清除</h3><strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</strong></li></ol><p>缺点:</p><ol><li><strong>效率低</strong>,标记和清除两个阶段的效率都不高，因为这两个阶段都需要遍历内存中的对象，很多时候内存中的对象实例数量是非常庞大的，这无疑很耗费时间，而且GC时需要停止应用程序，这会导致非常差的用户体验。</li><li><strong>清除之后会产生大量的空间碎片</strong>，内存空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><strong>将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把这一块内存所有的对象一次性清理掉</strong>。</p><p>优点: 优化了标记/清除算法的效率低、内存碎片多的问题<br>缺点:</p><ol><li>将内存缩小为原来的一半，浪费了一半的内存空间。</li><li>如果对象的存活率很高，极端一点的情况假设对象存活率为100%，那么我们需要将所有存活的对象复制一遍</li></ol><p>由于新生代中的对象几乎都是“朝生夕死”的（达到98%），现在的商业虚拟机都采用复制算法来回收新生代。由于新生代的对象存活率低，所以并不需要按照1：1的比例来划分内存空间，而是将<strong>内存分为一块较大的Eden空间和两块较小的From Survivor空间、To Survivor空间，三者的比例为8:1:1</strong>.每次使用Eden和From Survivor区域，To Survivor作为保留空间。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的。GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着， From Survivor区和To Survivor区会交换它们的角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区</p><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记/整理"></a>标记/整理</h3><p>首先标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边线以外的内存。</p><p>优点：回收后可回收对象被清理掉了，存活的对象按规则排列存放在内存中。<br>缺点：效率也不高，不仅要标记存活对象，还要整理所有存活对象的引用地址</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法的思想是<strong>按对象的存活周期不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法</strong>。</p><p> 新生代：朝生夕灭，存活时间很短。</p><p> 老年代：经过多次Minor GC而存活下来，存活周期长。</p><ul><li>在新生代中每次垃圾回收都发现有大量的对象死去，只有少量存活，因此采用<strong>复制算法回收新生代</strong>，只需要付出少量对象的复制成本就可以完成收集；</li><li>老年代中对象的存活率高，不适合采用复制算法，而且如果老年代采用复制算法，它是没有额外的空间进行分配担保的，因此必须使用<strong>标记/清理算法或者标记/整理算法</strong>来进行回收。</li></ul><h3 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h3><p>对传统的、基本的GC实现来说，由于它们<strong>在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情</strong>。如果说<strong>收集整个GC堆耗时太长，那不如只收集其中的一部分</strong>？于是就有好几种不同的划分（partition）GC堆的方式来实现部分收集，而分代式GC就是这其中的一个思路。</p><p><a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="noopener">分代的解析</a></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul><li>年轻代收集器 Serial、ParNew、Parallel Scavenge</li><li>老年代收集器 Serial Old、Parallel Old、CMS收集器</li><li>特殊收集器 G1收集器[新型，不在年轻、老年代范畴内]</li></ul><h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2><p>Serial是单线程收集器，Serial收集器只能使用一条线程进行收集工作，在收集的时候必须得停掉其它线程，<strong>采用复制算法</strong>，等待收集工作完成其它线程才可以继续工作。</p><h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><p>可以认为是Serial的升级版，因为它支持多线程[GC线程]，而且收集算法、Stop The World、回收策略和Serial一样，就是可以有多个GC线程并发运行</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS<strong>采用的是”标记-清除”算法，而且是支持并发</strong><br>它的运作分为4个阶段:</p><ul><li>初始标记:标记一下GC Roots能直接关联到的对象，速度很快</li><li>并发标记:GC Roots Tarcing过程，即可达性分析</li><li>重新标记:为了修正因并发标记期间用户程序运作而产生变动的那一部分对象的标记记录，会有些许停顿，时间上一般 初始标记 &lt; 重新标记 &lt; 并发标记</li><li>并发清除</li></ul><p>以上<strong>初始标记和重新标记</strong>需要停掉其他运行的线程</p><p>优点:CMS收集器的内存回收工作是可以和用户线程一起并发执行。<br>缺点:</p><ul><li>cpu敏感</li><li>无法处理浮动垃圾</li><li>由于使用的标记-清除算法会产生垃圾碎片</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1的特别之处在于<strong>它强化了分区，弱化了分代的概念，是区域化、增量式的收集器，它不属于新生代也不属于老年代收集器，用到的算法为标记-清理、复制算法</strong>。<br>G1是区域化的，它将java堆内存划分为若干个大小相同的区域。<br>G1提供三种垃圾回收模式 young gc、mixed gc 和 full gc,不像其它的收集器，根据区域而不是分代，新生代老年代的对象它都能回收<br>它的运作分为4个阶段:</p><ul><li><p>初始标记:标记一下GC Roots能直接关联到的对象，速度很快</p></li><li><p>并发标记:GC Roots Tarcing过程，即可达性分析</p></li><li>最终标记:</li><li>筛选回收</li></ul><p>以上<strong>初始标记和最终标记和筛选回收</strong>需要停掉其他运行的线程<br><a href="https://www.jianshu.com/p/76959115d486" target="_blank" rel="noopener">深入理解JVM和GC</a></p><h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><ul><li>对象优先在Eden分配<ol><li>Eden空间不足直接触发Minor GC</li></ol></li><li><p>大对象直接进入老年代</p><ol><li>需要大量连续内存空间的 Java 对象。例如那种很长的字符串或者数组。</li><li>防止新生代复制大对象消耗资源</li></ol></li><li>长期存活对象进入老年代<ol><li>固定对象年龄判定： 虚拟机给每个对象定义一个年龄计数器，对象每在 Survivor 中熬过一次 Minor GC，年龄 +1，达到 -XX:MaxTenuringThreshold 设定值后，会被晋升到老年代，-XX:MaxTenuringThreshold 默认为 15；</li><li>动态对象年龄判定： Survivor 中有相同年龄的对象的空间总和大于 Survivor 空间的一半，那么，年龄大于或等于该年龄的对象直接晋升到老年代。</li></ol><ul><li>空间分配担保<ol><li>如果Eden中所有新生代对象都要存活，但剩下的一个Survivor空间明显不够，就要老年代空间来进行担保</li><li>如果老年代空间不够，尝试进行Full GC</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;以下都是以hotspot虚拟机为准&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;JVM分区&quot;&gt;&lt;a href=&quot;#JVM分区&quot; class=&quot;headerlink&quot; title=&quot;JVM分区&quot;&gt;&lt;/a&gt;JVM分区&lt;/h1&gt;&lt;p&gt;Java虚拟机在执行java程序的过程中会把它所管理的内存划分为几个不同的数据区域，分别是&lt;br&gt;&lt;strong&gt;程序计数器，java虚拟机栈，本地方法栈，堆，方法区&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA虚拟机" scheme="https://sqwyyy.github.io/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://sqwyyy.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JMM</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/JMM/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/JMM/</id>
    <published>2020-05-25T13:23:39.000Z</published>
    <updated>2020-05-25T13:31:20.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范</strong>。</p><a id="more"></a><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p><strong>它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。可以保证并发编程场景中的原子性、可见性和有序性</strong>。</p><h1 id="JVM对Java内存模型的实现"><a href="#JVM对Java内存模型的实现" class="headerlink" title="JVM对Java内存模型的实现"></a>JVM对Java内存模型的实现</h1><p>在JVM内部，<strong>Java内存模型把内存分成了两部分：线程栈区和堆区</strong></p><p>所有原始类型(boolean,byte,short,char,int,long,float,double)的局部变量都直接保存在<strong>线程栈当中，对于它们的值各个线程之间都是独立的</strong>。</p><p>堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的局部变量，它都会被存储在堆区。</p><p>Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。</p><p><strong>Java的内存模型在并发的情况下如何处理原子性，有序性，可见性</strong></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>java内存模型保证原子性变量操作包括read，load，assign，use，store，write，lock，unlock。<strong>基本数据类型的访问，读写都是具有原子性的（除了long和double的非原子性协定）</strong></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>java内存模型时<strong>通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值</strong>这种依赖主内存作为传递媒介的方式实现可见性。</p><ul><li><p>volatile可见性的实现就是借助了CPU的lock指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则:</p><ol><li><p>写volatile时处理器会将缓存写回到主内存。</p></li><li><p>一个处理器的缓存写回到内存会导致其他处理器的缓存失效。</p></li></ol></li><li><p>锁实现可见性的原理是</p><ol><li><p>当线程<strong>释放锁</strong>时，<strong>JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</strong>。</p></li><li><p>当线程<strong>获取锁</strong>时，<strong>JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量</strong>。</p></li></ol></li><li><p>final的可见性是因为一旦初始化完成就无法修改，对于线程而言值不会改变。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span>[] Arrary   <span class="comment">//假设修饰一个数组</span></span><br><span class="line"><span class="keyword">int</span> i=Arrary[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>实际上可分解为2个子操作:</p><ol><li>读取数组引用地址，由于volatile修饰数组，这步子操作是volatile有效的，</li><li>在取到数组引用后根据下标读取具体元素,这步与volatile是无关的</li></ol><p><strong>对于引用型的对象，volatile只是能保障对象的引用，至于该引用所指向的对象实例中的值volatile无法保障</strong><br>类似于数组声明为volatile时，引用地址具有可见性，元素本身不具有可见性<br>如果要使数组内的元素也能触发volatile作用，<strong>可以使用AtomicIntegerArray</strong></p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>java语言中有一个<strong>先行发生</strong>原则来实现有序性</p><ol><li>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序是允许的(对编译器和处理器</li></ol><p>Happens-Before规则-无需任何同步手段就可以保证的</p><ol><li><p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p></li><li><p>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</p></li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li><li>线程中断规则:对线程interrupt方法的调用happens-before于被中断线程的代码检测到中断事件的发生。</li></ol><ul><li><p>volatile有序性的实现——<strong>JMM对volatile的内存屏障</strong>插入策略：</p><ol><li><p>在每个volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。</p></li><li><p>在每个volatile读操作的后面插入一个LoadLoad屏障。在每个volatile读操作的后面插入一个LoadStore屏障。</p></li></ol></li><li><p>锁有序性的实现——互斥锁:一个变量在同一时刻只允许一条线程对其进行lock操作</p></li></ul><p><strong>synchronized并没有实现禁止指令重排序</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA虚拟机" scheme="https://sqwyyy.github.io/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://sqwyyy.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数字链路层</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E6%95%B0%E5%AD%97%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E6%95%B0%E5%AD%97%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-05-25T13:21:13.000Z</published>
    <updated>2020-05-25T13:22:18.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链路层的意义"><a href="#链路层的意义" class="headerlink" title="链路层的意义"></a>链路层的意义</h1><p>物理层的线路有传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用<strong>差错检测、封装成帧和透明传输</strong>等方法，向网络层提供高质量的数据传输服务。</p><p><strong>数据链路层的最基本的功能是向上层提供透明的和可靠的数据传送基本服务</strong></p><a id="more"></a><h1 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h1><p>数据链路层使用的信道主要有两种类型：</p><ul><li>点对点信道：也就是字面意思，点对点得通信方式。</li><li>广播信道：这种信道是一对多的方式，所以整个过程也比较复杂。必须使用一些信道协议来协调网络中的主机数据发送。</li></ul><h1 id="点到点信道"><a href="#点到点信道" class="headerlink" title="点到点信道"></a>点到点信道</h1><ol><li><p>节点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。 </p></li><li><p>节点A把封装好的帧发送给节点B的数据链路层。 </p></li><li>若节点B的数据链路层收到的帧无差错，则从收到的帧当中提取出IP数据报上交给上面的网络层，否则丢弃这个帧。</li></ol><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>其实就是在帧的前后添加首部和尾部。这个时候我们就需要考虑，我们如何来识别一个帧，所以这里提出了一个帧定界的概念，使用两个控制字符，一个控制字符SOH放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT标识帧的结束</p><p>一帧多大呢？<strong>MTU就是帧的数据部分的最大长度，也就是IP数据报的最大长度</strong>。</p><h3 id="MTU-和-MSS-区别"><a href="#MTU-和-MSS-区别" class="headerlink" title="MTU 和 MSS 区别"></a>MTU 和 MSS 区别</h3><ul><li>MTU： Maximum Transmit Unit，最大传输单元，即物理接口（数据链路层）提供给其上层（通常是IP层）最大一次传输数据的大小</li><li>MSS：Maximum Segment Size ，TCP一次能够传输的数据(不包括协议头的开销)的最大值</li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>在帧的有效数据当中，可能出现和帧定界的控制字符一样的字符，为了防止将这些字符当中帧定界的字符，使用<strong>字节填充法</strong></p><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符”ESC”。而在接收端的数据链路层在将数据送往网络层之前删除这个插入的转义字符。我们把这种方法叫做字节填充法</p><h2 id="差错检错"><a href="#差错检错" class="headerlink" title="差错检错"></a>差错检错</h2><p>数据链路层点对点传输的第三个问题就是差错检测。就是我们所说的比特在传出过程当中可能会产生差错，1可能会变成0，0可能会变成1.</p><p>解决方法: CRC</p><p>CRC的基本思想就是将传输的数据当作一个位数很长的数，将这个数除以另外的一个数。得到的余数作为校验数据附加到原数据后面。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;链路层的意义&quot;&gt;&lt;a href=&quot;#链路层的意义&quot; class=&quot;headerlink&quot; title=&quot;链路层的意义&quot;&gt;&lt;/a&gt;链路层的意义&lt;/h1&gt;&lt;p&gt;物理层的线路有传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用&lt;strong&gt;差错检测、封装成帧和透明传输&lt;/strong&gt;等方法，向网络层提供高质量的数据传输服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据链路层的最基本的功能是向上层提供透明的和可靠的数据传送基本服务&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="数字链路层" scheme="https://sqwyyy.github.io/tags/%E6%95%B0%E5%AD%97%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络常见面试题</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-05-25T13:20:05.000Z</published>
    <updated>2020-05-25T13:22:18.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI，TCP-IP，五层协议的体系结构，以及各层协议"><a href="#OSI，TCP-IP，五层协议的体系结构，以及各层协议" class="headerlink" title="OSI，TCP/IP，五层协议的体系结构，以及各层协议"></a>OSI，TCP/IP，五层协议的体系结构，以及各层协议</h1><ul><li><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p></li><li><p>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。</p></li><li><p>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</p></li></ul><ol><li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）</li><li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li><li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li><li>传输层：TCP、UDP、SPX</li><li>会话层：NFS、SQL、NETBIOS、RPC</li><li>表示层：JPEG、MPEG、ASII</li><li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li></ol><a id="more"></a><h1 id="从浏览器中输入URL到页面展示到底发生了什么"><a href="#从浏览器中输入URL到页面展示到底发生了什么" class="headerlink" title="从浏览器中输入URL到页面展示到底发生了什么"></a>从浏览器中输入URL到页面展示到底发生了什么</h1><ol><li><p>浏览器获取输入的域名URL</p></li><li><p>浏览器向DNS查找域名的IP地址</p></li><li>域名系统DNS解析出域名服务器的IP地址</li><li>浏览器与该服务器建立TCP连接(默认端口号80)</li><li>浏览器发出HTTP请求，请求页面</li><li>服务器通过HTTP响应把html文件发送给浏览器</li><li>TCP连接释放</li><li>浏览器将html文件进行解析，并显示给用户。</li></ol><p><a href="https://zhuanlan.zhihu.com/p/79350395" target="_blank" rel="noopener">解析</a><br>涉及到的协议</p><ul><li><p>应用层：HTTP(WWW访问协议)，DNS(域名解析服务)</p></li><li><p>传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)</p></li><li><p>网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)</p></li></ul><h2 id="DNS查找域名的IP地址"><a href="#DNS查找域名的IP地址" class="headerlink" title="DNS查找域名的IP地址"></a>DNS查找域名的IP地址</h2><p>比如网址时www.qq.com,真正的写法应该时<strong>www.qq.com.</strong>，.代表的就是根域名服务，.com代表的就是顶级域名,.qq代表的则是次级域名</p><ol><li><p>请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会<strong>首先查看本地硬盘的 hosts 文件</strong>，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p></li><li><p>如果在本地的 hosts 文件没有能够找到对应的 ip 地址，<strong>浏览器会发出一个 DNS请求到本地DNS服务器</strong> 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p></li><li><p>查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</strong></p></li><li><p><strong>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出顶级域服务器的地址</strong>。这种过程是迭代的过程。</p></li><li><p>本地DNS服务器继续向顶级域服务器发出请求，在这个例子中，请求的对象是.com域服务器。<strong>.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的次级域名服务器的地址</strong>。</p></li><li><p>最后，<strong>本地DNS服务器向次级域名服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中</strong>，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p></li></ol><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><strong>ARP是地址解析协议</strong></p><ol><li><p>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p></li><li><p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</p></li><li><p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p></li><li><p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。</p></li></ol><h2 id="icmp协议"><a href="#icmp协议" class="headerlink" title="icmp协议"></a>icmp协议</h2><p><a href="https://blog.csdn.net/baidu_37964071/article/details/80514340" target="_blank" rel="noopener">icmp</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OSI，TCP-IP，五层协议的体系结构，以及各层协议&quot;&gt;&lt;a href=&quot;#OSI，TCP-IP，五层协议的体系结构，以及各层协议&quot; class=&quot;headerlink&quot; title=&quot;OSI，TCP/IP，五层协议的体系结构，以及各层协议&quot;&gt;&lt;/a&gt;OSI，TCP/IP，五层协议的体系结构，以及各层协议&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）&lt;/li&gt;
&lt;li&gt;数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）&lt;/li&gt;
&lt;li&gt;网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）&lt;/li&gt;
&lt;li&gt;传输层：TCP、UDP、SPX&lt;/li&gt;
&lt;li&gt;会话层：NFS、SQL、NETBIOS、RPC&lt;/li&gt;
&lt;li&gt;表示层：JPEG、MPEG、ASII&lt;/li&gt;
&lt;li&gt;应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp与udp</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/tcp%E4%B8%8Eudp/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/tcp%E4%B8%8Eudp/</id>
    <published>2020-05-25T13:16:29.000Z</published>
    <updated>2020-05-25T13:22:18.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h1><p><img src="https://img-blog.csdn.net/20140609125220296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><a id="more"></a><ul><li>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</li><li>序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li><li>确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li><li>数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li><li>保留，占6位，保留今后使用，但目前应都位0；</li><li>标志位 SYN ACK PSH FIN RST URG(</li><li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；<br>检验和，占2字节，校验首部和数据这两部分；<br>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；<br>选项，长度可变，定义一些其他的可选的参数。</li></ul><p><a href="https://www.jianshu.com/p/e0b8a66cf875" target="_blank" rel="noopener">来源</a></p><ol><li>TCP的6种标志位和2种序号</li><li>SYN(synchronous) :建立连接，请求同步标志，为1的时候为有效</li><li>ACK(acknowledgement 确认) :应答标志，表示接受到所发的数据，1为有效</li><li>PSH(push传送) ：接收方应该尽快把这个报文交给应用层</li><li>FIN(finish结束) :释放一个连接</li><li>RST(reset) ：重置连接</li><li>URG(urgent紧急)：紧急指针有效</li></ol><p>顺序序号（sequence number）：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>确认序号（acknowledge number）：ack序号，占32位，只有标志位ACK为1时，确认序号字段才有效，Ack=Seq+1。</p><h1 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h1><ul><li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p></li><li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p></li><li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p> 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ul><h1 id="为什么连接时不能两次握手或者时四次握手"><a href="#为什么连接时不能两次握手或者时四次握手" class="headerlink" title="为什么连接时不能两次握手或者时四次握手"></a>为什么连接时不能两次握手或者时四次握手</h1><h2 id="为什么要进行三次握手"><a href="#为什么要进行三次握手" class="headerlink" title="为什么要进行三次握手"></a>为什么要进行三次握手</h2><p><strong>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</strong></p><p>第一次握手：客户端发送网络包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。</p><p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><h2 id="如果是用两次握手，则会出现下面这种情况"><a href="#如果是用两次握手，则会出现下面这种情况" class="headerlink" title="如果是用两次握手，则会出现下面这种情况:"></a>如果是用两次握手，则会出现下面这种情况:</h2><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p><h2 id="假设可以四次握手"><a href="#假设可以四次握手" class="headerlink" title="假设可以四次握手:"></a>假设可以四次握手:</h2><ol><li><p>A 发送同步信号SYN + A的初始化序列号</p></li><li><p>B 确认收到A的同步信号并且记录A的初始化序列号 (ack报文)</p></li><li>B 发送同步信号SYN + B的初始化序列号 (seq报文)</li><li>A 确认收到B的同步信号并且记录B的初始化序列号</li></ol><p>由以上可得2.3步骤可以合并，只需要三次握手，可以提高连接的速度与效率</p><h1 id="如果中途有包丢失"><a href="#如果中途有包丢失" class="headerlink" title="如果中途有包丢失"></a>如果中途有包丢失</h1><ul><li><p>第一个包，即A发给B的SYN 中途被丢，没有到达B</p><p>A会周期性超时重传，直到收到B的确认</p></li><li><p>第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A</p><p>B会周期性超时重传，直到收到A的确认</p></li><li><p>第三个包，即A发给B的ACK 中途被丢，没有到达B</p><p>A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：</p></li></ul><ol><li><p>假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。</p></li><li><p>假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。</p></li><li><p>假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</p></li></ol><p><a href="https://www.zhihu.com/question/24853633/answer/115173386" target="_blank" rel="noopener">来源</a></p><h1 id="三次握手过程中可以携带数据吗"><a href="#三次握手过程中可以携带数据吗" class="headerlink" title="三次握手过程中可以携带数据吗"></a>三次握手过程中可以携带数据吗</h1><p>其实<strong>第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据</strong></p><p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h1 id="ISN-Initial-Sequence-Number-是固定的吗"><a href="#ISN-Initial-Sequence-Number-是固定的吗" class="headerlink" title="ISN(Initial Sequence Number)是固定的吗"></a>ISN(Initial Sequence Number)是固定的吗</h1><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p><p>三次握手的其中一个重要功能是<strong>客户端和服务端交换 ISN(Initial Sequence Number),以便让对方知道接下来接收数据的时候如何按序列号组装数据</strong>.如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><h1 id="什么是半连接队列"><a href="#什么是半连接队列" class="headerlink" title="什么是半连接队列"></a>什么是半连接队列</h1><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p><p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于SYN-ACK 重传次数的问题：</p><p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><h1 id="SYN攻击是什么"><a href="#SYN攻击是什么" class="headerlink" title="SYN攻击是什么"></a>SYN攻击是什么</h1><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。<strong>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪</strong>。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h1 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h1><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p><p> 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p></li><li><p>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p><p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），<strong>服务端进入CLOSE_WAIT（关闭等待）状态</strong>，此时的TCP处于半关闭状态，客户端到服务端的连接释放。<strong>客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态</strong>，等待服务端发出的连接释放报文段。</p></li><li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><p> 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p></li></ul><h1 id="为什么连接的时候是三次握手，关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手</h1><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h1 id="服务器出现大量的CLOSE-WAIT"><a href="#服务器出现大量的CLOSE-WAIT" class="headerlink" title="服务器出现大量的CLOSE_WAIT"></a>服务器出现大量的CLOSE_WAIT</h1><p><strong>close wait绝大多数情况下是因为是客户端异常断了，服务端处理逻辑又不够好。服务器没有及时close()的缘故(比如捕捉的异常里面没有调close())</strong><br>解决方法:</p><ol><li><p>检查代码，释放资源的代码；</p></li><li><p>检查配置，处理请求的线程配置；</p></li><li><p>通过检查CLOSE_WAIT数目：<br>netstat  -n | awk ‘/ tcp/{++S[$NF]}END{for(a in S ) print a,S[a]}’</p></li></ol><h1 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态</h1><ol><li><p>确定有足够时间让对方收到ack包。为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。</p></li><li><p>避免新旧连接混淆。就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</p></li></ol><h1 id="TIME-WAIT过多"><a href="#TIME-WAIT过多" class="headerlink" title="TIME_WAIT过多"></a>TIME_WAIT过多</h1><p><strong>出现大量tcp连接关闭</strong></p><p>打开 sysctl.conf 文件，修改以下几个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line">net.ipv4.tcp_timestamps &#x3D; 1</span><br></pre></td></tr></table></figure><br><a href="https://zhuanlan.zhihu.com/p/40013724" target="_blank" rel="noopener">TIME_WAIT修改的原因</a></p><h1 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h1><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><a href="https://zhuanlan.zhihu.com/p/86426969" target="_blank" rel="noopener">三次握手与四次挥手</a></p><h1 id="TCP如何保证传输可靠性"><a href="#TCP如何保证传输可靠性" class="headerlink" title="TCP如何保证传输可靠性"></a>TCP如何保证传输可靠性</h1><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。<strong>并且前面的进位不能丢弃，补在后面，最后取反</strong>，得到校验和。<br>发送方:在发送数据之前计算检验和，并进行校验和的填充。<br>接收方:收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p><p>a数据段 1100 1010 0111 0111<br>b数据段 1001 1000 1010 1110<br>相加   1 0110 0011 0001 1111<br>      将多余的进位1加在后面<br>得到   0110 0011 0010 0000<br>       取反<br>校验和  1001 1100 1101 1111 </p><p>注意:如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是<strong>如果接收方比对校验和与发送方一致，数据不一定传输成功。</strong></p><h2 id="确认应答与序列号"><a href="#确认应答与序列号" class="headerlink" title="确认应答与序列号"></a>确认应答与序列号</h2><p>序列号:     TCP传输时<strong>将每个字节的数据都进行了编号</strong>，这就是序列号。<br>确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。<strong>这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发</strong>。</p><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。<strong>如果发送方发送完数据后，迟迟没有等到接收方的ACK报文</strong>，可能的原因有:</p><ol><li>数据在传输过程中由于网络原因等直接全体丢包，接收方没有接收到。</li><li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。<br>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制</strong>简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。<strong>如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答</strong>。</li></ol><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>三次握手和四次挥手</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传之类。<strong>而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制</strong>。<br>流量控制由<strong>滑动窗口协议</strong>（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。<strong>主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送</strong>。</p><h3 id="流量控制引发的死锁？怎么避免死锁的发生？"><a href="#流量控制引发的死锁？怎么避免死锁的发生？" class="headerlink" title="流量控制引发的死锁？怎么避免死锁的发生？"></a>流量控制引发的死锁？怎么避免死锁的发生？</h3><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。<br>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>TCP传输的过程中，发送端开始发送数据的时候，<strong>如果刚开始就发送大量的数据，那么就可能造成一些问题</strong>。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><p><strong>拥塞控制主要是四个算法：1）慢开始，2）拥塞避免，3）拥塞发生，4）快速恢复</strong></p><h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。<br>比如一开始为1 第二次就为2 第三次4… 达到ssthresh门限.<br>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：</p><ol><li>当cwnd&lt;ssthresh时，使用<strong>慢开始算法</strong>。</li><li>当cwnd&gt;ssthresh时，改用<strong>拥塞避免算法</strong>。</li><li>当cwnd=ssthresh时，<strong>慢开始与拥塞避免算法任意</strong></li></ol><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1.</p><p><strong>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法</strong></p><h3 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h3><p>快重传要求<strong>接收方在收到一个失序的报文段后就立即发出重复确认</strong>，快重传算法规定，发送方<strong>只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</strong>，而不必继续等待设置的重传计时器时间到期</p><h3 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h3><p>当发送方连续收到三个重复确认时，<strong>把ssthresh门限减半，cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大</strong>。不使用慢开始是因为考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。</p><p><a href="https://zhuanlan.zhihu.com/p/37379780" target="_blank" rel="noopener">来源</a><br><a href="https://blog.csdn.net/cbjcry/article/details/84925028" target="_blank" rel="noopener">来源</a></p><h1 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h1><p>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</p><p>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</p><h1 id="tcp和udp区别"><a href="#tcp和udp区别" class="headerlink" title="tcp和udp区别"></a>tcp和udp区别</h1><ol><li>TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>TCP首部开销20字节，UDP的首部开销小，只有8个字节。</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</li></ol><h1 id="一台主机上最多保持多少个连接"><a href="#一台主机上最多保持多少个连接" class="headerlink" title="一台主机上最多保持多少个连接"></a>一台主机上最多保持多少个连接</h1><ul><li><strong>内核通过四元组（源IP，源PORT，目标IP，目标PORT）来识别TCP连接</strong>，在一台主机上，只要这个四元组不重复，限制连接个数的就是系统配置（各种最大xx数）及系统资源（主要是内存）</li><li>客户端每次发起一个TCP连接时,系统会随机选取一个空闲的端口,该端口是独占的不能与其他TCP连接共享,因此理论上一台机器有多少空闲的端口,就能对外发起多少个TCP连接。根据TCP/IP协议,<strong>端口port使用16位无符号整数unsigned short来存储,因此本地端口一共有2^16=65536</strong>个,即0-65535,其中0~1023是预留端口,0有特殊含义不能使用,1024以下端口都是超级管理员用户(如root)才可以使用,因此就算使用root权限,一台机器最多能使用的端口也只有65535个<br>-（这个结论有问题占用的应该是服务端的文件描述符）<br><a href="https://www.jianshu.com/p/c77e7026531a" target="_blank" rel="noopener">可以linux中实验一下</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP报文格式&quot;&gt;&lt;a href=&quot;#TCP报文格式&quot; class=&quot;headerlink&quot; title=&quot;TCP报文格式&quot;&gt;&lt;/a&gt;TCP报文格式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20140609125220296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="tcp&amp;udp" scheme="https://sqwyyy.github.io/tags/tcp-udp/"/>
    
  </entry>
  
  <entry>
    <title>http与https</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/http%E4%B8%8Ehttps/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/http%E4%B8%8Ehttps/</id>
    <published>2020-05-25T13:15:16.000Z</published>
    <updated>2020-05-25T13:22:18.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>HTTP 是<strong>超文本传输协议</strong>，也就是HyperText Transfer Protocol。<br><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</strong></p><a id="more"></a><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li>http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接。</li><li>无状态：无状态是指协议对于事务处理没有记忆，不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。。</li></ol><h1 id="http的请求构成与响应构成"><a href="#http的请求构成与响应构成" class="headerlink" title="http的请求构成与响应构成"></a>http的请求构成与响应构成</h1><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>客户端发送一个HTTP请求到服务端的格式：</p><ol><li>请求行</li><li>请求头</li><li>请求体</li></ol><p>下面是一个请求的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET&#x2F;sample.jspHTTP&#x2F;1.1</span><br><span class="line">Accept:image&#x2F;gif.image&#x2F;jpeg,*&#x2F;*</span><br><span class="line">Accept-Language:zh-cn</span><br><span class="line">Connection:Keep-Alive</span><br><span class="line">Host:localhost</span><br><span class="line">User-Agent:Mozila&#x2F;4.0(compatible;MSIE5.01;Window NT5.0)</span><br><span class="line">Accept-Encoding:gzip,deflate</span><br><span class="line"></span><br><span class="line">username&#x3D;jinqiao&amp;password&#x3D;1234</span><br></pre></td></tr></table></figure></p><ol><li>以上请求中“GET”代表请求方法，“/sample.jsp”表示URI，“HTTP/1.1代表协议和协议的版本。</li><li>Accept 可接受的内容类型<br>Accept-Language 语言<br>Connection连接状态<br>Host 请求的域名（这里我设置的是请求本地，当然，关于域名，就是所谓的URL）<br>User-Agent 浏览器端浏览器型号和版本<br>Accept-Encoding 可接受的压缩类型 gzip,deflate</li><li>请求头和请求正文之间是一个空行，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：username=jinqiao&amp;password=1234<br><img src="https://pic1.zhimg.com/v2-054ba2c979cd2792840d99a1d0f4dc1c_b.jpg" alt="http请求"></li></ol><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>服务端发送一个HTTP响应到客户端的格式：</p><ol><li>状态行</li><li>响应头</li><li>响应正文</li></ol><p>状态行由<strong>协议版本、数字形式的状态代码、及相应的状态描述</strong>，各元素之间以<strong>空格分隔</strong><br><img src="https://pic2.zhimg.com/v2-e2447b28c4e1fd60d43bfa3976ff1531_b.jpg" alt="http响应报文"></p><h2 id="响应头-请求头可能包含："><a href="#响应头-请求头可能包含：" class="headerlink" title="响应头/请求头可能包含："></a>响应头/请求头可能包含：</h2><p>Location：响应报头域用于重定向接受者到一个新的位置。</p><p>Server：响应报头域包含了服务器用来处理请求的软件信息。它和User-Agent请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户 端软件(浏览器)和操作系统的信息。</p><p>Content-Encoding：实体报头域被使用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容编码，因而要获得Content- Type报头域中所引用的媒体类型，必须采用相应的解码机制。</p><p>Content-Language：实体报头域描述了资源所用的自然语言。Content-Language允许用户遵照自身的首选语言来识别和区分实体。 </p><p>Content-Length：实体报头域用于指明正文的长度，以字节方式存储的十进制数字来表示，也就是一个数字字符占一个字节，用其对应的ASCII码存储传输。<br>这个长度仅仅是表示实体正文的长度，没有包括实体报头的长度。</p><p>Content-Type：实体报头域用语指明发送给接收者的实体正文的媒体类型。</p><p>Last-Modified：实体报头域用于指示资源最后的修改日期及时间。</p><p>Expires：实体报头域给出响应过期的日期和时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line"></span><br><span class="line">Server:Apache Tomcat&#x2F;5.0.12</span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br></pre></td></tr></table></figure><h1 id="HTTP-常见的状态码"><a href="#HTTP-常见的状态码" class="headerlink" title="HTTP 常见的状态码"></a>HTTP 常见的状态码</h1><p>五大类常见http状态码</p><div class="table-container"><table><thead><tr><th></th><th>具体含义</th><th>常见状态码</th></tr></thead><tbody><tr><td>1xx</td><td>提示信息，表示目前是协议处理的中间状态，还需要后续操作；</td><td></td></tr><tr><td>2xx</td><td>成功，报文已经收到并被正确处理</td><td>200 204</td></tr><tr><td>3xx</td><td>重定向,资源位置发生变动，需要客户端重新发送请求</td><td>301 302 304</td></tr><tr><td>4xx</td><td>客服端错误，请求报文有误，服务器无法处理</td><td>400 403 404</td></tr><tr><td>5xx</td><td>服务器错误，服务器在处理请求时内部发生了错误</td><td>500 501 502 503</td></tr></tbody></table></div><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p><ol><li>200 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</li><li>204 请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li></ol><h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p><ol><li><p>302 该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问</p></li><li><p>303 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</p></li></ol><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p><ol><li><p>「400 Bad Request」表示客户端请求的报文有错误。</p></li><li><p>「403 Forbidden」表示请求被拒绝。</p></li><li><p>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li></ol><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p><p>1.「500 Internal Server Error」服务器正在执行请求时发生错误。</p><p>2.「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p><p>3.「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</p><h2 id="常见问题以及解决方法"><a href="#常见问题以及解决方法" class="headerlink" title="常见问题以及解决方法"></a>常见问题以及解决方法</h2><h3 id="404：（Not-Found）服务器无法找到请求的页面或资源。"><a href="#404：（Not-Found）服务器无法找到请求的页面或资源。" class="headerlink" title="404：（Not Found）服务器无法找到请求的页面或资源。"></a>404：（Not Found）服务器无法找到请求的页面或资源。</h3><ol><li>此类报错首先考虑我们的接口写的时候正确。（可以借用postman来测试）</li><li>其次可以检查资源的路径是否出错。</li></ol><h3 id="405：（Method-Not-Allowed-）方法不允许，方法禁用。"><a href="#405：（Method-Not-Allowed-）方法不允许，方法禁用。" class="headerlink" title="405：（Method Not Allowed ）方法不允许，方法禁用。"></a>405：（Method Not Allowed ）方法不允许，方法禁用。</h3><ol><li>一般出现在servlet中比较常见.就是自己的service函数写错了。</li><li>方法名称写错，方法参数类型与标准不一致。</li></ol><h3 id="500-：（Internal-Server-Error）-服务器内部错误，不能完成客户的请求。"><a href="#500-：（Internal-Server-Error）-服务器内部错误，不能完成客户的请求。" class="headerlink" title="500 ：（Internal Server Error） 服务器内部错误，不能完成客户的请求。"></a>500 ：（Internal Server Error） 服务器内部错误，不能完成客户的请求。</h3><ol><li>500报错一般是后端服务器问题，但也不排除前端出错，例如后台报序列化错误，可能是因为前端没有设置content-Type=application/json。</li><li>重要的是要查看自己写的后端业务逻辑代码有没有问题，根据报错提示查找bug。</li><li>常见的错误位置：NullPointException，据库中提取的数据没有提取到而给另一个对象，传递了空值或注入某个对象，过程中出现空值.，没有正确获取到对象的而出现异常。</li></ol><h3 id="501：（-Not-Implemented）尚未实施，或请求格式错误。"><a href="#501：（-Not-Implemented）尚未实施，或请求格式错误。" class="headerlink" title="501：（ Not Implemented）尚未实施，或请求格式错误。"></a>501：（ Not Implemented）尚未实施，或请求格式错误。</h3><ol><li>一般考虑我们前端写的ajax中的type:”post/get”是否出错或者from表单中的method:”post/get”是否书写错误。<h1 id="HTTP的8中请求方式"><a href="#HTTP的8中请求方式" class="headerlink" title="HTTP的8中请求方式"></a>HTTP的8中请求方式</h1></li><li>GET：向服务器请求指定的资源</li><li>POST：向服务器提交数据请求处理，数据被包含在请求体中。</li><li>HEAD : 返回服务器上对指定资源数据的 HTTP 请求头，在不需要返回全部数据的情况。</li><li>OPTIONS : 返回服务器对指定资源数据支持的 HTTP 请求方法，一般用于测试服务器功能的可用性。</li><li>PUT : 向服务器上传指定的数据。</li><li>DELETE : 向服务器发送请求删除指定数据。</li><li>TRACE : 回显服务器收到的请求，主要进行功能测试诊断。</li><li>CONNECT : HTTP1.1 协议中预留请求方式，可以将连接改为管道方式的代理服务器</li></ol><h1 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h1><ol><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ol><h1 id="HTTP-1-0-HTTP-1-1-HTPP-2-HTTP-3"><a href="#HTTP-1-0-HTTP-1-1-HTPP-2-HTTP-3" class="headerlink" title="HTTP/1.0 HTTP/1.1 HTPP/2 HTTP/3"></a>HTTP/1.0 HTTP/1.1 HTPP/2 HTTP/3</h1><h2 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能" class="headerlink" title="HTTP/1.1 相比 HTTP/1.0 提高了什么性能"></a>HTTP/1.1 相比 HTTP/1.0 提高了什么性能</h2><ol><li>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ol><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>早期 HTTP/1.0 性能上的一个很大的问题，<strong>那就是每发起一个请求，都要新建一次 TCP 连接</strong>（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。</p><p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接的通信方式</strong>，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p><strong>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</strong>。</p><h3 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h3><p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p><strong>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</strong></p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p><p>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。<strong>要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」</strong>。</p><h2 id="HTTP-1-1的缺点"><a href="#HTTP-1-1的缺点" class="headerlink" title="HTTP/1.1的缺点"></a>HTTP/1.1的缺点</h2><ol><li><strong>请求 / 响应头部（Header）未经压缩就发送</strong>，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。<strong>每次互相发送相同的首部造成的浪费较多</strong>；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li><li><strong>没有请求优先级控制</strong>；</li><li><strong>请求只能从客户端开始，服务器只能被动响应</strong>。</li></ol><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p><strong>HTTP/2 协议是基于 HTTPS 的</strong>，所以 HTTP/2 的安全性也是有保障的。<br>特点：</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP/2 会<strong>压缩头</strong>（Header)如果你同时发出多个请求，<strong>他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分</strong>。</p><p>这就是所谓的 HPACK 算法：<strong>在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了</strong>。</p><h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3><p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，<strong>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧</strong>。<br>HTTP1.1中的报文是 报文首部 + 空格 + 报文主题<br>HTTP2中的报文是 头信息帧 + 数据帧</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p><p>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</p><p>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</p><p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p><ol><li>同个域名<strong>只需要占用一个 TCP 连接</strong>，使用一个连接并行发送多个请求和响应，消除了因多个 TCP 连接而带来的延时和内存消耗并行交错地发送多个请求，</li><li>请求之间互不影响并行交错地发送多个响应，</li><li>响应之间互不干扰在 HTTP/2 中，</li><li>每个请求都可以带<strong>一个 31 bit 的优先值</strong>，数值越大优先级越低，0 表示最高优先级。有了这个优先值，客户端和服务器就可以在处理不同流时采取不同的策略，以最优的方式发送流、消息和帧。</li></ol><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</p><p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送</p><p><a href="https://zhuanlan.zhihu.com/p/68012355" target="_blank" rel="noopener">HTTP2/HTTP3</a></p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p><strong>HTTP/2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><h1 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p><h2 id="浏览器在使用HTTPS传输数据的流程"><a href="#浏览器在使用HTTPS传输数据的流程" class="headerlink" title="浏览器在使用HTTPS传输数据的流程"></a>浏览器在使用HTTPS传输数据的流程</h2><ol><li>首先TCP三次握手建立连接</li><li>客户端通过URL访问服务器建立SSL连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>服务器利用自己的私钥解密出会话密钥。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ol><h2 id="SSL连接的详细过程"><a href="#SSL连接的详细过程" class="headerlink" title="SSL连接的详细过程"></a>SSL连接的详细过程</h2><h3 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h3><p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。<br>在这一步，客户端主要向服务器发送以下信息：</p><ol><li>客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</li><li>客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。</li><li>客户端支持的密码套件列表，如 RSA 加密算法。</li></ol><h3 id="SeverHello"><a href="#SeverHello" class="headerlink" title="SeverHello"></a>SeverHello</h3><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p><ol><li>确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。</li><li>确认的密码套件列表，如 RSA 加密算法。</li><li>服务器的数字证书。</li></ol><h3 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h3><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p><strong>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文</strong>，向服务器发送如下信息：</p><ol><li>一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ol><p>上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</p><h3 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h3><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：</p><ol><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li></ol><p>至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><p><a href="https://www.nowcoder.com/discuss/379081?type=5" target="_blank" rel="noopener">牛客网http图解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;HTTP 是&lt;strong&gt;超文本传输协议&lt;/strong&gt;，也就是HyperText Transfer Protocol。&lt;br&gt;&lt;strong&gt;HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://sqwyyy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http&amp;https" scheme="https://sqwyyy.github.io/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>sql语句练习</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</id>
    <published>2020-05-25T13:08:57.000Z</published>
    <updated>2020-05-25T13:13:00.456Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`salaries`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`salary`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`from_date`</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ( </span><br><span class="line">(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> emp_no = <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">to_date</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>) -</span><br><span class="line">(<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> salaries <span class="keyword">WHERE</span> emp_no = <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">to_date</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>)</span><br><span class="line">) <span class="keyword">AS</span> growth</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`departments`</span> (</span><br><span class="line"><span class="string">`dept_no`</span> <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`dept_name`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`dept_no`</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`dept_emp`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`dept_no`</span> <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`dept_no`</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`employees`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`birth_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`last_name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`gender`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`hire_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> departments.dept_name,employees.last_name,employees.first_name</span><br><span class="line"><span class="keyword">from</span> departments <span class="keyword">left</span> <span class="keyword">join</span> dept_emp <span class="keyword">on</span> departments.dept_no = dept_emp.dept_no</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> employees <span class="keyword">on</span> employees.emp_no = dept_emp.emp_no;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">本题思路为运用两次LEFT JOIN连接嵌套</span><br><span class="line">1、第一次LEFT JOIN连接employees表与dept_emp表，</span><br><span class="line">得到所有员工的last_name和first_name以及对应的dept_no，</span><br><span class="line">也包括暂时没有分配部门的员工</span><br><span class="line">2、第二次LEFT JOIN连接上表与departments表，</span><br><span class="line">即连接dept_no与dept_name，得到所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`salaries`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`emp_no`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`salary`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`from_date`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`to_date`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`emp_no`&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;`from_date`&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; ( &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; salary &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; salaries &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; emp_no = &lt;span class=&quot;number&quot;&gt;10001&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to_date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DESC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; salary &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; salaries &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; emp_no = &lt;span class=&quot;number&quot;&gt;10001&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;to_date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ASC&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;AS&lt;/span&gt; growth&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
      <category term="sql练习" scheme="https://sqwyyy.github.io/tags/sql%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试题</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-05-25T13:07:44.000Z</published>
    <updated>2020-05-25T13:14:01.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主键、外键、超键、候选键"><a href="#主键、外键、超键、候选键" class="headerlink" title="主键、外键、超键、候选键"></a>主键、外键、超键、候选键</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。<br>候选键：是最小超键，即没有冗余元素的超键。<br>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。<br>外键：在一个表中存在的另一个表的主键称此表的外键。</p><a id="more"></a><h2 id="为什么用自增列作为主键"><a href="#为什么用自增列作为主键" class="headerlink" title="为什么用自增列作为主键"></a>为什么用自增列作为主键</h2><p>innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。</p><h2 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h2><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p><h2 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h2><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。<br>调用：<br>1）可以用一个命令对象来调用存储过程。<br>2）可以供外部程序调用，比如：java程序。</p><h1 id="什么是临时表，临时表什么时候删除"><a href="#什么是临时表，临时表什么时候删除" class="headerlink" title="什么是临时表，临时表什么时候删除"></a>什么是临时表，临时表什么时候删除</h1><ul><li>什么是临时表: MySQL用于存储一些中间结果集的表，临时表只在当前连接可见。</li><li>临时表什么时候删除: 当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。</li></ul><h2 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h2><p>优点：<br>1）存储过程是预编译过的，执行效率高。<br>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。<br>3）安全性高，执行存储过程需要有一定权限的用户。<br>4）存储过程可以重复使用，可减少数据库开发人员的工作量。<br>缺点：移植性差</p><h2 id="drop、truncate、-delete区别"><a href="#drop、truncate、-delete区别" class="headerlink" title="drop、truncate、 delete区别"></a>drop、truncate、 delete区别</h2><p>最基本：<br>drop直接删掉表。<br>truncate删除表中数据，再插入时自增长id又从1开始。<br>delete删除表中数据，可以加where字句。<br>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。<br>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。<br>（3） 一般而言，drop &gt; truncate &gt; delete<br>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view<br>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。<br>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。<br>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。<br>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。<br>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。<br>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。<br>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p><h2 id="查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序"></a>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序</h2><ul><li>from:需要从哪个数据表检索数据</li><li>where:过滤表中数据的条件</li><li>group by:如何将上面过滤出的数据分组</li><li>having:对上面已经分组的数据进行过滤的条件</li><li>select:查看结果集中的哪个列，或列的计算结果</li><li>order by :按照什么样的顺序来查看返回的数据</li></ul><h2 id="非关系型数据库和关系型数据库区别，优势比较"><a href="#非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="非关系型数据库和关系型数据库区别，优势比较?"></a>非关系型数据库和关系型数据库区别，优势比较?</h2><p>非关系型数据库的优势：</p><ol><li>性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li>可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ol><p>关系型数据库的优势：</p><ol><li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持：使得对于安全性能很高的数据访问要求得以实现。</li></ol><h2 id="SQL语言分类"><a href="#SQL语言分类" class="headerlink" title="SQL语言分类"></a>SQL语言分类</h2><ol><li>数据查询语言DQL(SELECT FROM WHERE子句构成的查询块)</li><li>数据操纵语言DML(INSERT UPDATE DELETE)</li><li>数据定义语言DDL(CREATE TABLE/VIEW/INDEX)</li><li>数据控制语言DCL(GRANT：授权 ROLLBACK回滚 COMMIT提交)</li></ol><h2 id="like-和-的区别"><a href="#like-和-的区别" class="headerlink" title="like %和-的区别"></a>like %和-的区别</h2><p>%百分号通配符:表示任何字符出现任意次数(可以是0次).<br><strong>_下划线通配符:</strong>表示只能匹配单个字符,不能多也不能少,就是一个字符.<br>like操作符: LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><h2 id="MYSQL的存储引擎"><a href="#MYSQL的存储引擎" class="headerlink" title="MYSQL的存储引擎"></a>MYSQL的存储引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别以及如何选择"><a href="#MySQL存储引擎MyISAM与InnoDB区别以及如何选择" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别以及如何选择"></a>MySQL存储引擎MyISAM与InnoDB区别以及如何选择</h3><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； </li><li>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；</li><li>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</li><li>InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有</li><li>MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。<br>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。<br>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。<br>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。<br>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。</li></ol><h3 id="MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a>MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</h3><p>事务处理上方面<br>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。<br>锁级别<br>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。<br><a href="https://blog.csdn.net/qq_35642036/article/details/82820178" target="_blank" rel="noopener">来源</a></p><h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p><strong>1NF的定义为：符合1NF的关系中的每个属性都不可再分,具有原子性</strong></p><h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p><strong>满足1NF的基础上，要求：表中的所有列，都必需依赖于主键，而不能有任何一列与主键没有关系</strong></p><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p><strong>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖</strong></p><p><a href="https://zhuanlan.zhihu.com/p/20028672" target="_blank" rel="noopener">数据库范式</a></p><h1 id="主从复制，分库分表？"><a href="#主从复制，分库分表？" class="headerlink" title="主从复制，分库分表？"></a>主从复制，分库分表？</h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主键、外键、超键、候选键&quot;&gt;&lt;a href=&quot;#主键、外键、超键、候选键&quot; class=&quot;headerlink&quot; title=&quot;主键、外键、超键、候选键&quot;&gt;&lt;/a&gt;主键、外键、超键、候选键&lt;/h2&gt;&lt;p&gt;超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。&lt;br&gt;候选键：是最小超键，即没有冗余元素的超键。&lt;br&gt;主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。&lt;br&gt;外键：在一个表中存在的另一个表的主键称此表的外键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql优化</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E4%BC%98%E5%8C%96/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E4%BC%98%E5%8C%96/</id>
    <published>2020-05-25T13:06:50.000Z</published>
    <updated>2020-05-25T13:12:09.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h1><a id="more"></a><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，<strong>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</strong></p><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，<strong>应该尽量把字段设置为NOTNULL</strong>，这样在将来执行查询的时候，数据库不用去比较NULL值。 对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h1 id="使用连接查询来代替子查询"><a href="#使用连接查询来代替子查询" class="headerlink" title="使用连接查询来代替子查询"></a>使用连接查询来代替子查询</h1><p>例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CustomerID <span class="keyword">FROM</span> salesinfo)</span><br></pre></td></tr></table></figure><br>子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> salesinfo <span class="keyword">ON</span> customerinfo.CustomerID=salesinfo.CustomerID</span><br><span class="line"><span class="keyword">WHERE</span> salesinfo.CustomerID <span class="keyword">ISNULL</span></span><br></pre></td></tr></table></figure><p>连接查询</p><p>内连接：只显示两表id匹配的<br>左外连接：显示join左边的表的所有数据（不管两表是否匹配），对于不匹配的部分都用NULL显示<br>右外连接：与左外连接相反，显示join右边的表的所有数据<br><a href="https://blog.csdn.net/doubleguy/article/details/89708227" target="_blank" rel="noopener">来源</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--内连接（只显示两表id匹配的）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">inner</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--左外连接（显示join左边的表的所有数据，exam只有两条记录，所以stu.id,grade都用NULL显示）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">left</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--右外连接（与左外连接相反，显示join右边的表的所有数据）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">right</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br></pre></td></tr></table></figure></p><h2 id="子查询比连接查询慢的原因是"><a href="#子查询比连接查询慢的原因是" class="headerlink" title="子查询比连接查询慢的原因是"></a>子查询比连接查询慢的原因是</h2><p><strong>执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，<strong>就是可以保持数据库中数据的一致性和完整性</strong>。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><ol><li><p>原子性。事务是数据库的逻辑工作单位，<strong>事务中包含的各操作要么都做，要么都不做</strong></p></li><li><p>一致性。<strong>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</strong>。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p></li><li><p>隔离性。<strong>在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰</strong>。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p>持续性。也称永久性，<strong>指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的</strong>。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><h2 id="事务并发可能出现的问题"><a href="#事务并发可能出现的问题" class="headerlink" title="事务并发可能出现的问题"></a>事务并发可能出现的问题</h2></li><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：在一个事务的两次查询之中数据不一致，事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li><li>幻读：例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ol><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommitted（读取未提交内容）-RU"><a href="#Read-Uncommitted（读取未提交内容）-RU" class="headerlink" title="Read Uncommitted（读取未提交内容） RU"></a>Read Uncommitted（读取未提交内容） RU</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><h3 id="Read-Committed（读取提交内容）RC"><a href="#Read-Committed（读取提交内容）RC" class="headerlink" title="Read Committed（读取提交内容）RC"></a>Read Committed（读取提交内容）RC</h3><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><h3 id="Repeatable-Read（可重读）RR"><a href="#Repeatable-Read（可重读）RR" class="headerlink" title="Repeatable Read（可重读）RR"></a>Repeatable Read（可重读）RR</h3><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p><h2 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h2><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><div class="table-container"><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>x</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>x</td><td>x</td><td>√</td></tr><tr><td>Serializable</td><td>x</td><td>x</td><td>x</td></tr></tbody></table></div><h1 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mvcc是多版本并发控制 ，它是数据库管理系统一种常见的并发控制。</p><ul><li>事务版本号:每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</li><li><p>表格的隐藏列</p><ul><li>DB_TRX_ID: 记录操作该数据事务的事务ID；</li><li>DB_ROLL_PTR：指向上一个版本数据在undo log 里的位置指针；</li><li>DB_ROW_ID: 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</li><li>undoLog: 事务的回滚日志</li><li><p>Read view: 在innodb 中每个SQL语句执行前都会得到一个read_view</p><ul><li><p>trx_ids: trx_ids为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）</p></li><li><p>low_limit_id: 当前最大的事务号 + 1，事务号 &gt;= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。</p></li><li>up_limit_id: 当前已经提交的事务号 + 1，事务号 &lt; up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。</li></ul></li></ul></li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li><p>获取当前事务版本号</p></li><li><p>获得一个readview</p></li><li>查到数据，与readview的事务版本号进行匹配</li><li>不符合readview的规则，就从undo lo获取历史版本数据</li><li>返回符合规则的数据</li></ol><p>RC(read commit) 级别下<strong>同一个事务里面的每一次查询都会获得一个新的read view副本</strong>。这样就可能造成同一个事务里前后读取数据可能不一致的问题（幻读）</p><p>RR(重复读)级别下的<strong>一个事务里只会获取一次read view副本</strong>，从而保证每次查询的数据都是一样的。</p><h2 id="mvcc并未解决幻读问题"><a href="#mvcc并未解决幻读问题" class="headerlink" title="mvcc并未解决幻读问题"></a>mvcc并未解决幻读问题</h2><p>例如:<br>一开始表中有一条数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|id|name|</span><br><span class="line">|1|开发部|</span><br></pre></td></tr></table></figure><br>| 事务一                        | 事务二                                  |<br>| ——————————————- | ———————————————————- |<br>| begin                         | begin                                   |<br>| select * from dept            | -                                       |<br>| -                             | insert into dept(name) values(“研发部”) |<br>| -                             | commit                                  |<br>| update dept set name=”财务部” | -                                       |<br>| commit                        | -                                       |</p><p>上面的结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id name</span><br><span class="line">1 开发部</span><br><span class="line">9 开发部</span><br></pre></td></tr></table></figure><br>产生了幻读</p><p><strong>解决幻读的方法是添加next-key lock</strong></p><p><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68" target="_blank" rel="noopener">mvcc</a><br><a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">mvcc</a></p><h2 id="数据中的锁"><a href="#数据中的锁" class="headerlink" title="数据中的锁"></a>数据中的锁</h2><h3 id="读的分类"><a href="#读的分类" class="headerlink" title="读的分类"></a>读的分类</h3><ul><li>快照读是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</li><li>当前读是基于 临键锁（行锁 + 间歇锁）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。<br><a href="https://www.cnblogs.com/AlmostWasteTime/p/11466520.html" target="_blank" rel="noopener">快照读与当前读</a><h3 id="按锁的粒度分类"><a href="#按锁的粒度分类" class="headerlink" title="按锁的粒度分类:"></a>按锁的粒度分类:</h3></li></ul><ol><li>行锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。行级锁<strong>分为共享锁和排他锁。</strong></li><li>页锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li><li>表锁:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。<br>表级锁定分为表<strong>共享读锁（共享锁）与表独占写锁（排他锁）</strong></li></ol><p>InnoDB行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！(innodb和myISAM都不支持页锁)</p><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。<br>排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。<br>我们<strong>通过update、delete等语句加上的锁都是行级别的锁</strong>。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。<br>意向共享锁(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br>意向排他锁(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p><h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><ol><li>行锁:该锁是对索引记录进行加锁,innodb中一定存在聚簇索引，所以行锁最终在聚簇索引上.</li><li>间隙锁:是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<strong>Read Committed隔离级别下，隔离级别比Read Committed低的情况下，都不会使用间隙锁</strong></li><li>Next-Key Locks：这个理解为行锁+索引前面的间隙锁。<br>比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10](负无穷)</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><strong>表锁是通过Next-Key Locks来实现的锁表操作。</strong><h2 id="锁的用法"><a href="#锁的用法" class="headerlink" title="锁的用法"></a>锁的用法</h2>SELECT … LOCK IN SHARE MODE 共享行锁<br>SELECT … FOR UPDATE 排他行锁<br>LOCK TABLE … READ 共享读锁<br>LOCK TABLE … WRITE 排他写锁</li></ol><p><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">锁的详解</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><h1 id="优化sql语句"><a href="#优化sql语句" class="headerlink" title="优化sql语句"></a>优化sql语句</h1><ol><li>能用到索引尽量用到索引.对索引的优化实际上就是sql语句的调优</li><li>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段</li><li>尽量使用where,而不要使用having</li><li>尽量使用多表查询,不要使用子查询</li><li>where后的and.or左右执行顺序是从右至左,运算符为and时–尽量把为假的放在右边,运算符为or时–尽量把为真的放在右边</li></ol><h1 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h1><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Phone <span class="keyword">FROM</span> <span class="keyword">client</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,BirthDate <span class="keyword">FROM</span> author <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Supplier <span class="keyword">FROM</span> product</span><br></pre></td></tr></table></figure><br><a href="https://zhuanlan.zhihu.com/p/86871140" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;选取最适用的字段属性&quot;&gt;&lt;a href=&quot;#选取最适用的字段属性&quot; class=&quot;headerlink&quot; title=&quot;选取最适用的字段属性&quot;&gt;&lt;/a&gt;选取最适用的字段属性&lt;/h1&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2020-05-25T13:05:57.000Z</published>
    <updated>2020-05-25T13:11:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h1><a id="more"></a><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，<strong>在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</strong></p><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，<strong>应该尽量把字段设置为NOTNULL</strong>，这样在将来执行查询的时候，数据库不用去比较NULL值。 对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><h1 id="使用连接查询来代替子查询"><a href="#使用连接查询来代替子查询" class="headerlink" title="使用连接查询来代替子查询"></a>使用连接查询来代替子查询</h1><p>例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">WHERE</span> CustomerID <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> CustomerID <span class="keyword">FROM</span> salesinfo)</span><br></pre></td></tr></table></figure><br>子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customerinfo</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> salesinfo <span class="keyword">ON</span> customerinfo.CustomerID=salesinfo.CustomerID</span><br><span class="line"><span class="keyword">WHERE</span> salesinfo.CustomerID <span class="keyword">ISNULL</span></span><br></pre></td></tr></table></figure><p>连接查询</p><p>内连接：只显示两表id匹配的<br>左外连接：显示join左边的表的所有数据（不管两表是否匹配），对于不匹配的部分都用NULL显示<br>右外连接：与左外连接相反，显示join右边的表的所有数据<br><a href="https://blog.csdn.net/doubleguy/article/details/89708227" target="_blank" rel="noopener">来源</a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--内连接（只显示两表id匹配的）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">inner</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--左外连接（显示join左边的表的所有数据，exam只有两条记录，所以stu.id,grade都用NULL显示）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">left</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br><span class="line"><span class="comment">--右外连接（与左外连接相反，显示join右边的表的所有数据）</span></span><br><span class="line"><span class="keyword">select</span> stu.id,exam.id,stu.name,exam.grade <span class="keyword">from</span> stu <span class="keyword">right</span> <span class="keyword">join</span> exam <span class="keyword">on</span> stu.id=exam.id</span><br></pre></td></tr></table></figure></p><h2 id="子查询比连接查询慢的原因是"><a href="#子查询比连接查询慢的原因是" class="headerlink" title="子查询比连接查询慢的原因是"></a>子查询比连接查询慢的原因是</h2><p><strong>执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，<strong>就是可以保持数据库中数据的一致性和完整性</strong>。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><h2 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p><ol><li><p>原子性。事务是数据库的逻辑工作单位，<strong>事务中包含的各操作要么都做，要么都不做</strong></p></li><li><p>一致性。<strong>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</strong>。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p></li><li><p>隔离性。<strong>在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰</strong>。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p>持续性。也称永久性，<strong>指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的</strong>。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><h2 id="事务并发可能出现的问题"><a href="#事务并发可能出现的问题" class="headerlink" title="事务并发可能出现的问题"></a>事务并发可能出现的问题</h2></li><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：在一个事务的两次查询之中数据不一致，事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li><li>幻读：例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ol><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="Read-Uncommitted（读取未提交内容）-RU"><a href="#Read-Uncommitted（读取未提交内容）-RU" class="headerlink" title="Read Uncommitted（读取未提交内容） RU"></a>Read Uncommitted（读取未提交内容） RU</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><h3 id="Read-Committed（读取提交内容）RC"><a href="#Read-Committed（读取提交内容）RC" class="headerlink" title="Read Committed（读取提交内容）RC"></a>Read Committed（读取提交内容）RC</h3><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><h3 id="Repeatable-Read（可重读）RR"><a href="#Repeatable-Read（可重读）RR" class="headerlink" title="Repeatable Read（可重读）RR"></a>Repeatable Read（可重读）RR</h3><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p><h2 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h2><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><div class="table-container"><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>x</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>x</td><td>x</td><td>√</td></tr><tr><td>Serializable</td><td>x</td><td>x</td><td>x</td></tr></tbody></table></div><h1 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>mvcc是多版本并发控制 ，它是数据库管理系统一种常见的并发控制。</p><ul><li>事务版本号:每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</li><li><p>表格的隐藏列</p><ul><li>DB_TRX_ID: 记录操作该数据事务的事务ID；</li><li>DB_ROLL_PTR：指向上一个版本数据在undo log 里的位置指针；</li><li>DB_ROW_ID: 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</li><li>undoLog: 事务的回滚日志</li><li><p>Read view: 在innodb 中每个SQL语句执行前都会得到一个read_view</p><ul><li><p>trx_ids: trx_ids为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）</p></li><li><p>low_limit_id: 当前最大的事务号 + 1，事务号 &gt;= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。</p></li><li>up_limit_id: 当前已经提交的事务号 + 1，事务号 &lt; up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。</li></ul></li></ul></li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li><p>获取当前事务版本号</p></li><li><p>获得一个readview</p></li><li>查到数据，与readview的事务版本号进行匹配</li><li>不符合readview的规则，就从undo lo获取历史版本数据</li><li>返回符合规则的数据</li></ol><p>RC(read commit) 级别下<strong>同一个事务里面的每一次查询都会获得一个新的read view副本</strong>。这样就可能造成同一个事务里前后读取数据可能不一致的问题（幻读）</p><p>RR(重复读)级别下的<strong>一个事务里只会获取一次read view副本</strong>，从而保证每次查询的数据都是一样的。</p><h2 id="mvcc并未解决幻读问题"><a href="#mvcc并未解决幻读问题" class="headerlink" title="mvcc并未解决幻读问题"></a>mvcc并未解决幻读问题</h2><p>例如:<br>一开始表中有一条数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|id|name|</span><br><span class="line">|1|开发部|</span><br></pre></td></tr></table></figure><br>| 事务一                        | 事务二                                  |<br>| ——————————————- | ———————————————————- |<br>| begin                         | begin                                   |<br>| select * from dept            | -                                       |<br>| -                             | insert into dept(name) values(“研发部”) |<br>| -                             | commit                                  |<br>| update dept set name=”财务部” | -                                       |<br>| commit                        | -                                       |</p><p>上面的结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id name</span><br><span class="line">1 开发部</span><br><span class="line">9 开发部</span><br></pre></td></tr></table></figure><br>产生了幻读</p><p><strong>解决幻读的方法是添加next-key lock</strong></p><p><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/68" target="_blank" rel="noopener">mvcc</a><br><a href="https://zhuanlan.zhihu.com/p/52977862" target="_blank" rel="noopener">mvcc</a></p><h2 id="数据中的锁"><a href="#数据中的锁" class="headerlink" title="数据中的锁"></a>数据中的锁</h2><h3 id="读的分类"><a href="#读的分类" class="headerlink" title="读的分类"></a>读的分类</h3><ul><li>快照读是基于 MVCC 和 undo log 来实现的，适用于简单 select 语句。</li><li>当前读是基于 临键锁（行锁 + 间歇锁）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。<br><a href="https://www.cnblogs.com/AlmostWasteTime/p/11466520.html" target="_blank" rel="noopener">快照读与当前读</a><h3 id="按锁的粒度分类"><a href="#按锁的粒度分类" class="headerlink" title="按锁的粒度分类:"></a>按锁的粒度分类:</h3></li></ul><ol><li>行锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。行级锁<strong>分为共享锁和排他锁。</strong></li><li>页锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li><li>表锁:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。<br>表级锁定分为表<strong>共享读锁（共享锁）与表独占写锁（排他锁）</strong></li></ol><p>InnoDB行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！(innodb和myISAM都不支持页锁)</p><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>共享锁(S锁):假设事务T1对数据A加上共享锁，那么事务T2可以读数据A，不能修改数据A。<br>排他锁(X锁):假设事务T1对数据A加上排他锁，那么事务T2不能读数据A，不能修改数据A。<br>我们<strong>通过update、delete等语句加上的锁都是行级别的锁</strong>。只有LOCK TABLE … READ和LOCK TABLE … WRITE才能申请表级别的锁。<br>意向共享锁(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br>意向排他锁(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。</p><h3 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h3><ol><li>行锁:该锁是对索引记录进行加锁,innodb中一定存在聚簇索引，所以行锁最终在聚簇索引上.</li><li>间隙锁:是对索引的间隙加锁，其目的只有一个，防止其他事物插入数据。在<strong>Read Committed隔离级别下，隔离级别比Read Committed低的情况下，都不会使用间隙锁</strong></li><li>Next-Key Locks：这个理解为行锁+索引前面的间隙锁。<br>比如一个索引包含值，10，11，13和20。那么，间隙锁的范围如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10](负无穷)</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><strong>表锁是通过Next-Key Locks来实现的锁表操作。</strong><h2 id="锁的用法"><a href="#锁的用法" class="headerlink" title="锁的用法"></a>锁的用法</h2>SELECT … LOCK IN SHARE MODE 共享行锁<br>SELECT … FOR UPDATE 排他行锁<br>LOCK TABLE … READ 共享读锁<br>LOCK TABLE … WRITE 排他写锁</li></ol><p><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">锁的详解</a></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><h1 id="优化sql语句"><a href="#优化sql语句" class="headerlink" title="优化sql语句"></a>优化sql语句</h1><ol><li>能用到索引尽量用到索引.对索引的优化实际上就是sql语句的调优</li><li>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段</li><li>尽量使用where,而不要使用having</li><li>尽量使用多表查询,不要使用子查询</li><li>where后的and.or左右执行顺序是从右至左,运算符为and时–尽量把为假的放在右边,运算符为or时–尽量把为真的放在右边</li></ol><h1 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h1><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Phone <span class="keyword">FROM</span> <span class="keyword">client</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,BirthDate <span class="keyword">FROM</span> author <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,Supplier <span class="keyword">FROM</span> product</span><br></pre></td></tr></table></figure><br><a href="https://zhuanlan.zhihu.com/p/86871140" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;选取最适用的字段属性&quot;&gt;&lt;a href=&quot;#选取最适用的字段属性&quot; class=&quot;headerlink&quot; title=&quot;选取最适用的字段属性&quot;&gt;&lt;/a&gt;选取最适用的字段属性&lt;/h1&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://sqwyyy.github.io/categories/mysql/"/>
    
    
      <category term="索引" scheme="https://sqwyyy.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/ThreadLocal/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/ThreadLocal/</id>
    <published>2020-05-25T13:02:05.000Z</published>
    <updated>2020-05-25T13:10:19.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaBase.LineDistance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈一句话功能简述〉;</span></span><br><span class="line"><span class="comment"> * 〈功能详细描述〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> [相关类/方法]（可选）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> [产品/模块版本] （可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> MyThreadLocal();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程1："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程2："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    threadLocal.set(threadLocal.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"线程3："</span> + threadLocal.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">2</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">2</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">1</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">2</span></span><br><span class="line">线程<span class="number">2</span>：<span class="number">3</span></span><br><span class="line">线程<span class="number">3</span>：<span class="number">3</span></span><br><span class="line">线程<span class="number">1</span>：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><h1 id="Threadlocal原理"><a href="#Threadlocal原理" class="headerlink" title="Threadlocal原理"></a>Threadlocal原理</h1><ol><li>void set(Object value)设置当前线程的线程局部变量的值。</li><li>public Object get()该方法返回当前线程所对应的线程局部变量。</li><li>public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li><li>protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</li></ol><h2 id="set方法的实现"><a href="#set方法的实现" class="headerlink" title="set方法的实现"></a>set方法的实现</h2><p>set方法是设置一个线程的局部变量的值，相当于当前线程通过set设置的局部变量的值，只对当前线程可见。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();<span class="comment">//获取当前执行的线程</span></span><br><span class="line">        ThreadLocalMap map = getMap(t); <span class="comment">//获得当前线程的ThreadLocalMap实例</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)<span class="comment">//如果map不为空，说明当前线程已经有了一个ThreadLocalMap实例</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);<span class="comment">//直接将当前value设置到ThreadLocalMap中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value); <span class="comment">//说明当前线程是第一次使用线程本地变量，构造map</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>map.set(this,value)中key是this，value是我们指定的值，this代表的是那个ThreadLocal类型的变量。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap是一个静态内部类，内部定义了一个Entry对象用来真正存储数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            <span class="comment">//构造一个Entry数组，并设置初始大小</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">//计算Entry数据下标</span></span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将`firstValue`存入到指定的table下标中</span></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;<span class="comment">//设置节点长度为1</span></span><br><span class="line">            setThreshold(INITIAL_CAPACITY); <span class="comment">//设置扩容的阈值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>每个线程自身都维护着一个ThreadLocalMap，用来存储线程本地的数据，可以简单理解成ThreadLocalMap的key是ThreadLocal变量，value是线程本地的数据。就这样很简单的实现了线程本地数据存储和交互访问。</p><h2 id="get方法的实现"><a href="#get方法的实现" class="headerlink" title="get方法的实现"></a>get方法的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             T result = (T)e.value;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap中存放的就是Entry，Entry的KEY就是ThreadLocal，VALUE就是值。</p><h2 id="remo"><a href="#remo" class="headerlink" title="remo"></a>remo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();<span class="comment">//调用Entry的clear方法</span></span><br><span class="line">                    expungeStaleEntry(i);<span class="comment">//清除陈旧数据</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000017272578" target="_blank" rel="noopener">来源</a><br><a href="https://www.jianshu.com/p/69ae8c213b30" target="_blank" rel="noopener">来源</a><br><a href="https://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="ThreadLocal" scheme="https://sqwyyy.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/AQS/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/AQS/</id>
    <published>2020-05-25T12:59:22.000Z</published>
    <updated>2020-05-25T13:10:19.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AQS是一个抽象类，主要是通过继承的方式来使用，这个类在java.util.concurrent.locks包。<strong>一个用来实现同步锁以及其他涉及到同步功能的核心组件</strong>，列入有ReentrantLock、CountDownLatch等</p><a id="more"></a><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>从使用层面来说，AQS的功能分为两种：独占和共享</p><ol><li>独占锁，每次只能有一个线程持有锁，比如前面给大家演示的ReentrantLock就是以独占方式实现的互斥锁</li><li>共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><img src="1" alt="图片.png"></li></ol><h1 id="AQS源码（以ReentrantLock为例"><a href="#AQS源码（以ReentrantLock为例" class="headerlink" title="AQS源码（以ReentrantLock为例)"></a>AQS源码（以ReentrantLock为例)</h1><p>ReentrantLock.lock()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicvoid <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">   sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sync是一个静态内部类,它继承了AQS这个抽象类.Sync这个类有两个具体的实现分别是<strong>NofairSync(非公平锁)</strong>，<strong>FailSync(公平锁)</strong>.</p><ol><li>公平锁 表示所有线程严格按照FIFO来获取锁</li><li>非公平锁 表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁</li></ol><h2 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync.lock"></a>NonfairSync.lock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入acquire方法</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>acquire是AQS中的方法，如果CAS操作未能成功，说明state已经不为0，此时继续acquire(1)操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ol><li>通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false</li><li>如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部</li><li>acquireQueued，将Node作为参数，<strong>通过自旋去尝试获取锁</strong>。</li></ol><h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p>这个方法的作用是尝试获取锁，如果成功返回true，不成功返回false.它是重写AQS类中的tryAcquire方法,AQS中tryAcquire方法的定义，并没有实现，而是抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="nonfairTryAcquire方法"><a href="#nonfairTryAcquire方法" class="headerlink" title="nonfairTryAcquire方法"></a>nonfairTryAcquire方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">//获得state的值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//state=0说明当前是无锁状态</span></span><br><span class="line">        <span class="comment">//通过cas操作来替换state的值改为1，大家想想为什么要用cas呢？</span></span><br><span class="line">        <span class="comment">//理由是，在多线程环境中，直接修改state=1会存在线程安全问题，你猜到了吗？</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//保存当前获得锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这段逻辑就很简单了。如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">//增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="compareAndSetState方法"><a href="#compareAndSetState方法" class="headerlink" title="compareAndSetState方法"></a>compareAndSetState方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> STATE.compareAndSet(<span class="keyword">this</span>, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是通过cas乐观锁的方式来做比较并替换</p><ol><li>当state=0时，表示无锁状态</li><li>当state&gt;0时，表示已经有线程获得了锁，也就是state=1，但是因为ReentrantLock允许重入，所以同一个线程多次获得同步锁的时候，state会递增，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁</li></ol><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>当tryAcquire方法获取锁失败以后，则会先调用addWaiter将当前线程封装成Node，然后添加到AQS队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">//mode=Node.EXCLUSIVE</span></span><br><span class="line">        <span class="comment">//将当前线程封装成Node，并且mode为独占锁</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); </span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(node)方法</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//tail不为空的情况，说明队列中存在节点数据</span></span><br><span class="line">            node.prev = pred;  <span class="comment">//讲当前线程的Node的prev节点指向tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//通过cas讲node添加到AQS队列</span></span><br><span class="line">                pred.next = node;<span class="comment">//cas成功，把旧的tail的next指针指向新的tail</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">//tail=null，将node添加到同步队列中</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h3><p>enq就是通过自旋操作把当前节点加入队列中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail; <span class="comment">//如果是第一次添加到队列，那么tail=null</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//CAS的方式创建一个空的Node作为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   <span class="comment">//此时队列中只一个头结点，所以tail也指向它</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//进行第二次循环时，tail不为null，进入else区域。将当前线程的Node结点的prev指向tail，然后使用CAS将tail指向Node</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line"><span class="comment">//t此时指向tail,所以可以CAS成功，将tail重新指向Node。此时t为更新前的tail的值，即指向空的头结点，t.next=node，就将头结点的后续结点指向Node，返回头结点</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>假如有两个线程t1,t2同时进入enq方法，t==null表示队列是首次使用，需要先初始化<br>另外一个线程cas失败，则进入下次循环，通过cas操作将node添加到队尾</p><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p>将添加到队列中的Node作为参数传入acquireQueued方法，这里面会做抢占锁的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 获取prev节点,若为null即刻抛出NullPointException</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 如果前驱为head才有资格进行锁的抢夺</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点</span></span><br><span class="line"><span class="comment">//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">//获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">// 若前面为true,则执行挂起,待下次唤醒的时候检测中断的标志</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果抛出异常则取消锁的获取,进行出队(sync queue)操作</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>获取当前节点的prev节点</li><li>如果prev节点为head节点，那么它就有资格去争抢锁，调用tryAcquire抢占锁</li><li>抢占锁成功以后，把获得锁的节点设置为head，并且移除原来的初始化head节点</li><li>如果获得锁失败，则根据waitStatus决定是否需要挂起线程</li><li>最后，通过cancelAcquire取消获得锁的操作</li></ol><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p>从上面的分析可以看出，只有队列的第二个节点可以有机会争用锁，如果成功获取锁，则此节点晋升为头节点。对于第三个及以后的节点，if (p == head)条件不成立，首先进行shouldParkAfterFailedAcquire(p, node)操作<br>shouldParkAfterFailedAcquire方法是判断一个争用锁的线程是否应该被阻塞。它首先判断一个节点的前置节点的状态是否为Node.SIGNAL，如果是，是说明此节点已经将状态设置-如果锁释放，则应当通知它，所以它可以安全的阻塞了，返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">//前继节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//如果是SIGNAL状态，意味着当前线程需要被unpark唤醒</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">如果前节点的状态大于<span class="number">0</span>，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回<span class="keyword">false</span>。在下次循环执行shouldParkAfterFailedAcquire时，返回<span class="keyword">true</span>。这个操作实际是把队列中CANCELLED的节点剔除掉。</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点'的前继节点”。</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release方法里面做两件事，1，释放锁 ；2，唤醒park的线程</p><h2 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个动作可以认为就是一个设置锁状态的操作，而且是将状态减掉传入的参数值（参数是1），如果结果状态为0，就将排它锁的Owner设置为null，以使得其它的线程有机会进行执行。<br>在排它锁中，加锁的时候状态会增加1（当然可以自己修改这个值），在解锁的时候减掉1，同一个锁，在可以重入后，可能会被叠加为2、3、4这些值，只有unlock()的次数与lock()的次数对应才会将Owner线程设置为空，而且也只有这种情况下才会返回true。</p><h2 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//判断后继节点是否为空或者是否是取消状态,</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点, 至于为什么从尾部开始向前遍历，因为在doAcquireInterruptibly.cancelAcquire方法的处理过程中只设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法unparkSuccessor(Node)中，就意味着真正要释放锁了，它传入的是head节点（head节点是占用锁的节点），当前线程被释放之后，需要唤醒下一个节点的线程</p><p><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;AQS是一个抽象类，主要是通过继承的方式来使用，这个类在java.util.concurrent.locks包。&lt;strong&gt;一个用来实现同步锁以及其他涉及到同步功能的核心组件&lt;/strong&gt;，列入有ReentrantLock、CountDownLatch等&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA锁" scheme="https://sqwyyy.github.io/tags/JAVA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://sqwyyy.github.io/archives/2020/05/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://sqwyyy.github.io/archives/2020/05/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-05-25T12:57:16.000Z</published>
    <updated>2020-05-25T13:10:20.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用线程池的原因"><a href="#使用线程池的原因" class="headerlink" title="使用线程池的原因"></a>使用线程池的原因</h2><ol><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li><li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换<br><a href="https://www.jianshu.com/p/7726c70cdc40" target="_blank" rel="noopener">来源</a></li></ol><a id="more"></a><h2 id="线程池的主要参数"><a href="#线程池的主要参数" class="headerlink" title="线程池的主要参数"></a>线程池的主要参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> maximumPoolSize, // 线程数的上限</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">long</span> keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，</span></span></span><br><span class="line"><span class="function"><span class="params">                                     // 超过这个时间，多余的线程会被回收。</span></span></span><br><span class="line"><span class="function"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列</span></span></span><br><span class="line"><span class="function"><span class="params">  ThreadFactory threadFactory, // 新线程的产生方式</span></span></span><br><span class="line"><span class="function"><span class="params">  RejectedExecutionHandler handler)</span> <span class="comment">//拒绝策略</span></span></span><br></pre></td></tr></table></figure><ol><li>corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</li><li>maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</li><li>keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li><li>unit：存活时间单位（小时，分，秒等等）</li><li>workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</li><li>threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</li><li>handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。<h2 id="线程池流程"><a href="#线程池流程" class="headerlink" title="线程池流程"></a>线程池流程</h2></li><li>当提交一个新任务到线程池时首先线程池判断基本线程池(corePoolSize)是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程；</li><li>其次线程池判断工作队列(workQueue)是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程；</li><li>最后线程池判断整个线程池(maximumPoolSize)是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务；</li><li>如果线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；</li><li>如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过 keepAliveTime，线程也会被终止。</li></ol><h2 id="线程池为什么使用阻塞队列而不适用非阻塞队列"><a href="#线程池为什么使用阻塞队列而不适用非阻塞队列" class="headerlink" title="线程池为什么使用阻塞队列而不适用非阻塞队列"></a>线程池为什么使用阻塞队列而不适用非阻塞队列</h2><ol><li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。</li><li><p>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。使得在线程不至于一直占用cpu资源。</p><h2 id="java中提供的线程池"><a href="#java中提供的线程池" class="headerlink" title="java中提供的线程池"></a>java中提供的线程池</h2><p>Executors类提供了4种不同的线程池：newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool, newSingleThreadExecutor</p></li><li><p>newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>newScheduledThreadPool：适用于执行延时或者周期性任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2></li><li>RUNNING：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</li><li>SHUTDOWN： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>STOP ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>TIDYING ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；</li><li>TERMINATED： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2>RejectedExecutionHandler是一个接口：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当要创建的线程数量大于线程池的最大线程数的时候，新的任务就会被拒绝，就会调用这个接口里的这个方法。<br>可以自己实现这个接口，实现对这些超出数量的任务的处理。<br>ThreadPoolExecutor自己已经提供了四个拒绝策略，分别是<strong>CallerRunsPolicy,AbortPolicy,DiscardPolicy,DiscardOldestPolicy</strong><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3>ThreadPoolExecutor中默认的拒绝策略就是AbortPolicy。直接抛出异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mythread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程:"</span>+Thread.currentThread().getName() +<span class="string">" 执行:"</span>+name +<span class="string">"  run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">handerdom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,</span><br><span class="line">                TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"添加第"</span>+i+<span class="string">"个任务"</span>);</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Mythread(<span class="string">"线程"</span>+i));</span><br><span class="line">            Iterator iterator = executor.getQueue().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                Mythread thread = (Mythread) iterator.next();</span><br><span class="line">                System.out.println(<span class="string">"列表："</span>+thread.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task threadpoolexecutor.Mythread@7106e68e rejected from java.util.concurrent.ThreadPoolExecutor@7eda2dbb[Running, pool size &#x3D; 2, active threads &#x3D; 2, queued tasks &#x3D; 2, completed tasks &#x3D; 0]</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)</span><br><span class="line">at java.base&#x2F;java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)</span><br><span class="line">at threadpoolexecutor.handerdom.main(handerdom.java:34)</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br></pre></td></tr></table></figure></li><li>添加第一个任务时，直接执行，任务列表为空。</li><li>添加第二个任务时，因为采用的LinkedBlockingDeque，，并且核心线程正在执行任务，所以会将第二个任务放在队列中，队列中有 线程1.</li><li>添加第三个任务时，也一样会放在队列中，队列中有 线程1，线程2.</li><li>添加第四个任务时，因为核心任务还在运行，而且任务队列已经满了，所以胡直接创建新线程执行第四个任务，。这时线程池中一共就有两个线程在运行了，达到了最大线程数。任务队列中还是有线程1， 线程2.</li><li>添加第五个任务时，再也没有地方能存放和执行这个任务了，就会被线程池拒绝添加，执行拒绝策略的rejectedExecution方法，这里就是执行AbortPolicy的rejectedExecution方法直接抛出异常。<br>最终，只有四个线程能完成运行。后面的都被拒绝了。<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3>CallerRunsPolicy在任务被拒绝添加后，<strong>会调用当前线程池的所在的线程去执行被拒绝的任务。</strong><br>输出结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">线程:main 执行:线程4  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程2</span><br><span class="line">列表：线程5</span><br><span class="line">线程:pool-1-thread-1 执行:线程1  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程2  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程5  run</span><br></pre></td></tr></table></figure>这个策略的缺点就是可能会阻塞主线程。<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3>采用这个拒绝策略，会让被线程池拒绝的任务直接抛弃，不会抛异常也不会执行。<br>运行结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程2  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程1  run</span><br></pre></td></tr></table></figure><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3>当任务被拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的弹出，再把这个新任务添加进去。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">添加第0个任务</span><br><span class="line">添加第1个任务</span><br><span class="line">列表：线程1</span><br><span class="line">添加第2个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第3个任务</span><br><span class="line">列表：线程1</span><br><span class="line">列表：线程2</span><br><span class="line">添加第4个任务</span><br><span class="line">列表：线程2</span><br><span class="line">列表：线程4</span><br><span class="line">添加第5个任务</span><br><span class="line">列表：线程4</span><br><span class="line">列表：线程5</span><br><span class="line">线程:pool-1-thread-1 执行:线程0  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程3  run</span><br><span class="line">线程:pool-1-thread-2 执行:线程5  run</span><br><span class="line">线程:pool-1-thread-1 执行:线程4  run</span><br></pre></td></tr></table></figure></li><li>在添加第五个任务时，会被线程池拒绝。这时任务队列中有 任务2，任务3</li><li>这时，拒绝策略会让任务队列中最先加入的任务弹出，也就是任务2.</li><li>然后把被拒绝的任务5添加人任务队列，这时任务队列中就成了 任务3，任务5.</li><li>添加第六个任务时会因为同样的过程，将队列中的任务3抛弃，把任务6加进去，任务队列中就成了 任务5，任务6</li><li>因此，最终能被执行的任务只有1，4，5，6. 任务2和任务3倍抛弃了，不会执行。</li></ol><h3 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h3><p>实现一个让被拒绝的任务在一个新的线程中执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"新线程"</span>+<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">new</span> MyRejectedExecutionHandler());</span><br></pre></td></tr></table></figure><br><a href="https://blog.csdn.net/qq_25806863/article/details/71172823" target="_blank" rel="noopener">来源</a></p><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p><a href="https://www.cnblogs.com/pejsidney/p/9001875.html" target="_blank" rel="noopener">来源</a></p><h2 id="如何实现一个简单的线程池"><a href="#如何实现一个简单的线程池" class="headerlink" title="如何实现一个简单的线程池"></a>如何实现一个简单的线程池</h2><p><a href="https://www.jianshu.com/p/9b7dfb407f72" target="_blank" rel="noopener">来源</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义简单线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span></span>&#123;</span><br><span class="line">    <span class="comment">/**存放线程的集合*/</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;MyThead&gt; threads;</span><br><span class="line">    <span class="comment">/**任务队列*/</span></span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">/**线程池初始限定大小*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line">    <span class="comment">/**已经工作的线程数目*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workThreadNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span><span class="params">(<span class="keyword">int</span> initPoolNum)</span> </span>&#123;</span><br><span class="line">        threadNum = initPoolNum;</span><br><span class="line">        threads = <span class="keyword">new</span> ArrayList&lt;&gt;(initPoolNum);</span><br><span class="line">        <span class="comment">//任务队列初始化为线程池线程数的四倍</span></span><br><span class="line">        taskQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(initPoolNum*<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        threadNum = initPoolNum;</span><br><span class="line">        workThreadNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="comment">//线程池未满，每加入一个任务则开启一个线程</span></span><br><span class="line">            <span class="keyword">if</span>(workThreadNum &lt; threadNum) &#123;</span><br><span class="line">                MyThead myThead = <span class="keyword">new</span> MyThead(runnable);</span><br><span class="line">                myThead.start();</span><br><span class="line">                threads.add(myThead);</span><br><span class="line">                workThreadNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程池已满，放入任务队列，等待有空闲线程时执行</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//队列已满，无法添加时，拒绝任务</span></span><br><span class="line">                <span class="keyword">if</span>(!taskQueue.offer(runnable)) &#123;</span><br><span class="line">                    rejectTask();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rejectTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"任务队列已满，无法继续添加，请扩大您的初始化线程池！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThreadPool myThreadPool = <span class="keyword">new</span> MyThreadPool(<span class="number">5</span>);</span><br><span class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"执行中"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            myThreadPool.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThead</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThead</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = runnable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//该线程一直启动着，不断从任务队列取出任务执行</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//如果初始化任务不为空，则执行初始化任务</span></span><br><span class="line">                <span class="keyword">if</span>(task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则去任务队列取任务并执行</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Runnable queueTask = taskQueue.poll();</span><br><span class="line">                    <span class="keyword">if</span>(queueTask != <span class="keyword">null</span>)</span><br><span class="line">                        queueTask.run();    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>过程:</p><ol><li>初始化线程池，指定线程池的大小。</li><li>向线程池中放入任务执行。</li><li>如果线程池中创建的线程数目未到指定大小，则创建我们自定义的线程类放入线程池集合，并执行任务。执行完了后该线程会一直监听队列</li><li>如果线程池中创建的线程数目已满，则将任务放入缓冲任务队列</li><li>线程池中所有创建的线程，都会一直从缓存任务队列中取任务，取到任务马上执行<h3 id="ThreadPoolExecutor源码分析"><a href="#ThreadPoolExecutor源码分析" class="headerlink" title="ThreadPoolExecutor源码分析"></a>ThreadPoolExecutor源码分析</h3><a href="https://www.jianshu.com/p/9b7dfb407f72" target="_blank" rel="noopener">来源</a></li></ol><h3 id="线程池与异步任务"><a href="#线程池与异步任务" class="headerlink" title="线程池与异步任务"></a>线程池与异步任务</h3><p><a href="https://www.cnblogs.com/wyq1995/p/10076949.html" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用线程池的原因&quot;&gt;&lt;a href=&quot;#使用线程池的原因&quot; class=&quot;headerlink&quot; title=&quot;使用线程池的原因&quot;&gt;&lt;/a&gt;使用线程池的原因&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗&lt;/li&gt;
&lt;li&gt;提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；&lt;/li&gt;
&lt;li&gt;方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/7726c70cdc40&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JAVA多线程" scheme="https://sqwyyy.github.io/categories/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JAVA线程池" scheme="https://sqwyyy.github.io/tags/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
